diff --git a/dist/_chunks/useEncodeDataAttribute-RKZGuQWJ.js b/dist/_chunks/useEncodeDataAttribute-RKZGuQWJ.js
new file mode 100644
index 0000000000000000000000000000000000000000..1e255592210272d3eaa6d90e544f61803a08b289
--- /dev/null
+++ b/dist/_chunks/useEncodeDataAttribute-RKZGuQWJ.js
@@ -0,0 +1,7 @@
+import { encodeDataAttribute } from '@sanity/core-loader/encode-data-attribute';
+import { useCallback } from 'react';
+function useEncodeDataAttribute(result, sourceMap, studioUrl) {
+  return useCallback(path => encodeDataAttribute(result, sourceMap, studioUrl, path), [result, sourceMap, studioUrl]);
+}
+export { useEncodeDataAttribute };
+//# sourceMappingURL=useEncodeDataAttribute-RKZGuQWJ.js.map
diff --git a/dist/_chunks/useEncodeDataAttribute-mY2QBNF1.js.map b/dist/_chunks/useEncodeDataAttribute-RKZGuQWJ.js.map
similarity index 68%
rename from dist/_chunks/useEncodeDataAttribute-mY2QBNF1.js.map
rename to dist/_chunks/useEncodeDataAttribute-RKZGuQWJ.js.map
index 1898c1e41832ccb86f4b45d6258581454ca04a49..cdb46d36b0b62414ac87c7f6885868eff61273dd 100644
--- a/dist/_chunks/useEncodeDataAttribute-mY2QBNF1.js.map
+++ b/dist/_chunks/useEncodeDataAttribute-RKZGuQWJ.js.map
@@ -1 +1 @@
-{"version":3,"file":"useEncodeDataAttribute-mY2QBNF1.js","sources":["../../src/useEncodeDataAttribute.ts"],"sourcesContent":["import type { ContentSourceMap } from '@sanity/client'\nimport type {\n  ResolveStudioUrl,\n  StudioPathLike,\n  StudioUrl,\n} from '@sanity/client/csm'\nimport { encodeDataAttribute } from '@sanity/core-loader/encode-data-attribute'\nimport { useCallback } from 'react'\n\n/** @public */\nexport type EncodeDataAttributeCallback = (\n  path: StudioPathLike,\n) => string | undefined\n\n/** @public */\nexport function useEncodeDataAttribute<QueryResponseResult = unknown>(\n  result: QueryResponseResult,\n  sourceMap: ContentSourceMap | undefined,\n  studioUrl: StudioUrl | ResolveStudioUrl,\n): EncodeDataAttributeCallback {\n  return useCallback(\n    (path) => encodeDataAttribute(result, sourceMap, studioUrl, path),\n    [result, sourceMap, studioUrl],\n  )\n}\n\nexport type { ContentSourceMap, ResolveStudioUrl, StudioPathLike, StudioUrl }\n"],"names":["encodeDataAttribute","useCallback","useEncodeDataAttribute","result","sourceMap","studioUrl","path"],"mappings":"8BAegBA,MAAA,kEAAAC,MAAA,QAAA,SAAAC,EACdC,EACAC,EACAC,GAEO,OAAAJ,GACJK,GAASN,EAAoBG,EAAQC,EAAWC,EAAWC,IAC5D,CAACH,EAAQC,EAAWC,GAExB,QAAAH"}
\ No newline at end of file
+{"version":3,"file":"useEncodeDataAttribute-RKZGuQWJ.js","sources":["../../src/useEncodeDataAttribute.ts"],"sourcesContent":["import type { ContentSourceMap } from '@sanity/client'\nimport type {\n  ResolveStudioUrl,\n  StudioPathLike,\n  StudioUrl,\n} from '@sanity/client/csm'\nimport { encodeDataAttribute } from '@sanity/core-loader/encode-data-attribute'\nimport { useCallback } from 'react'\n\n/** @public */\nexport type EncodeDataAttributeCallback = (\n  path: StudioPathLike,\n) => string | undefined\n\n/** @public */\nexport function useEncodeDataAttribute<QueryResponseResult = unknown>(\n  result: QueryResponseResult,\n  sourceMap: ContentSourceMap | undefined,\n  studioUrl: StudioUrl | ResolveStudioUrl,\n): EncodeDataAttributeCallback {\n  return useCallback(\n    (path) => encodeDataAttribute(result, sourceMap, studioUrl, path),\n    [result, sourceMap, studioUrl],\n  )\n}\n\nexport type { ContentSourceMap, ResolveStudioUrl, StudioPathLike, StudioUrl }\n"],"names":["useEncodeDataAttribute","result","sourceMap","studioUrl","useCallback","path","encodeDataAttribute"],"mappings":";;AAegB,SAAAA,sBAAAA,CACdC,MACA,EAAAC,SAAA,EACAC,SAC6B,EAAA;EACtB,OAAAC,WAAA,CACJC,IAAS,IAAAC,mBAAA,CAAoBL,MAAQ,EAAAC,SAAA,EAAWC,WAAWE,IAAI,CAAA,EAChE,CAACJ,MAAQ,EAAAC,SAAA,EAAWC,SAAS,CAAA,CAC/B;AACF;"}
\ No newline at end of file
diff --git a/dist/_chunks/useEncodeDataAttribute-mY2QBNF1.js b/dist/_chunks/useEncodeDataAttribute-mY2QBNF1.js
deleted file mode 100644
index fa905c18dcab6aeb56b806785a55fcd1a6f5fbb2..0000000000000000000000000000000000000000
diff --git a/dist/_chunks/useEncodeDataAttribute-vXn1EmPc.cjs b/dist/_chunks/useEncodeDataAttribute-vXn1EmPc.cjs
deleted file mode 100644
index e1d81de67034da4cf2a516f702f2445544559b3d..0000000000000000000000000000000000000000
diff --git a/dist/_chunks/useEncodeDataAttribute-wUJAsY0X.cjs b/dist/_chunks/useEncodeDataAttribute-wUJAsY0X.cjs
new file mode 100644
index 0000000000000000000000000000000000000000..5808869efde1e5df38fac6606c82ebbfe204b475
--- /dev/null
+++ b/dist/_chunks/useEncodeDataAttribute-wUJAsY0X.cjs
@@ -0,0 +1,9 @@
+'use strict';
+
+var encodeDataAttribute = require('@sanity/core-loader/encode-data-attribute');
+var react = require('react');
+function useEncodeDataAttribute(result, sourceMap, studioUrl) {
+  return react.useCallback(path => encodeDataAttribute.encodeDataAttribute(result, sourceMap, studioUrl, path), [result, sourceMap, studioUrl]);
+}
+exports.useEncodeDataAttribute = useEncodeDataAttribute;
+//# sourceMappingURL=useEncodeDataAttribute-wUJAsY0X.cjs.map
diff --git a/dist/_chunks/useEncodeDataAttribute-vXn1EmPc.cjs.map b/dist/_chunks/useEncodeDataAttribute-wUJAsY0X.cjs.map
similarity index 67%
rename from dist/_chunks/useEncodeDataAttribute-vXn1EmPc.cjs.map
rename to dist/_chunks/useEncodeDataAttribute-wUJAsY0X.cjs.map
index 5b891d7cffae363c82ac5a44d87585663dfb63d6..ee7e8d9a95232e990bfe7588744a9a8aea0d03f8 100644
--- a/dist/_chunks/useEncodeDataAttribute-vXn1EmPc.cjs.map
+++ b/dist/_chunks/useEncodeDataAttribute-wUJAsY0X.cjs.map
@@ -1 +1 @@
-{"version":3,"file":"useEncodeDataAttribute-vXn1EmPc.cjs","sources":["../../src/useEncodeDataAttribute.ts"],"sourcesContent":["import type { ContentSourceMap } from '@sanity/client'\nimport type {\n  ResolveStudioUrl,\n  StudioPathLike,\n  StudioUrl,\n} from '@sanity/client/csm'\nimport { encodeDataAttribute } from '@sanity/core-loader/encode-data-attribute'\nimport { useCallback } from 'react'\n\n/** @public */\nexport type EncodeDataAttributeCallback = (\n  path: StudioPathLike,\n) => string | undefined\n\n/** @public */\nexport function useEncodeDataAttribute<QueryResponseResult = unknown>(\n  result: QueryResponseResult,\n  sourceMap: ContentSourceMap | undefined,\n  studioUrl: StudioUrl | ResolveStudioUrl,\n): EncodeDataAttributeCallback {\n  return useCallback(\n    (path) => encodeDataAttribute(result, sourceMap, studioUrl, path),\n    [result, sourceMap, studioUrl],\n  )\n}\n\nexport type { ContentSourceMap, ResolveStudioUrl, StudioPathLike, StudioUrl }\n"],"names":["encodeDataAttribute","require","react","exports","u","result","sourceMap","studioUrl","useCallback","path"],"mappings":"AAegB,aAAA,IAAAA,EAAAC,QAAA,6CAAAC,EAAAD,QAAA,SAShBE,QAAAC,EATgB,SACdC,EACAC,EACAC,GAEO,OAAAC,EAAAA,aACJC,GAAST,EAAAA,oBAAoBK,EAAQC,EAAWC,EAAWE,IAC5D,CAACJ,EAAQC,EAAWC,GAExB"}
\ No newline at end of file
+{"version":3,"file":"useEncodeDataAttribute-wUJAsY0X.cjs","sources":["../../src/useEncodeDataAttribute.ts"],"sourcesContent":["import type { ContentSourceMap } from '@sanity/client'\nimport type {\n  ResolveStudioUrl,\n  StudioPathLike,\n  StudioUrl,\n} from '@sanity/client/csm'\nimport { encodeDataAttribute } from '@sanity/core-loader/encode-data-attribute'\nimport { useCallback } from 'react'\n\n/** @public */\nexport type EncodeDataAttributeCallback = (\n  path: StudioPathLike,\n) => string | undefined\n\n/** @public */\nexport function useEncodeDataAttribute<QueryResponseResult = unknown>(\n  result: QueryResponseResult,\n  sourceMap: ContentSourceMap | undefined,\n  studioUrl: StudioUrl | ResolveStudioUrl,\n): EncodeDataAttributeCallback {\n  return useCallback(\n    (path) => encodeDataAttribute(result, sourceMap, studioUrl, path),\n    [result, sourceMap, studioUrl],\n  )\n}\n\nexport type { ContentSourceMap, ResolveStudioUrl, StudioPathLike, StudioUrl }\n"],"names":["useEncodeDataAttribute","result","sourceMap","studioUrl","useCallback","path","encodeDataAttribute"],"mappings":";;;;AAegB,SAAAA,sBAAAA,CACdC,MACA,EAAAC,SAAA,EACAC,SAC6B,EAAA;EACtB,OAAAC,KAAA,CAAAA,WAAA,CACJC,IAAS,IAAAC,mBAAAA,CAAAA,mBAAA,CAAoBL,MAAQ,EAAAC,SAAA,EAAWC,WAAWE,IAAI,CAAA,EAChE,CAACJ,MAAQ,EAAAC,SAAA,EAAWC,SAAS,CAAA,CAC/B;AACF;"}
\ No newline at end of file
diff --git a/dist/index.cjs b/dist/index.cjs
index 6474484291ec63a8aefd5fec43cc5172dd27a2e8..7cec41a1efa121997f4b15b1d848b47d57652ef0 100644
--- a/dist/index.cjs
+++ b/dist/index.cjs
@@ -1 +1,116 @@
-"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var e=require("@sanity/core-loader"),t=require("react"),r=require("./_chunks/useEncodeDataAttribute-vXn1EmPc.cjs");exports.useEncodeDataAttribute=r.u,exports.createQueryStore=r=>{const{createFetcherStore:n,setServerClient:s,enableLiveMode:i,unstable__cache:o,unstable__serverClient:a}=e.createQueryStore(r),u={};return{loadQuery:async(e,t={},r={})=>{const{perspective:n="published"}=r;if("undefined"!=typeof document)throw new Error("Cannot use `loadQuery` in a browser environment, you should use it inside a loader, getStaticProps, getServerSideProps, getInitialProps, or in a React Server Component.");if("published"!==n&&!a.instance)throw new Error('You cannot use other perspectives than "published" unless you set "ssr: true" and call "setServerClient" first.');if("previewDrafts"===n){if(!a.canPreviewDrafts)throw new Error('You cannot use "previewDrafts" unless you set a "token" in the "client" instance you\'re pasing to "setServerClient".');const r=a.instance.config().useCdn?a.instance.withConfig({useCdn:!1}):a.instance,{result:s,resultSourceMap:i}=await r.fetch(e,t,{filterResponse:!1,resultSourceMap:"withKeyArraySelector",perspective:n});return{data:s,sourceMap:i,perspective:n}}const{result:s,resultSourceMap:i}=await o.fetch(JSON.stringify({query:e,params:t}));return i?{data:s,sourceMap:i}:{data:s}},useQuery:(e,r=u,s={})=>{const[i]=t.useState((()=>s.initial?{perspective:"published",...s.initial}:void 0)),o=t.useMemo((()=>JSON.stringify(r)),[r]),[a,c]=t.useState((()=>n(e,JSON.parse(o),i).value));return t.useEffect((()=>{const t=n(e,JSON.parse(o),i).listen((e=>{c(e)}));return()=>t()}),[o,i,e]),a},setServerClient:s,useLiveMode:({allowStudioOrigin:e,client:r,onConnect:n,onDisconnect:s})=>{t.useEffect((()=>{const t=i({allowStudioOrigin:e,client:r,onConnect:n,onDisconnect:s});return()=>t()}),[e,r,n,s])}}};//# sourceMappingURL=index.cjs.map
+'use strict';
+
+Object.defineProperty(exports, '__esModule', {
+  value: true
+});
+var coreLoader = require('@sanity/core-loader');
+var react = require('react');
+var useEncodeDataAttribute = require('./_chunks/useEncodeDataAttribute-wUJAsY0X.cjs');
+const createQueryStore = options => {
+  const {
+    createFetcherStore,
+    setServerClient,
+    enableLiveMode,
+    unstable__cache,
+    unstable__serverClient
+  } = coreLoader.createQueryStore(options);
+  const DEFAULT_PARAMS = {};
+  const useQuery = (query, params = DEFAULT_PARAMS, options2 = {}) => {
+    const [initial, setInitial] = react.useState(() => options2.initial ? {
+      perspective: "published",
+      ...options2.initial
+    } : void 0);
+    const $initial = options2.initial;
+    react.useEffect(() => {
+      setInitial(() => $initial ? {
+        perspective: "published",
+        ...$initial
+      } : void 0);
+    }, [$initial]);
+    const $params = react.useMemo(() => JSON.stringify(params), [params]);
+    const [snapshot, setSnapshot] = react.useState(() => {
+      const fetcher = createFetcherStore(query, JSON.parse($params), initial);
+      return fetcher.value;
+    });
+    react.useEffect(() => {
+      const fetcher = createFetcherStore(query, JSON.parse($params), initial);
+      setSnapshot(fetcher.value);
+      const unlisten = fetcher.listen(snapshot2 => {
+        setSnapshot(snapshot2);
+      });
+      return () => unlisten();
+    }, [$params, initial, query]);
+    return snapshot;
+  };
+  const useLiveMode = ({
+    allowStudioOrigin,
+    client,
+    onConnect,
+    onDisconnect
+  }) => {
+    react.useEffect(() => {
+      const disableLiveMode = enableLiveMode({
+        allowStudioOrigin,
+        client,
+        onConnect,
+        onDisconnect
+      });
+      return () => disableLiveMode();
+    }, [allowStudioOrigin, client, onConnect, onDisconnect]);
+  };
+  const loadQuery = async (query, params = {}, options2 = {}) => {
+    const {
+      perspective = "published"
+    } = options2;
+    if (typeof document !== "undefined") {
+      throw new Error("Cannot use `loadQuery` in a browser environment, you should use it inside a loader, getStaticProps, getServerSideProps, getInitialProps, or in a React Server Component.");
+    }
+    if (perspective !== "published" && !unstable__serverClient.instance) {
+      throw new Error(`You cannot use other perspectives than "published" unless you set "ssr: true" and call "setServerClient" first.`);
+    }
+    if (perspective === "previewDrafts") {
+      if (!unstable__serverClient.canPreviewDrafts) {
+        throw new Error(`You cannot use "previewDrafts" unless you set a "token" in the "client" instance you're pasing to "setServerClient".`);
+      }
+      const client = unstable__serverClient.instance.config().useCdn ? unstable__serverClient.instance.withConfig({
+        useCdn: false
+      }) : unstable__serverClient.instance;
+      const {
+        result: result2,
+        resultSourceMap: resultSourceMap2
+      } = await client.fetch(query, params, {
+        filterResponse: false,
+        resultSourceMap: "withKeyArraySelector",
+        perspective
+      });
+      return {
+        data: result2,
+        sourceMap: resultSourceMap2,
+        perspective
+      };
+    }
+    const {
+      result,
+      resultSourceMap
+    } = await unstable__cache.fetch(JSON.stringify({
+      query,
+      params
+    }));
+    return resultSourceMap ? {
+      data: result,
+      sourceMap: resultSourceMap
+    } : {
+      data: result
+    };
+  };
+  return {
+    loadQuery,
+    // @ts-expect-error - update typings
+    useQuery,
+    setServerClient,
+    useLiveMode
+  };
+};
+exports.useEncodeDataAttribute = useEncodeDataAttribute.useEncodeDataAttribute;
+exports.createQueryStore = createQueryStore;
+//# sourceMappingURL=index.cjs.map
diff --git a/dist/index.cjs.map b/dist/index.cjs.map
index 1f69728ecf32dcafb1d83cbf501394e03d10a3eb..e9a1d87f0a624813185097275522a98353258e73 100644
--- a/dist/index.cjs.map
+++ b/dist/index.cjs.map
@@ -1 +1 @@
-{"version":3,"file":"index.cjs","sources":["../src/index.ts"],"sourcesContent":["import type {\n  ClientPerspective,\n  ContentSourceMap,\n  QueryParams,\n} from '@sanity/client'\nimport {\n  createQueryStore as createCoreQueryStore,\n  type CreateQueryStoreOptions,\n  EnableLiveModeOptions,\n  type QueryStoreState,\n} from '@sanity/core-loader'\nimport { useEffect, useMemo, useState } from 'react'\n\nexport type * from '@sanity/core-loader'\n\nexport type UseQueryHook = <\n  QueryResponseResult = unknown,\n  QueryResponseError = unknown,\n>(\n  query: string,\n  params?: QueryParams,\n  options?: UseQueryOptions<QueryResponseResult>,\n) => QueryStoreState<QueryResponseResult, QueryResponseError>\nexport interface UseQueryOptions<QueryResponseResult = unknown> {\n  /**\n   * Initial `data` and `sourceMap`, used with SSR hydration and is required if `ssr: true`\n   * and an optional speed optimization if `ssr: false`.\n   * It's recommended to set `initial` to the return value of `loadQuery()`.\n   * @example\n   * ```ts\n   * const query = `*[_type == \"author\" && slug.current == $slug][0]`\n   * export const getServerSideProps = async ({params}) => {\n   *   const initial = await loadQuery<AuhthorType>(query, params)\n   *   return { props: { params, initial } }\n   * }\n   * export default function Page({params, initial}) {\n   *   const {data} = useQuery<AuthorType>(query, params, {initial})\n   * }\n   * ```\n   */\n  initial?: {\n    data: QueryResponseResult\n    sourceMap?: ContentSourceMap\n    /**\n     * The perspective used to fetch the data, if not provided it'll assume 'published'\n     */\n    perspective?: ClientPerspective\n  }\n}\nexport type UseLiveModeHook = (options: EnableLiveModeOptions) => void\n\nexport interface QueryStore {\n  loadQuery: <QueryResponseResult>(\n    query: string,\n    params?: QueryParams,\n    options?: { perspective?: ClientPerspective },\n  ) => Promise<{\n    data: QueryResponseResult\n    sourceMap?: ContentSourceMap\n    perspective?: ClientPerspective\n  }>\n  setServerClient: ReturnType<typeof createCoreQueryStore>['setServerClient']\n  useQuery: UseQueryHook\n  useLiveMode: UseLiveModeHook\n}\n\nexport interface QueryOptions<T = 'next'> {\n  /**\n   * The perspective used to fetch the data, if not provided it'll assume 'published'\n   */\n  perspective?: ClientPerspective\n  cache?: RequestInit['cache']\n  next?: T extends keyof RequestInit ? RequestInit[T] : never\n}\n\nexport const createQueryStore = (\n  options: CreateQueryStoreOptions,\n): QueryStore => {\n  const {\n    createFetcherStore,\n    setServerClient,\n    enableLiveMode,\n    unstable__cache,\n    unstable__serverClient,\n  } = createCoreQueryStore(options)\n  const DEFAULT_PARAMS = {}\n  const useQuery = <QueryResponseResult, QueryResponseError>(\n    query: string,\n    params: QueryParams = DEFAULT_PARAMS,\n    options: UseQueryOptions<QueryResponseResult> = {},\n  ) => {\n    const [initial] = useState(() =>\n      options.initial\n        ? { perspective: 'published' as const, ...options.initial }\n        : undefined,\n    )\n    const $params = useMemo(() => JSON.stringify(params), [params])\n\n    const [snapshot, setSnapshot] = useState<\n      QueryStoreState<QueryResponseResult, QueryResponseError>\n    >(() => {\n      const fetcher = createFetcherStore<\n        QueryResponseResult,\n        QueryResponseError\n      >(query, JSON.parse($params), initial)\n      return fetcher.value!\n    })\n    useEffect(() => {\n      const fetcher = createFetcherStore<\n        QueryResponseResult,\n        QueryResponseError\n      >(query, JSON.parse($params), initial)\n      const unlisten = fetcher.listen((snapshot) => {\n        setSnapshot(snapshot)\n      })\n\n      return () => unlisten()\n    }, [$params, initial, query])\n\n    return snapshot\n  }\n\n  const useLiveMode: UseLiveModeHook = ({\n    allowStudioOrigin,\n    client,\n    onConnect,\n    onDisconnect,\n  }) => {\n    useEffect(() => {\n      const disableLiveMode = enableLiveMode({\n        allowStudioOrigin,\n        client,\n        onConnect,\n        onDisconnect,\n      })\n      return () => disableLiveMode()\n    }, [allowStudioOrigin, client, onConnect, onDisconnect])\n  }\n  const loadQuery = async <QueryResponseResult>(\n    query: string,\n    params: QueryParams = {},\n    options: QueryOptions = {},\n  ): Promise<{\n    data: QueryResponseResult\n    sourceMap?: ContentSourceMap\n    perspective?: ClientPerspective\n  }> => {\n    const { perspective = 'published' } = options\n    if (typeof document !== 'undefined') {\n      throw new Error(\n        'Cannot use `loadQuery` in a browser environment, you should use it inside a loader, getStaticProps, getServerSideProps, getInitialProps, or in a React Server Component.',\n      )\n    }\n    if (perspective !== 'published' && !unstable__serverClient.instance) {\n      throw new Error(\n        `You cannot use other perspectives than \"published\" unless you set \"ssr: true\" and call \"setServerClient\" first.`,\n      )\n    }\n    if (perspective === 'previewDrafts') {\n      if (!unstable__serverClient.canPreviewDrafts) {\n        throw new Error(\n          `You cannot use \"previewDrafts\" unless you set a \"token\" in the \"client\" instance you're pasing to \"setServerClient\".`,\n        )\n      }\n      // Necessary with a new client instanec as `useCdn` can't be set on `client.fetch`\n      const client = unstable__serverClient.instance!.config().useCdn\n        ? unstable__serverClient.instance!.withConfig({ useCdn: false })\n        : unstable__serverClient.instance!\n      const { result, resultSourceMap } =\n        await client!.fetch<QueryResponseResult>(query, params, {\n          filterResponse: false,\n          resultSourceMap: 'withKeyArraySelector',\n          perspective,\n        })\n      return { data: result, sourceMap: resultSourceMap, perspective }\n    }\n    const { result, resultSourceMap } =\n      await unstable__cache.fetch<QueryResponseResult>(\n        JSON.stringify({ query, params }),\n      )\n    return resultSourceMap\n      ? { data: result, sourceMap: resultSourceMap }\n      : { data: result }\n  }\n\n  return {\n    loadQuery,\n    useQuery,\n    setServerClient,\n    useLiveMode,\n  }\n}\n\nexport * from './useEncodeDataAttribute'\n"],"names":["Object","defineProperty","exports","value","coreLoader","require","react","useEncodeDataAttribute","u","createQueryStore","options","createFetcherStore","setServerClient","enableLiveMode","unstable__cache","unstable__serverClient","createCoreQueryStore","DEFAULT_PARAMS","loadQuery","async","query","params","perspective","document","Error","instance","canPreviewDrafts","client","config","useCdn","withConfig","result","resultSourceMap","fetch","filterResponse","data","sourceMap","JSON","stringify","useQuery","initial","useState","$params","useMemo","snapshot","setSnapshot","parse","useEffect","unlisten","listen","useLiveMode","allowStudioOrigin","onConnect","onDisconnect","disableLiveMode"],"mappings":"AA2Ea,aAAAA,OAAAC,eAAAC,QAAA,aAAA,CAAAC,OAAA,IAAA,IAAAC,EAAAC,QAAA,uBAAAC,EAAAD,QAAA,SAAAE,EAAAF,QAAA,iDAoHbH,QAAAK,uBAAAA,EAAAC,EAAAN,QAAAO,iBAnHEC,IAEM,MAAAC,mBACJA,EAAAC,gBACAA,EAAAC,eACAA,EAAAC,gBACAA,EAAAC,uBACAA,GACEC,EAAAA,iBAAqBN,GACnBO,EAAiB,CAAA,EAoGhB,MAAA,CACLC,UAhDgBC,MAChBC,EACAC,EAAsB,CACtBX,EAAAA,EAAwB,MAMlB,MAAAY,YAAEA,EAAc,aAAgBZ,EAClC,GAAoB,oBAAba,SACT,MAAM,IAAIC,MACR,4KAGJ,GAAoB,cAAhBF,IAAgCP,EAAuBU,SACzD,MAAM,IAAID,MACR,mHAGJ,GAAoB,kBAAhBF,EAAiC,CAC/B,IAACP,EAAuBW,iBAC1B,MAAM,IAAIF,MACR,yHAIJ,MAAMG,EAASZ,EAAuBU,SAAUG,SAASC,OACrDd,EAAuBU,SAAUK,WAAW,CAAED,QAAQ,IACtDd,EAAuBU,UACnBM,OAAAA,EAAQC,gBAAAA,SACRL,EAAQM,MAA2Bb,EAAOC,EAAQ,CACtDa,gBAAgB,EAChBF,gBAAiB,uBACjBV,gBAEJ,MAAO,CAAEa,KAAMJ,EAAQK,UAAWJ,EAAiBV,cACrD,CACA,MAAMS,OAAEA,EAAAC,gBAAQA,SACRlB,EAAgBmB,MACpBI,KAAKC,UAAU,CAAElB,QAAOC,YAErB,OAAAW,EACH,CAAEG,KAAMJ,EAAQK,UAAWJ,GAC3B,CAAEG,KAAMJ,EAAO,EAKnBQ,SArGeA,CACfnB,EACAC,EAAsBJ,EACtBP,EAAgD,MAE1C,MAAC8B,GAAWC,EAAAA,UAAS,IACzB/B,EAAQ8B,QACJ,CAAElB,YAAa,eAAyBZ,EAAQ8B,cAChD,IAEAE,EAAUC,WAAQ,IAAMN,KAAKC,UAAUjB,IAAS,CAACA,KAEhDuB,EAAUC,GAAeJ,YAE9B,IACgB9B,EAGdS,EAAOiB,KAAKS,MAAMJ,GAAUF,GACfrC,QAcV,OAZP4C,EAAAA,WAAU,KACR,MAIMC,EAJUrC,EAGdS,EAAOiB,KAAKS,MAAMJ,GAAUF,GACLS,QAAQL,IAC/BC,EAAYD,EAAQ,IAGtB,MAAO,IAAMI,GAAS,GACrB,CAACN,EAASF,EAASpB,IAEfwB,CAAA,EAqEPhC,kBACAsC,YAnEmCA,EACnCC,oBACAxB,SACAyB,YACAC,mBAEAN,EAAAA,WAAU,KACR,MAAMO,EAAkBzC,EAAe,CACrCsC,oBACAxB,SACAyB,YACAC,iBAEF,MAAO,IAAMC,GAAgB,GAC5B,CAACH,EAAmBxB,EAAQyB,EAAWC,GAAa,EAsDzD"}
\ No newline at end of file
+{"version":3,"file":"index.cjs","sources":["../src/createQueryStore.ts"],"sourcesContent":["import type { QueryParams } from '@sanity/client'\nimport {\n  createQueryStore as createCoreQueryStore,\n  type CreateQueryStoreOptions,\n  type QueryStoreState,\n} from '@sanity/core-loader'\nimport { useEffect, useMemo, useState } from 'react'\n\nimport {\n  QueryResponseInitial,\n  QueryStore,\n  UseLiveModeHook,\n  UseQueryOptions,\n} from './types'\n\nexport const createQueryStore = (\n  options: CreateQueryStoreOptions,\n): QueryStore => {\n  const {\n    createFetcherStore,\n    setServerClient,\n    enableLiveMode,\n    unstable__cache,\n    unstable__serverClient,\n  } = createCoreQueryStore(options)\n  const DEFAULT_PARAMS = {}\n  const useQuery = <QueryResponseResult, QueryResponseError>(\n    query: string,\n    params: QueryParams = DEFAULT_PARAMS,\n    options: UseQueryOptions<QueryResponseResult> = {},\n  ) => {\n    const [initial, setInitial] = useState(() =>\n      options.initial\n        ? { perspective: 'published' as const, ...options.initial }\n        : undefined,\n    )\n\n    const $initial = options.initial\n\n    useEffect(() => {\n      setInitial(() =>\n        $initial\n          ? { perspective: 'published' as const, ...$initial }\n          : undefined,\n      )\n    }, [$initial])\n\n    const $params = useMemo(() => JSON.stringify(params), [params])\n\n    const [snapshot, setSnapshot] = useState<\n      QueryStoreState<QueryResponseResult, QueryResponseError>\n    >(() => {\n      const fetcher = createFetcherStore<\n        QueryResponseResult,\n        QueryResponseError\n      >(query, JSON.parse($params), initial)\n      return fetcher.value!\n    })\n    useEffect(() => {\n      const fetcher = createFetcherStore<\n        QueryResponseResult,\n        QueryResponseError\n      >(query, JSON.parse($params), initial)\n      setSnapshot(fetcher.value!)\n      const unlisten = fetcher.listen((snapshot) => {\n        setSnapshot(snapshot)\n      })\n\n      return () => unlisten()\n    }, [$params, initial, query])\n\n    return snapshot\n  }\n\n  const useLiveMode: UseLiveModeHook = ({\n    allowStudioOrigin,\n    client,\n    onConnect,\n    onDisconnect,\n  }) => {\n    useEffect(() => {\n      const disableLiveMode = enableLiveMode({\n        allowStudioOrigin,\n        client,\n        onConnect,\n        onDisconnect,\n      })\n      return () => disableLiveMode()\n    }, [allowStudioOrigin, client, onConnect, onDisconnect])\n  }\n  const loadQuery = async <QueryResponseResult>(\n    query: string,\n    params: QueryParams = {},\n    options: Parameters<QueryStore['loadQuery']>[2] = {},\n  ): Promise<QueryResponseInitial<QueryResponseResult>> => {\n    const { perspective = 'published' } = options\n    if (typeof document !== 'undefined') {\n      throw new Error(\n        'Cannot use `loadQuery` in a browser environment, you should use it inside a loader, getStaticProps, getServerSideProps, getInitialProps, or in a React Server Component.',\n      )\n    }\n    if (perspective !== 'published' && !unstable__serverClient.instance) {\n      throw new Error(\n        `You cannot use other perspectives than \"published\" unless you set \"ssr: true\" and call \"setServerClient\" first.`,\n      )\n    }\n    if (perspective === 'previewDrafts') {\n      if (!unstable__serverClient.canPreviewDrafts) {\n        throw new Error(\n          `You cannot use \"previewDrafts\" unless you set a \"token\" in the \"client\" instance you're pasing to \"setServerClient\".`,\n        )\n      }\n      // Necessary with a new client instanec as `useCdn` can't be set on `client.fetch`\n      const client = unstable__serverClient.instance!.config().useCdn\n        ? unstable__serverClient.instance!.withConfig({ useCdn: false })\n        : unstable__serverClient.instance!\n      const { result, resultSourceMap } =\n        await client!.fetch<QueryResponseResult>(query, params, {\n          filterResponse: false,\n          resultSourceMap: 'withKeyArraySelector',\n          perspective,\n        })\n      return { data: result, sourceMap: resultSourceMap, perspective }\n    }\n    const { result, resultSourceMap } =\n      await unstable__cache.fetch<QueryResponseResult>(\n        JSON.stringify({ query, params }),\n      )\n    // @ts-expect-error - update typings\n    return resultSourceMap\n      ? { data: result, sourceMap: resultSourceMap }\n      : { data: result }\n  }\n\n  return {\n    loadQuery,\n    // @ts-expect-error - update typings\n    useQuery,\n    setServerClient,\n    useLiveMode,\n  }\n}\n"],"names":["createQueryStore","options","createFetcherStore","setServerClient","enableLiveMode","unstable__cache","unstable__serverClient","createCoreQueryStore","DEFAULT_PARAMS","useQuery","query","params","initial","setInitial","useState","perspective","$initial","useEffect","$params","useMemo","JSON","stringify","snapshot","setSnapshot","fetcher","parse","value","unlisten","listen","useLiveMode","allowStudioOrigin","client","onConnect","onDisconnect","disableLiveMode","loadQuery","document","Error","instance","canPreviewDrafts","config","useCdn","withConfig","result","resultSourceMap","fetch","filterResponse","data","sourceMap"],"mappings":"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"}
\ No newline at end of file
diff --git a/dist/index.d.ts b/dist/index.d.ts
index 3049c1a65f600330068b8527ebb9cb29500e5aa8..378275bfc62674ef4df6202794ee48578b3860fe 100644
--- a/dist/index.d.ts
+++ b/dist/index.d.ts
@@ -20,29 +20,45 @@ export declare type EncodeDataAttributeCallback = (
   path: StudioPathLike,
 ) => string | undefined
 
-export declare interface QueryOptions<T = 'next'> {
+declare type NonUndefinedGuard<T> = T extends undefined ? never : T
+
+declare interface QueryResponseInitial<QueryResponseResult> {
+  data: QueryResponseResult
+  sourceMap: ContentSourceMap | undefined
   /**
    * The perspective used to fetch the data, if not provided it'll assume 'published'
    */
   perspective?: ClientPerspective
-  cache?: RequestInit['cache']
-  next?: T extends keyof RequestInit ? RequestInit[T] : never
 }
 
-export declare interface QueryStore {
+declare interface QueryStore<
+  LoadQueryOptions = {
+    perspective?: ClientPerspective
+  },
+> {
   loadQuery: <QueryResponseResult>(
     query: string,
     params?: QueryParams,
-    options?: {
-      perspective?: ClientPerspective
-    },
-  ) => Promise<{
-    data: QueryResponseResult
-    sourceMap?: ContentSourceMap
-    perspective?: ClientPerspective
-  }>
+    options?: LoadQueryOptions,
+  ) => Promise<QueryResponseInitial<QueryResponseResult>>
   setServerClient: ReturnType<typeof createQueryStore_2>['setServerClient']
-  useQuery: UseQueryHook
+  useQuery: {
+    <QueryResponseResult = unknown, QueryResponseError = unknown>(
+      query: string,
+      params?: QueryParams,
+      options?: UseQueryOptionsUndefinedInitial,
+    ): QueryStoreState<QueryResponseResult, QueryResponseError>
+    <QueryResponseResult = unknown, QueryResponseError = unknown>(
+      query: string,
+      params?: QueryParams,
+      options?: UseQueryOptionsDefinedInitial<QueryResponseResult>,
+    ): Omit<
+      QueryStoreState<QueryResponseResult, QueryResponseError>,
+      'data'
+    > & {
+      data: QueryResponseResult
+    }
+  }
   useLiveMode: UseLiveModeHook
 }
 
@@ -59,18 +75,9 @@ export declare function useEncodeDataAttribute<QueryResponseResult = unknown>(
   studioUrl: StudioUrl | ResolveStudioUrl,
 ): EncodeDataAttributeCallback
 
-export declare type UseLiveModeHook = (options: EnableLiveModeOptions) => void
-
-export declare type UseQueryHook = <
-  QueryResponseResult = unknown,
-  QueryResponseError = unknown,
->(
-  query: string,
-  params?: QueryParams,
-  options?: UseQueryOptions<QueryResponseResult>,
-) => QueryStoreState<QueryResponseResult, QueryResponseError>
+declare type UseLiveModeHook = (options: EnableLiveModeOptions) => void
 
-export declare interface UseQueryOptions<QueryResponseResult = unknown> {
+declare interface UseQueryOptionsDefinedInitial<QueryResponseResult = unknown> {
   /**
    * Initial `data` and `sourceMap`, used with SSR hydration and is required if `ssr: true`
    * and an optional speed optimization if `ssr: false`.
@@ -87,16 +94,27 @@ export declare interface UseQueryOptions<QueryResponseResult = unknown> {
    * }
    * ```
    */
-  initial?: {
-    data: QueryResponseResult
-    sourceMap?: ContentSourceMap
-    /**
-     * The perspective used to fetch the data, if not provided it'll assume 'published'
-     */
-    perspective?: ClientPerspective
-  }
+  initial: NonUndefinedGuard<QueryResponseInitial<QueryResponseResult>>
 }
 
-export * from '@sanity/core-loader'
+declare interface UseQueryOptionsUndefinedInitial {
+  /**
+   * Initial `data` and `sourceMap`, used with SSR hydration and is required if `ssr: true`
+   * and an optional speed optimization if `ssr: false`.
+   * It's recommended to set `initial` to the return value of `loadQuery()`.
+   * @example
+   * ```ts
+   * const query = `*[_type == "author" && slug.current == $slug][0]`
+   * export const getServerSideProps = async ({params}) => {
+   *   const initial = await loadQuery<AuhthorType>(query, params)
+   *   return { props: { params, initial } }
+   * }
+   * export default function Page({params, initial}) {
+   *   const {data} = useQuery<AuthorType>(query, params, {initial})
+   * }
+   * ```
+   */
+  initial?: undefined
+}
 
 export {}
diff --git a/dist/index.js b/dist/index.js
index 81255babeaaecbe18d89668ae39aa18922ec1291..55b931abc138828a58f17089766111208b663a84 100644
--- a/dist/index.js
+++ b/dist/index.js
@@ -1 +1,110 @@
-import{createQueryStore as e}from"@sanity/core-loader";import{useState as t,useMemo as r,useEffect as n}from"react";export{u as useEncodeDataAttribute}from"./_chunks/useEncodeDataAttribute-mY2QBNF1.js";const s=s=>{const{createFetcherStore:i,setServerClient:o,enableLiveMode:a,unstable__cache:u,unstable__serverClient:c}=e(s),l={};return{loadQuery:async(e,t={},r={})=>{const{perspective:n="published"}=r;if("undefined"!=typeof document)throw new Error("Cannot use `loadQuery` in a browser environment, you should use it inside a loader, getStaticProps, getServerSideProps, getInitialProps, or in a React Server Component.");if("published"!==n&&!c.instance)throw new Error('You cannot use other perspectives than "published" unless you set "ssr: true" and call "setServerClient" first.');if("previewDrafts"===n){if(!c.canPreviewDrafts)throw new Error('You cannot use "previewDrafts" unless you set a "token" in the "client" instance you\'re pasing to "setServerClient".');const r=c.instance.config().useCdn?c.instance.withConfig({useCdn:!1}):c.instance,{result:s,resultSourceMap:i}=await r.fetch(e,t,{filterResponse:!1,resultSourceMap:"withKeyArraySelector",perspective:n});return{data:s,sourceMap:i,perspective:n}}const{result:s,resultSourceMap:i}=await u.fetch(JSON.stringify({query:e,params:t}));return i?{data:s,sourceMap:i}:{data:s}},useQuery:(e,s=l,o={})=>{const[a]=t((()=>o.initial?{perspective:"published",...o.initial}:void 0)),u=r((()=>JSON.stringify(s)),[s]),[c,p]=t((()=>i(e,JSON.parse(u),a).value));return n((()=>{const t=i(e,JSON.parse(u),a).listen((e=>{p(e)}));return()=>t()}),[u,a,e]),c},setServerClient:o,useLiveMode:({allowStudioOrigin:e,client:t,onConnect:r,onDisconnect:s})=>{n((()=>{const n=a({allowStudioOrigin:e,client:t,onConnect:r,onDisconnect:s});return()=>n()}),[e,t,r,s])}}};export{s as createQueryStore};//# sourceMappingURL=index.js.map
+import { createQueryStore as createQueryStore$1 } from '@sanity/core-loader';
+import { useState, useEffect, useMemo } from 'react';
+export { useEncodeDataAttribute } from './_chunks/useEncodeDataAttribute-RKZGuQWJ.js';
+const createQueryStore = options => {
+  const {
+    createFetcherStore,
+    setServerClient,
+    enableLiveMode,
+    unstable__cache,
+    unstable__serverClient
+  } = createQueryStore$1(options);
+  const DEFAULT_PARAMS = {};
+  const useQuery = (query, params = DEFAULT_PARAMS, options2 = {}) => {
+    const [initial, setInitial] = useState(() => options2.initial ? {
+      perspective: "published",
+      ...options2.initial
+    } : void 0);
+    const $initial = options2.initial;
+    useEffect(() => {
+      setInitial(() => $initial ? {
+        perspective: "published",
+        ...$initial
+      } : void 0);
+    }, [$initial]);
+    const $params = useMemo(() => JSON.stringify(params), [params]);
+    const [snapshot, setSnapshot] = useState(() => {
+      const fetcher = createFetcherStore(query, JSON.parse($params), initial);
+      return fetcher.value;
+    });
+    useEffect(() => {
+      const fetcher = createFetcherStore(query, JSON.parse($params), initial);
+      setSnapshot(fetcher.value);
+      const unlisten = fetcher.listen(snapshot2 => {
+        setSnapshot(snapshot2);
+      });
+      return () => unlisten();
+    }, [$params, initial, query]);
+    return snapshot;
+  };
+  const useLiveMode = ({
+    allowStudioOrigin,
+    client,
+    onConnect,
+    onDisconnect
+  }) => {
+    useEffect(() => {
+      const disableLiveMode = enableLiveMode({
+        allowStudioOrigin,
+        client,
+        onConnect,
+        onDisconnect
+      });
+      return () => disableLiveMode();
+    }, [allowStudioOrigin, client, onConnect, onDisconnect]);
+  };
+  const loadQuery = async (query, params = {}, options2 = {}) => {
+    const {
+      perspective = "published"
+    } = options2;
+    if (typeof document !== "undefined") {
+      throw new Error("Cannot use `loadQuery` in a browser environment, you should use it inside a loader, getStaticProps, getServerSideProps, getInitialProps, or in a React Server Component.");
+    }
+    if (perspective !== "published" && !unstable__serverClient.instance) {
+      throw new Error(`You cannot use other perspectives than "published" unless you set "ssr: true" and call "setServerClient" first.`);
+    }
+    if (perspective === "previewDrafts") {
+      if (!unstable__serverClient.canPreviewDrafts) {
+        throw new Error(`You cannot use "previewDrafts" unless you set a "token" in the "client" instance you're pasing to "setServerClient".`);
+      }
+      const client = unstable__serverClient.instance.config().useCdn ? unstable__serverClient.instance.withConfig({
+        useCdn: false
+      }) : unstable__serverClient.instance;
+      const {
+        result: result2,
+        resultSourceMap: resultSourceMap2
+      } = await client.fetch(query, params, {
+        filterResponse: false,
+        resultSourceMap: "withKeyArraySelector",
+        perspective
+      });
+      return {
+        data: result2,
+        sourceMap: resultSourceMap2,
+        perspective
+      };
+    }
+    const {
+      result,
+      resultSourceMap
+    } = await unstable__cache.fetch(JSON.stringify({
+      query,
+      params
+    }));
+    return resultSourceMap ? {
+      data: result,
+      sourceMap: resultSourceMap
+    } : {
+      data: result
+    };
+  };
+  return {
+    loadQuery,
+    // @ts-expect-error - update typings
+    useQuery,
+    setServerClient,
+    useLiveMode
+  };
+};
+export { createQueryStore };
+//# sourceMappingURL=index.js.map
diff --git a/dist/index.js.map b/dist/index.js.map
index b41ae548248ddfd45bd01382453790420058f03c..a2e89cafb4088832124c8c958d009ac388911812 100644
--- a/dist/index.js.map
+++ b/dist/index.js.map
@@ -1 +1 @@
-{"version":3,"file":"index.js","sources":["../src/index.ts"],"sourcesContent":["import type {\n  ClientPerspective,\n  ContentSourceMap,\n  QueryParams,\n} from '@sanity/client'\nimport {\n  createQueryStore as createCoreQueryStore,\n  type CreateQueryStoreOptions,\n  EnableLiveModeOptions,\n  type QueryStoreState,\n} from '@sanity/core-loader'\nimport { useEffect, useMemo, useState } from 'react'\n\nexport type * from '@sanity/core-loader'\n\nexport type UseQueryHook = <\n  QueryResponseResult = unknown,\n  QueryResponseError = unknown,\n>(\n  query: string,\n  params?: QueryParams,\n  options?: UseQueryOptions<QueryResponseResult>,\n) => QueryStoreState<QueryResponseResult, QueryResponseError>\nexport interface UseQueryOptions<QueryResponseResult = unknown> {\n  /**\n   * Initial `data` and `sourceMap`, used with SSR hydration and is required if `ssr: true`\n   * and an optional speed optimization if `ssr: false`.\n   * It's recommended to set `initial` to the return value of `loadQuery()`.\n   * @example\n   * ```ts\n   * const query = `*[_type == \"author\" && slug.current == $slug][0]`\n   * export const getServerSideProps = async ({params}) => {\n   *   const initial = await loadQuery<AuhthorType>(query, params)\n   *   return { props: { params, initial } }\n   * }\n   * export default function Page({params, initial}) {\n   *   const {data} = useQuery<AuthorType>(query, params, {initial})\n   * }\n   * ```\n   */\n  initial?: {\n    data: QueryResponseResult\n    sourceMap?: ContentSourceMap\n    /**\n     * The perspective used to fetch the data, if not provided it'll assume 'published'\n     */\n    perspective?: ClientPerspective\n  }\n}\nexport type UseLiveModeHook = (options: EnableLiveModeOptions) => void\n\nexport interface QueryStore {\n  loadQuery: <QueryResponseResult>(\n    query: string,\n    params?: QueryParams,\n    options?: { perspective?: ClientPerspective },\n  ) => Promise<{\n    data: QueryResponseResult\n    sourceMap?: ContentSourceMap\n    perspective?: ClientPerspective\n  }>\n  setServerClient: ReturnType<typeof createCoreQueryStore>['setServerClient']\n  useQuery: UseQueryHook\n  useLiveMode: UseLiveModeHook\n}\n\nexport interface QueryOptions<T = 'next'> {\n  /**\n   * The perspective used to fetch the data, if not provided it'll assume 'published'\n   */\n  perspective?: ClientPerspective\n  cache?: RequestInit['cache']\n  next?: T extends keyof RequestInit ? RequestInit[T] : never\n}\n\nexport const createQueryStore = (\n  options: CreateQueryStoreOptions,\n): QueryStore => {\n  const {\n    createFetcherStore,\n    setServerClient,\n    enableLiveMode,\n    unstable__cache,\n    unstable__serverClient,\n  } = createCoreQueryStore(options)\n  const DEFAULT_PARAMS = {}\n  const useQuery = <QueryResponseResult, QueryResponseError>(\n    query: string,\n    params: QueryParams = DEFAULT_PARAMS,\n    options: UseQueryOptions<QueryResponseResult> = {},\n  ) => {\n    const [initial] = useState(() =>\n      options.initial\n        ? { perspective: 'published' as const, ...options.initial }\n        : undefined,\n    )\n    const $params = useMemo(() => JSON.stringify(params), [params])\n\n    const [snapshot, setSnapshot] = useState<\n      QueryStoreState<QueryResponseResult, QueryResponseError>\n    >(() => {\n      const fetcher = createFetcherStore<\n        QueryResponseResult,\n        QueryResponseError\n      >(query, JSON.parse($params), initial)\n      return fetcher.value!\n    })\n    useEffect(() => {\n      const fetcher = createFetcherStore<\n        QueryResponseResult,\n        QueryResponseError\n      >(query, JSON.parse($params), initial)\n      const unlisten = fetcher.listen((snapshot) => {\n        setSnapshot(snapshot)\n      })\n\n      return () => unlisten()\n    }, [$params, initial, query])\n\n    return snapshot\n  }\n\n  const useLiveMode: UseLiveModeHook = ({\n    allowStudioOrigin,\n    client,\n    onConnect,\n    onDisconnect,\n  }) => {\n    useEffect(() => {\n      const disableLiveMode = enableLiveMode({\n        allowStudioOrigin,\n        client,\n        onConnect,\n        onDisconnect,\n      })\n      return () => disableLiveMode()\n    }, [allowStudioOrigin, client, onConnect, onDisconnect])\n  }\n  const loadQuery = async <QueryResponseResult>(\n    query: string,\n    params: QueryParams = {},\n    options: QueryOptions = {},\n  ): Promise<{\n    data: QueryResponseResult\n    sourceMap?: ContentSourceMap\n    perspective?: ClientPerspective\n  }> => {\n    const { perspective = 'published' } = options\n    if (typeof document !== 'undefined') {\n      throw new Error(\n        'Cannot use `loadQuery` in a browser environment, you should use it inside a loader, getStaticProps, getServerSideProps, getInitialProps, or in a React Server Component.',\n      )\n    }\n    if (perspective !== 'published' && !unstable__serverClient.instance) {\n      throw new Error(\n        `You cannot use other perspectives than \"published\" unless you set \"ssr: true\" and call \"setServerClient\" first.`,\n      )\n    }\n    if (perspective === 'previewDrafts') {\n      if (!unstable__serverClient.canPreviewDrafts) {\n        throw new Error(\n          `You cannot use \"previewDrafts\" unless you set a \"token\" in the \"client\" instance you're pasing to \"setServerClient\".`,\n        )\n      }\n      // Necessary with a new client instanec as `useCdn` can't be set on `client.fetch`\n      const client = unstable__serverClient.instance!.config().useCdn\n        ? unstable__serverClient.instance!.withConfig({ useCdn: false })\n        : unstable__serverClient.instance!\n      const { result, resultSourceMap } =\n        await client!.fetch<QueryResponseResult>(query, params, {\n          filterResponse: false,\n          resultSourceMap: 'withKeyArraySelector',\n          perspective,\n        })\n      return { data: result, sourceMap: resultSourceMap, perspective }\n    }\n    const { result, resultSourceMap } =\n      await unstable__cache.fetch<QueryResponseResult>(\n        JSON.stringify({ query, params }),\n      )\n    return resultSourceMap\n      ? { data: result, sourceMap: resultSourceMap }\n      : { data: result }\n  }\n\n  return {\n    loadQuery,\n    useQuery,\n    setServerClient,\n    useLiveMode,\n  }\n}\n\nexport * from './useEncodeDataAttribute'\n"],"names":["createQueryStore$1","useState","useMemo","useEffect","u","createQueryStore","options","createFetcherStore","setServerClient","enableLiveMode","unstable__cache","unstable__serverClient","createCoreQueryStore","DEFAULT_PARAMS","loadQuery","async","query","params","perspective","document","Error","instance","canPreviewDrafts","client","config","useCdn","withConfig","result","resultSourceMap","fetch","filterResponse","data","sourceMap","JSON","stringify","useQuery","initial","$params","snapshot","setSnapshot","parse","value","unlisten","listen","useLiveMode","allowStudioOrigin","onConnect","onDisconnect","disableLiveMode"],"mappings":"2BA2EaA,MAAA,yCAAAC,aAAAC,eAAAC,MAAA,eAAAC,gCAAA,+CAAA,MAAAC,EACXC,IAEM,MAAAC,mBACJA,EAAAC,gBACAA,EAAAC,eACAA,EAAAC,gBACAA,EAAAC,uBACAA,GACEC,EAAqBN,GACnBO,EAAiB,CAAA,EAoGhB,MAAA,CACLC,UAhDgBC,MAChBC,EACAC,EAAsB,CACtBX,EAAAA,EAAwB,MAMlB,MAAAY,YAAEA,EAAc,aAAgBZ,EAClC,GAAoB,oBAAba,SACT,MAAM,IAAIC,MACR,4KAGJ,GAAoB,cAAhBF,IAAgCP,EAAuBU,SACzD,MAAM,IAAID,MACR,mHAGJ,GAAoB,kBAAhBF,EAAiC,CAC/B,IAACP,EAAuBW,iBAC1B,MAAM,IAAIF,MACR,yHAIJ,MAAMG,EAASZ,EAAuBU,SAAUG,SAASC,OACrDd,EAAuBU,SAAUK,WAAW,CAAED,QAAQ,IACtDd,EAAuBU,UACnBM,OAAAA,EAAQC,gBAAAA,SACRL,EAAQM,MAA2Bb,EAAOC,EAAQ,CACtDa,gBAAgB,EAChBF,gBAAiB,uBACjBV,gBAEJ,MAAO,CAAEa,KAAMJ,EAAQK,UAAWJ,EAAiBV,cACrD,CACA,MAAMS,OAAEA,EAAAC,gBAAQA,SACRlB,EAAgBmB,MACpBI,KAAKC,UAAU,CAAElB,QAAOC,YAErB,OAAAW,EACH,CAAEG,KAAMJ,EAAQK,UAAWJ,GAC3B,CAAEG,KAAMJ,EAAO,EAKnBQ,SArGeA,CACfnB,EACAC,EAAsBJ,EACtBP,EAAgD,MAE1C,MAAC8B,GAAWnC,GAAS,IACzBK,EAAQ8B,QACJ,CAAElB,YAAa,eAAyBZ,EAAQ8B,cAChD,IAEAC,EAAUnC,GAAQ,IAAM+B,KAAKC,UAAUjB,IAAS,CAACA,KAEhDqB,EAAUC,GAAetC,GAE9B,IACgBM,EAGdS,EAAOiB,KAAKO,MAAMH,GAAUD,GACfK,QAcV,OAZPtC,GAAU,KACR,MAIMuC,EAJUnC,EAGdS,EAAOiB,KAAKO,MAAMH,GAAUD,GACLO,QAAQL,IAC/BC,EAAYD,EAAQ,IAGtB,MAAO,IAAMI,GAAS,GACrB,CAACL,EAASD,EAASpB,IAEfsB,CAAA,EAqEP9B,kBACAoC,YAnEmCA,EACnCC,oBACAtB,SACAuB,YACAC,mBAEA5C,GAAU,KACR,MAAM6C,EAAkBvC,EAAe,CACrCoC,oBACAtB,SACAuB,YACAC,iBAEF,MAAO,IAAMC,GAAgB,GAC5B,CAACH,EAAmBtB,EAAQuB,EAAWC,GAAa,EAsDzD,SACF1C"}
\ No newline at end of file
+{"version":3,"file":"index.js","sources":["../src/createQueryStore.ts"],"sourcesContent":["import type { QueryParams } from '@sanity/client'\nimport {\n  createQueryStore as createCoreQueryStore,\n  type CreateQueryStoreOptions,\n  type QueryStoreState,\n} from '@sanity/core-loader'\nimport { useEffect, useMemo, useState } from 'react'\n\nimport {\n  QueryResponseInitial,\n  QueryStore,\n  UseLiveModeHook,\n  UseQueryOptions,\n} from './types'\n\nexport const createQueryStore = (\n  options: CreateQueryStoreOptions,\n): QueryStore => {\n  const {\n    createFetcherStore,\n    setServerClient,\n    enableLiveMode,\n    unstable__cache,\n    unstable__serverClient,\n  } = createCoreQueryStore(options)\n  const DEFAULT_PARAMS = {}\n  const useQuery = <QueryResponseResult, QueryResponseError>(\n    query: string,\n    params: QueryParams = DEFAULT_PARAMS,\n    options: UseQueryOptions<QueryResponseResult> = {},\n  ) => {\n    const [initial, setInitial] = useState(() =>\n      options.initial\n        ? { perspective: 'published' as const, ...options.initial }\n        : undefined,\n    )\n\n    const $initial = options.initial\n\n    useEffect(() => {\n      setInitial(() =>\n        $initial\n          ? { perspective: 'published' as const, ...$initial }\n          : undefined,\n      )\n    }, [$initial])\n\n    const $params = useMemo(() => JSON.stringify(params), [params])\n\n    const [snapshot, setSnapshot] = useState<\n      QueryStoreState<QueryResponseResult, QueryResponseError>\n    >(() => {\n      const fetcher = createFetcherStore<\n        QueryResponseResult,\n        QueryResponseError\n      >(query, JSON.parse($params), initial)\n      return fetcher.value!\n    })\n    useEffect(() => {\n      const fetcher = createFetcherStore<\n        QueryResponseResult,\n        QueryResponseError\n      >(query, JSON.parse($params), initial)\n      setSnapshot(fetcher.value!)\n      const unlisten = fetcher.listen((snapshot) => {\n        setSnapshot(snapshot)\n      })\n\n      return () => unlisten()\n    }, [$params, initial, query])\n\n    return snapshot\n  }\n\n  const useLiveMode: UseLiveModeHook = ({\n    allowStudioOrigin,\n    client,\n    onConnect,\n    onDisconnect,\n  }) => {\n    useEffect(() => {\n      const disableLiveMode = enableLiveMode({\n        allowStudioOrigin,\n        client,\n        onConnect,\n        onDisconnect,\n      })\n      return () => disableLiveMode()\n    }, [allowStudioOrigin, client, onConnect, onDisconnect])\n  }\n  const loadQuery = async <QueryResponseResult>(\n    query: string,\n    params: QueryParams = {},\n    options: Parameters<QueryStore['loadQuery']>[2] = {},\n  ): Promise<QueryResponseInitial<QueryResponseResult>> => {\n    const { perspective = 'published' } = options\n    if (typeof document !== 'undefined') {\n      throw new Error(\n        'Cannot use `loadQuery` in a browser environment, you should use it inside a loader, getStaticProps, getServerSideProps, getInitialProps, or in a React Server Component.',\n      )\n    }\n    if (perspective !== 'published' && !unstable__serverClient.instance) {\n      throw new Error(\n        `You cannot use other perspectives than \"published\" unless you set \"ssr: true\" and call \"setServerClient\" first.`,\n      )\n    }\n    if (perspective === 'previewDrafts') {\n      if (!unstable__serverClient.canPreviewDrafts) {\n        throw new Error(\n          `You cannot use \"previewDrafts\" unless you set a \"token\" in the \"client\" instance you're pasing to \"setServerClient\".`,\n        )\n      }\n      // Necessary with a new client instanec as `useCdn` can't be set on `client.fetch`\n      const client = unstable__serverClient.instance!.config().useCdn\n        ? unstable__serverClient.instance!.withConfig({ useCdn: false })\n        : unstable__serverClient.instance!\n      const { result, resultSourceMap } =\n        await client!.fetch<QueryResponseResult>(query, params, {\n          filterResponse: false,\n          resultSourceMap: 'withKeyArraySelector',\n          perspective,\n        })\n      return { data: result, sourceMap: resultSourceMap, perspective }\n    }\n    const { result, resultSourceMap } =\n      await unstable__cache.fetch<QueryResponseResult>(\n        JSON.stringify({ query, params }),\n      )\n    // @ts-expect-error - update typings\n    return resultSourceMap\n      ? { data: result, sourceMap: resultSourceMap }\n      : { data: result }\n  }\n\n  return {\n    loadQuery,\n    // @ts-expect-error - update typings\n    useQuery,\n    setServerClient,\n    useLiveMode,\n  }\n}\n"],"names":["createQueryStore","options","createFetcherStore","setServerClient","enableLiveMode","unstable__cache","unstable__serverClient","createCoreQueryStore","DEFAULT_PARAMS","useQuery","query","params","initial","setInitial","useState","perspective","$initial","useEffect","$params","useMemo","JSON","stringify","snapshot","setSnapshot","fetcher","parse","value","unlisten","listen","useLiveMode","allowStudioOrigin","client","onConnect","onDisconnect","disableLiveMode","loadQuery","document","Error","instance","canPreviewDrafts","config","useCdn","withConfig","result","resultSourceMap","fetch","filterResponse","data","sourceMap"],"mappings":"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"}
\ No newline at end of file
diff --git a/dist/jsx.cjs b/dist/jsx.cjs
index 25c5bfe6d0fcddc0a07a117202e5685850a2613e..4d4ea45f44dbe260292b3f98b5f0e2569306ceb9 100644
--- a/dist/jsx.cjs
+++ b/dist/jsx.cjs
@@ -1 +1,463 @@
-"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var e=require("react"),t=require("@sanity/client/csm");const r=["a","abbr","address","area","article","aside","audio","b","base","bdi","bdo","big","blockquote","body","br","button","canvas","caption","cite","code","col","colgroup","data","datalist","dd","del","details","dfn","dialog","div","dl","dt","em","embed","fieldset","figcaption","figure","footer","form","h1","h2","h3","h4","h5","h6","head","header","hgroup","hr","html","i","iframe","img","input","ins","kbd","keygen","label","legend","li","link","main","map","mark","menu","menuitem","meta","meter","nav","noscript","object","ol","optgroup","option","output","p","param","picture","pre","progress","q","rp","rt","ruby","s","samp","script","section","select","small","source","span","strong","style","sub","summary","sup","table","tbody","td","textarea","tfoot","th","thead","time","title","tr","track","u","ul","var","video","wbr","webview"];function n(e){return{issues:e}}function i(e){return{output:e}}function o(e,t){return{reason:e?.reason,validation:t.validation,origin:e?.origin||"value",message:t.message,input:t.input,path:t.path,abortEarly:e?.abortEarly,abortPipeEarly:e?.abortPipeEarly,skipPipe:e?.skipPipe}}function a(e,t){return{reason:t,origin:e?.origin,abortEarly:e?.abortEarly,abortPipeEarly:e?.abortPipeEarly,skipPipe:e?.skipPipe}}function s(e,t,r,s){if(!t||!t.length||r?.skipPipe)return i(e);let u,p,c=e;for(const e of t){const t=e(c);if(t.issues){u=u||a(r,s);for(const e of t.issues){const t=o(u,e);p?p.push(t):p=[t]}if(u.abortEarly||u.abortPipeEarly)break}else c=t.output}return p?n(p):i(c)}function u(e,t){return Array.isArray(e)?[void 0,e]:[e,t]}function p(e){return"function"==typeof e?e():e}function c(e,t,r,n,i,o){return{issues:[{reason:t,validation:r,origin:e?.origin||"value",message:p(n),input:i,issues:o,abortEarly:e?.abortEarly,abortPipeEarly:e?.abortPipeEarly,skipPipe:e?.skipPipe}]}}function l(e){return"object"==typeof e&&null!==e&&!Array.isArray(e)}function f(e){return null!==e&&Array.isArray(e)}function d(e){let t="";for(const r of e)"string"!=typeof r?"number"!=typeof r?f(r)?(t&&(t+=":"),t+=`${r.join(",")}}`):r._key&&(t&&(t+=":"),t+=`${r._key}`):(t&&(t+=":"),t+=`${r}`):(t&&(t+="."),t+=r);return t}function y(e,r,n,i){const{mapping:o,pathSuffix:a}=t.resolveMapping(n,r)||{};if(!o)return;if("literal"===o.source.type)return;if("unknown"===o.source.type)return;const s=r.documents[o.source.document],u=r.paths[o.source.path];return s&&u?{baseUrl:e.baseUrl,workspace:e.workspace,tool:e.tool,type:s._type,id:t.getPublishedId(s._id),path:t.studioPath.toString(t.jsonPathToStudioPath(t.resolvedKeyedSourcePath({keyedResultPath:i,pathSuffix:a,sourceBasePath:u})))}:void 0}const h=function(e,t){const[r,n]=u(e,t);return{type:"string",async:!1,_parse:(e,t)=>"string"!=typeof e?c(t,"type","string",r||"Invalid type",e):s(e,n,t,"string")}}([(k=1,e=>e.length<k?function(e,t,r){return n([{validation:e,message:p(t),input:r}])}("min_length",P||"Invalid length",e):i(e))]),b={type:"optional",wrapped:m=h,getDefault:()=>"function"==typeof v?v():v,async:!1,_parse(e,t){if(void 0===e){const t=this.getDefault();if(void 0===t)return i(e);e=t}return m._parse(e,t)}},g=function(e,t,r,i){const[o,a,p]=function(e,t,r){if(!e||"object"==typeof e&&!Array.isArray(e)){const[n,i]=u(t,r);return[e,n,i]}const[n,i]=u(e,t);return[void 0,n,i]}(t,r,i);let l;return{type:"object",entries:e,rest:o,async:!1,_parse(t,r){if(!t||"object"!=typeof t)return c(r,"type","object",a||"Invalid type",t);let i;l=l||Object.entries(e);const u={};for(const[e,n]of l){const o=t[e],a=n._parse(o,r);if(a.issues){const n={type:"object",input:t,key:e,value:o};for(const e of a.issues)e.path?e.path.unshift(n):e.path=[n],i?.push(e);if(i||(i=a.issues),r?.abortEarly)break}else(void 0!==a.output||e in t)&&(u[e]=a.output)}if(o&&(!r?.abortEarly||!i))for(const n in t)if(!(n in e)){const e=t[n],a=o._parse(e,r);if(a.issues){const o={type:"object",input:t,key:n,value:e};for(const e of a.issues)e.path?e.path.unshift(o):e.path=[o],i?.push(e);if(i||(i=a.issues),r?.abortEarly)break}else u[n]=a.output}return i?n(i):s(u,p,r,"object")}}}({id:h,path:h,type:b,baseUrl:h,workspace:b,tool:b});var m,v,k,P;function _(e){const{id:r,path:n,baseUrl:i,tool:o,workspace:a,type:s}=e;if(function(e){return t=e,!g._parse(t,{abortEarly:!0}).issues;var t}(e))return[["id",t.getPublishedId(r)],["type",s],["path",d(t.studioPath.fromString(n))],["base",encodeURIComponent(i)],["workspace",a],["tool",o]].filter((([,e])=>!!e)).map((e=>e.join("="))).join(";")}const E=["_createdAt","_dataset","_id","_key","_originalId","_projectId","_ref","_rev","_strengthenOnPublish","_type","_updatedAt","_weak"];const w=e.forwardRef((function(t,r){const{as:n,children:i,...o}=t;return i?.source?e.createElement(n,{...o,"data-sanity":_(i.source),ref:r},i.value):e.createElement(n,o,i?.value)})),j=["animate","circle","defs","desc","ellipse","g","image","line","filter","marker","mask","metadata","path","pattern","polygon","polyline","rect","stop","svg","switch","symbol","text","tspan","use","view","clipPath","feBlend","feColorMatrix","feComponentTransfer","feComposite","feConvolveMatrix","feDiffuseLighting","feDisplacementMap","feDistantLight","feDropShadow","feFlood","feFuncA","feFuncB","feFuncG","feFuncR","feGaussianBlur","feImage","feMerge","feMergeNode","feMorphology","feOffset","fePointLight","feSpecularLighting","feSpotLight","feTile","feTurbulence","foreignObject","linearGradient","radialGradient","textPath"];const x=new Proxy({},{get(t,n){if(i=n,r.includes(i)){if(t[n])return t[n];const r=e.forwardRef((function(t,r){return e.createElement(w,{as:n,ref:r,...t})}));return r.displayName=`sanity.${n}`,t[n]=r,r}var i;if(function(e){return j.includes(e)}(n)){if(t[n])return t[n];const r=e.forwardRef((function(t,r){return e.createElement(w,{as:n,ref:r,...t})}));return r.displayName=`sanity.${n}`,t[n]=r,r}throw new Error(`No such element: ${n}`)}});exports.encodeSanityNodeData=_,exports.sanity=x,exports.unwrapData=function e(t){if(void 0!==t){if(null===t)return null;if(l(r=t)&&"sanity"===r.$$type$$)return t.value;var r;if(f(t))return t.map((t=>e(t)));if(l(t))return Object.fromEntries(Object.entries(t).map((([t,r])=>E.includes(t)?[t,r]:[t,e(r)])));throw new Error("invalid wrapped value")}},exports.wrapData=function e(r,n,i,o=[],a=[]){if(void 0!==n)return null===n?null:f(n)?n.map(((t,n)=>e(r,t,i,o.concat(n),a.concat(l(t)&&"_key"in t&&"string"==typeof t._key?{_key:t._key,_index:n}:n)))):l(n)?Object.fromEntries(Object.entries(n).map((([t,n])=>E.includes(t)?[t,n]:[t,e(r,n,i,o.concat(t),a.concat(t))]))):{$$type$$:"sanity",path:t.studioPath.toString(t.jsonPathToStudioPath(o))||void 0,source:i?y(r,i,o,a):void 0,value:n}};//# sourceMappingURL=jsx.cjs.map
+'use strict';
+
+Object.defineProperty(exports, '__esModule', {
+  value: true
+});
+var react = require('react');
+var csm = require('@sanity/client/csm');
+const htmlElements = ["a", "abbr", "address", "area", "article", "aside", "audio", "b", "base", "bdi", "bdo", "big", "blockquote", "body", "br", "button", "canvas", "caption", "cite", "code", "col", "colgroup", "data", "datalist", "dd", "del", "details", "dfn", "dialog", "div", "dl", "dt", "em", "embed", "fieldset", "figcaption", "figure", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "iframe", "img", "input", "ins", "kbd", "keygen", "label", "legend", "li", "link", "main", "map", "mark", "menu", "menuitem", "meta", "meter", "nav", "noscript", "object", "ol", "optgroup", "option", "output", "p", "param", "picture", "pre", "progress", "q", "rp", "rt", "ruby", "s", "samp", "script", "section", "select", "small", "source", "span", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "textarea", "tfoot", "th", "thead", "time", "title", "tr", "track", "u", "ul", "var", "video", "wbr", "webview"];
+
+// src/error/flatten/flatten.ts
+
+// src/utils/getIssues/getIssues.ts
+function getIssues(issues) {
+  return {
+    issues
+  };
+}
+
+// src/utils/getOutput/getOutput.ts
+function getOutput(output) {
+  return {
+    output
+  };
+}
+
+// src/utils/executePipe/utils/getIssue/getIssue.ts
+function getIssue(info, issue) {
+  return {
+    reason: info?.reason,
+    validation: issue.validation,
+    origin: info?.origin || "value",
+    message: issue.message,
+    input: issue.input,
+    path: issue.path,
+    abortEarly: info?.abortEarly,
+    abortPipeEarly: info?.abortPipeEarly,
+    skipPipe: info?.skipPipe
+  };
+}
+
+// src/utils/executePipe/utils/getPipeInfo/getPipeInfo.ts
+function getPipeInfo(info, reason) {
+  return {
+    reason,
+    origin: info?.origin,
+    abortEarly: info?.abortEarly,
+    abortPipeEarly: info?.abortPipeEarly,
+    skipPipe: info?.skipPipe
+  };
+}
+
+// src/utils/executePipe/executePipe.ts
+function executePipe(input, pipe, parseInfo, reason) {
+  if (!pipe || !pipe.length || parseInfo?.skipPipe) {
+    return getOutput(input);
+  }
+  let pipeInfo;
+  let issues;
+  let output = input;
+  for (const action of pipe) {
+    const result = action._parse(output);
+    if (result.issues) {
+      pipeInfo = pipeInfo || getPipeInfo(parseInfo, reason);
+      for (const issueInfo of result.issues) {
+        const issue = getIssue(pipeInfo, issueInfo);
+        issues ? issues.push(issue) : issues = [issue];
+      }
+      if (pipeInfo.abortEarly || pipeInfo.abortPipeEarly) {
+        break;
+      }
+    } else {
+      output = result.output;
+    }
+  }
+  return issues ? getIssues(issues) : getOutput(output);
+}
+
+// src/utils/getDefaultArgs/getDefaultArgs.ts
+function getDefaultArgs(arg1, arg2) {
+  return Array.isArray(arg1) ? [void 0, arg1] : [arg1, arg2];
+}
+
+// src/utils/getErrorMessage/getErrorMessage.ts
+function getErrorMessage(message) {
+  return typeof message === "function" ? message() : message;
+}
+
+// src/utils/getPipeIssues/getPipeIssues.ts
+function getPipeIssues(validation, message, input, requirement) {
+  return getIssues([{
+    validation,
+    message: getErrorMessage(message),
+    input,
+    requirement
+  }]);
+}
+
+// src/utils/getRestAndDefaultArgs/getRestAndDefaultArgs.ts
+function getRestAndDefaultArgs(arg1, arg2, arg3) {
+  if (!arg1 || typeof arg1 === "object" && !Array.isArray(arg1)) {
+    const [error2, pipe2] = getDefaultArgs(arg2, arg3);
+    return [arg1, error2, pipe2];
+  }
+  const [error, pipe] = getDefaultArgs(arg1, arg2);
+  return [void 0, error, pipe];
+}
+
+// src/utils/getSchemaIssues/getSchemaIssues.ts
+function getSchemaIssues(info, reason, validation, message, input, issues) {
+  return {
+    issues: [{
+      reason,
+      validation,
+      origin: info?.origin || "value",
+      message: getErrorMessage(message),
+      input,
+      issues,
+      abortEarly: info?.abortEarly,
+      abortPipeEarly: info?.abortPipeEarly,
+      skipPipe: info?.skipPipe
+    }]
+  };
+}
+
+// src/methods/getDefault/getDefault.ts
+function getDefault(schema) {
+  return typeof schema.default === "function" ? schema.default() : schema.default;
+}
+
+// src/methods/is/is.ts
+function is(schema, input) {
+  return !schema._parse(input, {
+    abortEarly: true
+  }).issues;
+}
+
+// src/schemas/object/object.ts
+function object(entries, arg2, arg3, arg4) {
+  const [rest, message = "Invalid type", pipe] = getRestAndDefaultArgs(arg2, arg3, arg4);
+  let cachedEntries;
+  return {
+    type: "object",
+    async: false,
+    entries,
+    rest,
+    message,
+    pipe,
+    _parse(input, info) {
+      if (!input || typeof input !== "object") {
+        return getSchemaIssues(info, "type", "object", this.message, input);
+      }
+      cachedEntries = cachedEntries || Object.entries(this.entries);
+      let issues;
+      const output = {};
+      for (const [key, schema] of cachedEntries) {
+        const value2 = input[key];
+        const result = schema._parse(value2, info);
+        if (result.issues) {
+          const pathItem = {
+            type: "object",
+            input,
+            key,
+            value: value2
+          };
+          for (const issue of result.issues) {
+            if (issue.path) {
+              issue.path.unshift(pathItem);
+            } else {
+              issue.path = [pathItem];
+            }
+            issues?.push(issue);
+          }
+          if (!issues) {
+            issues = result.issues;
+          }
+          if (info?.abortEarly) {
+            break;
+          }
+        } else if (result.output !== void 0 || key in input) {
+          output[key] = result.output;
+        }
+      }
+      if (this.rest && !(info?.abortEarly && issues)) {
+        for (const key in input) {
+          if (!(key in this.entries)) {
+            const value2 = input[key];
+            const result = this.rest._parse(value2, info);
+            if (result.issues) {
+              const pathItem = {
+                type: "object",
+                input,
+                key,
+                value: value2
+              };
+              for (const issue of result.issues) {
+                if (issue.path) {
+                  issue.path.unshift(pathItem);
+                } else {
+                  issue.path = [pathItem];
+                }
+                issues?.push(issue);
+              }
+              if (!issues) {
+                issues = result.issues;
+              }
+              if (info?.abortEarly) {
+                break;
+              }
+            } else {
+              output[key] = result.output;
+            }
+          }
+        }
+      }
+      return issues ? getIssues(issues) : executePipe(output, this.pipe, info, "object");
+    }
+  };
+}
+
+// src/schemas/optional/optional.ts
+function optional(wrapped, default_) {
+  return {
+    type: "optional",
+    async: false,
+    wrapped,
+    default: default_,
+    _parse(input, info) {
+      if (input === void 0) {
+        const override = getDefault(this);
+        if (override === void 0) {
+          return getOutput(input);
+        }
+        input = override;
+      }
+      return this.wrapped._parse(input, info);
+    }
+  };
+}
+
+// src/schemas/string/string.ts
+function string(arg1, arg2) {
+  const [message = "Invalid type", pipe] = getDefaultArgs(arg1, arg2);
+  return {
+    type: "string",
+    async: false,
+    message,
+    pipe,
+    _parse(input, info) {
+      if (typeof input !== "string") {
+        return getSchemaIssues(info, "type", "string", this.message, input);
+      }
+      return executePipe(input, this.pipe, info, "string");
+    }
+  };
+}
+
+// src/validations/minLength/minLength.ts
+function minLength(requirement, message = "Invalid length") {
+  return {
+    type: "min_length",
+    async: false,
+    message,
+    requirement,
+    _parse(input) {
+      return input.length < this.requirement ? getPipeIssues(this.type, this.message, input, this.requirement) : getOutput(input);
+    }
+  };
+}
+function isRecord(value) {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+function isArray(value) {
+  return value !== null && Array.isArray(value);
+}
+function pathToUrlString(path) {
+  let str = "";
+  for (const segment of path) {
+    if (typeof segment === "string") {
+      if (str) str += ".";
+      str += segment;
+      continue;
+    }
+    if (typeof segment === "number") {
+      if (str) str += ":";
+      str += `${segment}`;
+      continue;
+    }
+    if (isArray(segment)) {
+      if (str) str += ":";
+      str += `${segment.join(",")}}`;
+      continue;
+    }
+    if (segment._key) {
+      if (str) str += ":";
+      str += `${segment._key}`;
+      continue;
+    }
+  }
+  return str;
+}
+function resolveSanityNode(context, csm$1, resultPath, keyedResultPath) {
+  const {
+    mapping,
+    pathSuffix
+  } = csm.resolveMapping(resultPath, csm$1) || {};
+  if (!mapping) {
+    return void 0;
+  }
+  if (mapping.source.type === "literal") {
+    return void 0;
+  }
+  if (mapping.source.type === "unknown") {
+    return void 0;
+  }
+  const sourceDoc = csm$1.documents[mapping.source.document];
+  const sourceBasePath = csm$1.paths[mapping.source.path];
+  if (sourceDoc && sourceBasePath) {
+    return {
+      baseUrl: context.baseUrl,
+      workspace: context.workspace,
+      tool: context.tool,
+      type: sourceDoc._type,
+      id: csm.getPublishedId(sourceDoc._id),
+      path: csm.studioPath.toString(csm.jsonPathToStudioPath(csm.resolvedKeyedSourcePath({
+        keyedResultPath,
+        pathSuffix,
+        sourceBasePath
+      })))
+    };
+  }
+  return void 0;
+}
+const lengthyStr = string([minLength(1)]);
+const optionalLengthyStr = optional(lengthyStr);
+const sanityNodeSchema = object({
+  id: lengthyStr,
+  path: lengthyStr,
+  type: optionalLengthyStr,
+  baseUrl: lengthyStr,
+  workspace: optionalLengthyStr,
+  tool: optionalLengthyStr
+});
+function isValidSanityNode(node) {
+  return is(sanityNodeSchema, node);
+}
+function encodeSanityNodeData(node) {
+  const {
+    id: _id,
+    path,
+    baseUrl,
+    tool,
+    workspace,
+    type
+  } = node;
+  if (!isValidSanityNode(node)) {
+    return void 0;
+  }
+  const parts = [["id", csm.getPublishedId(_id)], ["type", type], ["path", pathToUrlString(csm.studioPath.fromString(path))], ["base", encodeURIComponent(baseUrl)], ["workspace", workspace], ["tool", tool]];
+  return parts.filter(([, value]) => !!value).map(part => part.join("=")).join(";");
+}
+const SANITY_KEYS = ["_createdAt", "_dataset", "_id", "_key", "_originalId", "_projectId", "_ref", "_rev", "_strengthenOnPublish", "_type", "_updatedAt", "_weak"];
+function isSourceNode(t) {
+  return isRecord(t) && t.$$type$$ === "sanity";
+}
+function unwrapData(wrapper) {
+  if (wrapper === void 0) {
+    return void 0;
+  }
+  if (wrapper === null) {
+    return null;
+  }
+  if (isSourceNode(wrapper)) {
+    return wrapper.value;
+  }
+  if (isArray(wrapper)) {
+    return wrapper.map(item => unwrapData(item));
+  }
+  if (isRecord(wrapper)) {
+    return Object.fromEntries(Object.entries(wrapper).map(([k, v]) => SANITY_KEYS.includes(k) ? [k, v] : [k, unwrapData(v)]));
+  }
+  throw new Error("invalid wrapped value");
+}
+function wrapData(context, value, sourceMap, resultPath = [], keyedResultPath = []) {
+  if (value === void 0) {
+    return void 0;
+  }
+  if (value === null) {
+    return null;
+  }
+  if (isArray(value)) {
+    return value.map((t, idx) => wrapData(context, t, sourceMap, resultPath.concat(idx), keyedResultPath.concat(isRecord(t) && "_key" in t && typeof t._key === "string" ? {
+      _key: t._key,
+      _index: idx
+    } : idx)));
+  }
+  if (isRecord(value)) {
+    return Object.fromEntries(Object.entries(value).map(([k, v]) => SANITY_KEYS.includes(k) ? [k, v] : [k, wrapData(context, v, sourceMap, resultPath.concat(k), keyedResultPath.concat(k))]));
+  }
+  return {
+    $$type$$: "sanity",
+    path: csm.studioPath.toString(csm.jsonPathToStudioPath(resultPath)) || void 0,
+    source: sourceMap ? resolveSanityNode(context, sourceMap, resultPath, keyedResultPath) : void 0,
+    value
+  };
+}
+const SanityElement = react.forwardRef(function SanityElement2(props, ref) {
+  const {
+    as,
+    children: node,
+    ...restProps
+  } = props;
+  if (node?.source) {
+    return react.createElement(as, {
+      ...restProps,
+      "data-sanity": encodeSanityNodeData(node.source),
+      ref
+    }, node.value);
+  }
+  return react.createElement(as, restProps, node?.value);
+});
+const svgElements = ["animate", "circle", "defs", "desc", "ellipse", "g", "image", "line", "filter", "marker", "mask", "metadata", "path", "pattern", "polygon", "polyline", "rect", "stop", "svg", "switch", "symbol", "text", "tspan", "use", "view", "clipPath", "feBlend", "feColorMatrix", "feComponentTransfer", "feComposite", "feConvolveMatrix", "feDiffuseLighting", "feDisplacementMap", "feDistantLight", "feDropShadow", "feFlood", "feFuncA", "feFuncB", "feFuncG", "feFuncR", "feGaussianBlur", "feImage", "feMerge", "feMergeNode", "feMorphology", "feOffset", "fePointLight", "feSpecularLighting", "feSpotLight", "feTile", "feTurbulence", "foreignObject", "linearGradient", "radialGradient", "textPath"];
+function isHTMLElement(name) {
+  return htmlElements.includes(name);
+}
+function isSVGElement(name) {
+  return svgElements.includes(name);
+}
+const sanity = new Proxy({}, {
+  get(target, prop) {
+    if (isHTMLElement(prop)) {
+      if (target[prop]) return target[prop];
+      const SanityComponent = react.forwardRef(function SanityComponent2(props, ref) {
+        return react.createElement(SanityElement, {
+          as: prop,
+          ref,
+          ...props
+        });
+      });
+      SanityComponent.displayName = `sanity.${prop}`;
+      target[prop] = SanityComponent;
+      return SanityComponent;
+    }
+    if (isSVGElement(prop)) {
+      if (target[prop]) return target[prop];
+      const SanityComponent = react.forwardRef(function SanityComponent2(props, ref) {
+        return react.createElement(SanityElement, {
+          as: prop,
+          ref,
+          ...props
+        });
+      });
+      SanityComponent.displayName = `sanity.${prop}`;
+      target[prop] = SanityComponent;
+      return SanityComponent;
+    }
+    throw new Error(`No such element: ${prop}`);
+  }
+});
+exports.encodeSanityNodeData = encodeSanityNodeData;
+exports.sanity = sanity;
+exports.unwrapData = unwrapData;
+exports.wrapData = wrapData;
+//# sourceMappingURL=jsx.cjs.map
diff --git a/dist/jsx.cjs.map b/dist/jsx.cjs.map
index 2136ffe93354f80eb6c8d588608dd35e9058937a..f2075c9e8fc45a1af7fab663b39682d728bb2905 100644
--- a/dist/jsx.cjs.map
+++ b/dist/jsx.cjs.map
@@ -1 +1 @@
-{"version":3,"file":"jsx.cjs","sources":["../src/jsx/html.ts","../../../node_modules/.pnpm/valibot@0.20.1/node_modules/valibot/dist/index.js","../../visual-editing-helpers/dist/_chunks/urlStringToPath-FefM00gz.js","../../visual-editing-helpers/dist/csm.js","../src/jsx/SanityElement.tsx","../src/jsx/svg.ts","../src/jsx/jsx.ts"],"sourcesContent":["export const htmlElements = [\n  'a',\n  'abbr',\n  'address',\n  'area',\n  'article',\n  'aside',\n  'audio',\n  'b',\n  'base',\n  'bdi',\n  'bdo',\n  'big',\n  'blockquote',\n  'body',\n  'br',\n  'button',\n  'canvas',\n  'caption',\n  'cite',\n  'code',\n  'col',\n  'colgroup',\n  'data',\n  'datalist',\n  'dd',\n  'del',\n  'details',\n  'dfn',\n  'dialog',\n  'div',\n  'dl',\n  'dt',\n  'em',\n  'embed',\n  'fieldset',\n  'figcaption',\n  'figure',\n  'footer',\n  'form',\n  'h1',\n  'h2',\n  'h3',\n  'h4',\n  'h5',\n  'h6',\n  'head',\n  'header',\n  'hgroup',\n  'hr',\n  'html',\n  'i',\n  'iframe',\n  'img',\n  'input',\n  'ins',\n  'kbd',\n  'keygen',\n  'label',\n  'legend',\n  'li',\n  'link',\n  'main',\n  'map',\n  'mark',\n  'menu',\n  'menuitem',\n  'meta',\n  'meter',\n  'nav',\n  'noscript',\n  'object',\n  'ol',\n  'optgroup',\n  'option',\n  'output',\n  'p',\n  'param',\n  'picture',\n  'pre',\n  'progress',\n  'q',\n  'rp',\n  'rt',\n  'ruby',\n  's',\n  'samp',\n  'script',\n  'section',\n  'select',\n  'small',\n  'source',\n  'span',\n  'strong',\n  'style',\n  'sub',\n  'summary',\n  'sup',\n  'table',\n  'tbody',\n  'td',\n  'textarea',\n  'tfoot',\n  'th',\n  'thead',\n  'time',\n  'title',\n  'tr',\n  'track',\n  'u',\n  'ul',\n  'var',\n  'video',\n  'wbr',\n  'webview',\n] as const\n","// src/error/flatten/flatten.ts\nfunction flatten(arg1) {\n  return (Array.isArray(arg1) ? arg1 : arg1.issues).reduce(\n    (flatErrors, issue) => {\n      if (issue.path) {\n        if (issue.path.every(\n          ({ key }) => typeof key === \"string\" || typeof key === \"number\"\n        )) {\n          const path = issue.path.map(({ key }) => key).join(\".\");\n          if (flatErrors.nested[path]) {\n            flatErrors.nested[path].push(issue.message);\n          } else {\n            flatErrors.nested[path] = [issue.message];\n          }\n        }\n      } else {\n        if (flatErrors.root) {\n          flatErrors.root.push(issue.message);\n        } else {\n          flatErrors.root = [issue.message];\n        }\n      }\n      return flatErrors;\n    },\n    { nested: {} }\n  );\n}\n\n// src/error/ValiError/ValiError.ts\nvar ValiError = class extends Error {\n  issues;\n  /**\n   * Creates a Valibot error with useful information.\n   *\n   * @param issues The error issues.\n   */\n  constructor(issues) {\n    super(issues[0].message);\n    this.name = \"ValiError\";\n    this.issues = issues;\n  }\n};\n\n// src/methods/brand/brand.ts\nvar BrandSymbol = Symbol(\"brand\");\nfunction brand(schema, name) {\n  return schema;\n}\n\n// src/methods/coerce/coerce.ts\nfunction coerce(schema, action) {\n  return {\n    ...schema,\n    /**\n     * Parses unknown input based on its schema.\n     *\n     * @param input The input to be parsed.\n     * @param info The parse info.\n     *\n     * @returns The parsed output.\n     */\n    _parse(input, info) {\n      return schema._parse(action(input), info);\n    }\n  };\n}\n\n// src/methods/coerce/coerceAsync.ts\nfunction coerceAsync(schema, action) {\n  return {\n    ...schema,\n    /**\n     * Parses unknown input based on its schema.\n     *\n     * @param input The input to be parsed.\n     * @param info The parse info.\n     *\n     * @returns The parsed output.\n     */\n    async _parse(input, info) {\n      return schema._parse(await action(input), info);\n    }\n  };\n}\n\n// src/utils/getIssues/getIssues.ts\nfunction getIssues(issues) {\n  return { issues };\n}\n\n// src/utils/getOutput/getOutput.ts\nfunction getOutput(output) {\n  return { output };\n}\n\n// src/utils/executePipe/utils/getIssue/getIssue.ts\nfunction getIssue(info, issue) {\n  return {\n    reason: info?.reason,\n    validation: issue.validation,\n    origin: info?.origin || \"value\",\n    message: issue.message,\n    input: issue.input,\n    path: issue.path,\n    abortEarly: info?.abortEarly,\n    abortPipeEarly: info?.abortPipeEarly,\n    skipPipe: info?.skipPipe\n  };\n}\n\n// src/utils/executePipe/utils/getPipeInfo/getPipeInfo.ts\nfunction getPipeInfo(info, reason) {\n  return {\n    reason,\n    origin: info?.origin,\n    abortEarly: info?.abortEarly,\n    abortPipeEarly: info?.abortPipeEarly,\n    skipPipe: info?.skipPipe\n  };\n}\n\n// src/utils/executePipe/executePipe.ts\nfunction executePipe(input, pipe, parseInfo, reason) {\n  if (!pipe || !pipe.length || parseInfo?.skipPipe) {\n    return getOutput(input);\n  }\n  let pipeInfo;\n  let issues;\n  let output = input;\n  for (const action of pipe) {\n    const result = action(output);\n    if (result.issues) {\n      pipeInfo = pipeInfo || getPipeInfo(parseInfo, reason);\n      for (const issueInfo of result.issues) {\n        const issue = getIssue(pipeInfo, issueInfo);\n        issues ? issues.push(issue) : issues = [issue];\n      }\n      if (pipeInfo.abortEarly || pipeInfo.abortPipeEarly) {\n        break;\n      }\n    } else {\n      output = result.output;\n    }\n  }\n  return issues ? getIssues(issues) : getOutput(output);\n}\n\n// src/utils/executePipe/executePipeAsync.ts\nasync function executePipeAsync(input, pipe, parseInfo, reason) {\n  if (!pipe || !pipe.length || parseInfo?.skipPipe) {\n    return getOutput(input);\n  }\n  let pipeInfo;\n  let issues;\n  let output = input;\n  for (const action of pipe) {\n    const result = await action(output);\n    if (result.issues) {\n      pipeInfo = pipeInfo || getPipeInfo(parseInfo, reason);\n      for (const issueInfo of result.issues) {\n        const issue = getIssue(pipeInfo, issueInfo);\n        issues ? issues.push(issue) : issues = [issue];\n      }\n      if (pipeInfo.abortEarly || pipeInfo.abortPipeEarly) {\n        break;\n      }\n    } else {\n      output = result.output;\n    }\n  }\n  return issues ? getIssues(issues) : getOutput(output);\n}\n\n// src/utils/getDefaultArgs/getDefaultArgs.ts\nfunction getDefaultArgs(arg1, arg2) {\n  return Array.isArray(arg1) ? [void 0, arg1] : [arg1, arg2];\n}\n\n// src/utils/getErrorMessage/getErrorMessage.ts\nfunction getErrorMessage(error) {\n  return typeof error === \"function\" ? error() : error;\n}\n\n// src/utils/getPipeIssues/getPipeIssues.ts\nfunction getPipeIssues(validation, error, input) {\n  return getIssues([\n    {\n      validation,\n      message: getErrorMessage(error),\n      input\n    }\n  ]);\n}\n\n// src/utils/getRestAndDefaultArgs/getRestAndDefaultArgs.ts\nfunction getRestAndDefaultArgs(arg1, arg2, arg3) {\n  if (!arg1 || typeof arg1 === \"object\" && !Array.isArray(arg1)) {\n    const [error2, pipe2] = getDefaultArgs(arg2, arg3);\n    return [arg1, error2, pipe2];\n  }\n  const [error, pipe] = getDefaultArgs(\n    arg1,\n    arg2\n  );\n  return [void 0, error, pipe];\n}\n\n// src/utils/getSchemaIssues/getSchemaIssues.ts\nfunction getSchemaIssues(info, reason, validation, error, input, issues) {\n  return {\n    issues: [\n      {\n        reason,\n        validation,\n        origin: info?.origin || \"value\",\n        message: getErrorMessage(error),\n        input,\n        issues,\n        abortEarly: info?.abortEarly,\n        abortPipeEarly: info?.abortPipeEarly,\n        skipPipe: info?.skipPipe\n      }\n    ]\n  };\n}\n\n// src/utils/isLuhnAlgo/isLuhnAlgo.ts\nvar NON_DIGIT_REGEX = /\\D/gu;\nfunction isLuhnAlgo(input) {\n  const number2 = input.replaceAll(NON_DIGIT_REGEX, \"\");\n  let length2 = number2.length;\n  let bit = 1;\n  let sum = 0;\n  while (length2) {\n    const value2 = +number2[--length2];\n    bit ^= 1;\n    sum += bit ? [0, 2, 4, 6, 8, 1, 3, 5, 7, 9][value2] : value2;\n  }\n  return sum % 10 === 0;\n}\n\n// src/methods/fallback/fallback.ts\nfunction fallback(schema, fallback2) {\n  return {\n    ...schema,\n    /**\n     * Returns the fallback value.\n     */\n    getFallback(info) {\n      return typeof fallback2 === \"function\" ? fallback2(info) : fallback2;\n    },\n    /**\n     * Parses unknown input based on its schema.\n     *\n     * @param input The input to be parsed.\n     * @param info The parse info.\n     *\n     * @returns The parsed output.\n     */\n    _parse(input, info) {\n      const result = schema._parse(input, info);\n      return getOutput(\n        result.issues ? this.getFallback({ input, issues: result.issues }) : result.output\n      );\n    }\n  };\n}\n\n// src/methods/fallback/fallbackAsync.ts\nfunction fallbackAsync(schema, fallback2) {\n  return {\n    ...schema,\n    /**\n     * Returns the default value.\n     */\n    async getFallback(info) {\n      return typeof fallback2 === \"function\" ? await fallback2(info) : fallback2;\n    },\n    /**\n     * Parses unknown input based on its schema.\n     *\n     * @param input The input to be parsed.\n     * @param info The parse info.\n     *\n     * @returns The parsed output.\n     */\n    async _parse(input, info) {\n      const result = await schema._parse(input, info);\n      return getOutput(\n        result.issues ? await this.getFallback({ input, issues: result.issues }) : result.output\n      );\n    }\n  };\n}\n\n// src/methods/getDefault/getDefault.ts\nfunction getDefault(schema) {\n  return schema.getDefault?.();\n}\n\n// src/methods/getDefault/getDefaultAsync.ts\nasync function getDefaultAsync(schema) {\n  return schema.getDefault?.();\n}\n\n// src/methods/getDefaults/getDefaults.ts\nfunction getDefaults(schema) {\n  let defaults;\n  if (schema.getDefault) {\n    defaults = schema.getDefault();\n  } else if (\"type\" in schema) {\n    if (schema.type === \"object\") {\n      defaults = {};\n      for (const key in schema.entries) {\n        defaults[key] = getDefaults(schema.entries[key]);\n      }\n    } else if (schema.type === \"tuple\") {\n      defaults = [];\n      for (let key = 0; key < schema.items.length; key++) {\n        defaults.push(getDefaults(schema.items[key]));\n      }\n    }\n  }\n  return defaults;\n}\n\n// src/methods/getDefaults/getDefaultsAsync.ts\nasync function getDefaultsAsync(schema) {\n  let defaults;\n  if (schema.getDefault) {\n    defaults = await schema.getDefault();\n  } else if (\"type\" in schema) {\n    if (schema.type === \"object\") {\n      defaults = {};\n      for (const key in schema.entries) {\n        defaults[key] = await getDefaultsAsync(schema.entries[key]);\n      }\n    } else if (schema.type === \"tuple\") {\n      defaults = [];\n      for (let key = 0; key < schema.items.length; key++) {\n        defaults.push(await getDefaultsAsync(schema.items[key]));\n      }\n    }\n  }\n  return defaults;\n}\n\n// src/methods/getFallback/getFallback.ts\nfunction getFallback(schema, info) {\n  return schema.getFallback?.(info);\n}\n\n// src/methods/getFallback/getFallbackAsync.ts\nasync function getFallbackAsync(schema, info) {\n  return schema.getFallback?.(info);\n}\n\n// src/methods/getFallbacks/getFallbacks.ts\nfunction getFallbacks(schema) {\n  let fallbacks;\n  if (schema.getFallback) {\n    fallbacks = schema.getFallback();\n  } else if (\"type\" in schema) {\n    if (schema.type === \"object\") {\n      fallbacks = {};\n      for (const key in schema.entries) {\n        fallbacks[key] = getFallbacks(schema.entries[key]);\n      }\n    } else if (schema.type === \"tuple\") {\n      fallbacks = [];\n      for (let key = 0; key < schema.items.length; key++) {\n        fallbacks.push(getFallbacks(schema.items[key]));\n      }\n    }\n  }\n  return fallbacks;\n}\n\n// src/methods/getFallbacks/getFallbacksAsync.ts\nasync function getFallbacksAsync(schema) {\n  let fallbacks;\n  if (schema.getFallback) {\n    fallbacks = await schema.getFallback();\n  } else if (\"type\" in schema) {\n    if (schema.type === \"object\") {\n      fallbacks = {};\n      await Promise.all(\n        Object.entries(schema.entries).map(async ([key, schema2]) => {\n          fallbacks[key] = await getFallbacksAsync(schema2);\n        })\n      );\n    } else if (schema.type === \"tuple\") {\n      fallbacks = await Promise.all(\n        schema.items.map((schema2) => getFallbacksAsync(schema2))\n      );\n    }\n  }\n  return fallbacks;\n}\n\n// src/methods/is/is.ts\nfunction is(schema, input) {\n  return !schema._parse(input, { abortEarly: true }).issues;\n}\n\n// src/schemas/any/any.ts\nfunction any(pipe = []) {\n  return {\n    /**\n     * The schema type.\n     */\n    type: \"any\",\n    /**\n     * Whether it's async.\n     */\n    async: false,\n    /**\n     * Parses unknown input based on its schema.\n     *\n     * @param input The input to be parsed.\n     * @param info The parse info.\n     *\n     * @returns The parsed output.\n     */\n    _parse(input, info) {\n      return executePipe(input, pipe, info, \"any\");\n    }\n  };\n}\n\n// src/schemas/any/anyAsync.ts\nfunction anyAsync(pipe = []) {\n  return {\n    /**\n     * The schema type.\n     */\n    type: \"any\",\n    /**\n     * Whether it's async.\n     */\n    async: true,\n    /**\n     * Parses unknown input based on its schema.\n     *\n     * @param input The input to be parsed.\n     * @param info The parse info.\n     *\n     * @returns The parsed output.\n     */\n    async _parse(input, info) {\n      return executePipeAsync(input, pipe, info, \"any\");\n    }\n  };\n}\n\n// src/schemas/array/array.ts\nfunction array(item, arg2, arg3) {\n  const [error, pipe] = getDefaultArgs(arg2, arg3);\n  return {\n    /**\n     * The schema type.\n     */\n    type: \"array\",\n    /**\n     * The item schema.\n     */\n    item,\n    /**\n     * Whether it's async.\n     */\n    async: false,\n    /**\n     * Parses unknown input based on its schema.\n     *\n     * @param input The input to be parsed.\n     * @param info The parse info.\n     *\n     * @returns The parsed output.\n     */\n    _parse(input, info) {\n      if (!Array.isArray(input)) {\n        return getSchemaIssues(\n          info,\n          \"type\",\n          \"array\",\n          error || \"Invalid type\",\n          input\n        );\n      }\n      let issues;\n      const output = [];\n      for (let key = 0; key < input.length; key++) {\n        const value2 = input[key];\n        const result = item._parse(value2, info);\n        if (result.issues) {\n          const pathItem = {\n            type: \"array\",\n            input,\n            key,\n            value: value2\n          };\n          for (const issue of result.issues) {\n            if (issue.path) {\n              issue.path.unshift(pathItem);\n            } else {\n              issue.path = [pathItem];\n            }\n            issues?.push(issue);\n          }\n          if (!issues) {\n            issues = result.issues;\n          }\n          if (info?.abortEarly) {\n            break;\n          }\n        } else {\n          output.push(result.output);\n        }\n      }\n      return issues ? getIssues(issues) : executePipe(output, pipe, info, \"array\");\n    }\n  };\n}\n\n// src/schemas/array/arrayAsync.ts\nfunction arrayAsync(item, arg2, arg3) {\n  const [error, pipe] = getDefaultArgs(arg2, arg3);\n  return {\n    /**\n     * The schema type.\n     */\n    type: \"array\",\n    /**\n     * The item schema.\n     */\n    item,\n    /**\n     * Whether it's async.\n     */\n    async: true,\n    /**\n     * Parses unknown input based on its schema.\n     *\n     * @param input The input to be parsed.\n     * @param info The parse info.\n     *\n     * @returns The parsed output.\n     */\n    async _parse(input, info) {\n      if (!Array.isArray(input)) {\n        return getSchemaIssues(\n          info,\n          \"type\",\n          \"array\",\n          error || \"Invalid type\",\n          input\n        );\n      }\n      let issues;\n      const output = [];\n      await Promise.all(\n        input.map(async (value2, key) => {\n          if (!(info?.abortEarly && issues)) {\n            const result = await item._parse(value2, info);\n            if (!(info?.abortEarly && issues)) {\n              if (result.issues) {\n                const pathItem = {\n                  type: \"array\",\n                  input,\n                  key,\n                  value: value2\n                };\n                for (const issue of result.issues) {\n                  if (issue.path) {\n                    issue.path.unshift(pathItem);\n                  } else {\n                    issue.path = [pathItem];\n                  }\n                  issues?.push(issue);\n                }\n                if (!issues) {\n                  issues = result.issues;\n                }\n                if (info?.abortEarly) {\n                  throw null;\n                }\n              } else {\n                output[key] = result.output;\n              }\n            }\n          }\n        })\n      ).catch(() => null);\n      return issues ? getIssues(issues) : executePipeAsync(output, pipe, info, \"array\");\n    }\n  };\n}\n\n// src/schemas/bigint/bigint.ts\nfunction bigint(arg1, arg2) {\n  const [error, pipe] = getDefaultArgs(arg1, arg2);\n  return {\n    /**\n     * The schema type.\n     */\n    type: \"bigint\",\n    /**\n     * Whether it's async.\n     */\n    async: false,\n    /**\n     * Parses unknown input based on its schema.\n     *\n     * @param input The input to be parsed.\n     * @param info The parse info.\n     *\n     * @returns The parsed output.\n     */\n    _parse(input, info) {\n      if (typeof input !== \"bigint\") {\n        return getSchemaIssues(\n          info,\n          \"type\",\n          \"bigint\",\n          error || \"Invalid type\",\n          input\n        );\n      }\n      return executePipe(input, pipe, info, \"bigint\");\n    }\n  };\n}\n\n// src/schemas/bigint/bigintAsync.ts\nfunction bigintAsync(arg1, arg2) {\n  const [error, pipe] = getDefaultArgs(arg1, arg2);\n  return {\n    /**\n     * The schema type.\n     */\n    type: \"bigint\",\n    /**\n     * Whether it's async.\n     */\n    async: true,\n    /**\n     * Parses unknown input based on its schema.\n     *\n     * @param input The input to be parsed.\n     * @param info The parse info.\n     *\n     * @returns The parsed output.\n     */\n    async _parse(input, info) {\n      if (typeof input !== \"bigint\") {\n        return getSchemaIssues(\n          info,\n          \"type\",\n          \"bigint\",\n          error || \"Invalid type\",\n          input\n        );\n      }\n      return executePipeAsync(input, pipe, info, \"bigint\");\n    }\n  };\n}\n\n// src/schemas/blob/blob.ts\nfunction blob(arg1, arg2) {\n  const [error, pipe] = getDefaultArgs(arg1, arg2);\n  return {\n    /**\n     * The schema type.\n     */\n    type: \"blob\",\n    /**\n     * Whether it's async.\n     */\n    async: false,\n    /**\n     * Parses unknown input based on its schema.\n     *\n     * @param input The input to be parsed.\n     * @param info The parse info.\n     *\n     * @returns The parsed output.\n     */\n    _parse(input, info) {\n      if (!(input instanceof Blob)) {\n        return getSchemaIssues(\n          info,\n          \"type\",\n          \"blob\",\n          error || \"Invalid type\",\n          input\n        );\n      }\n      return executePipe(input, pipe, info, \"blob\");\n    }\n  };\n}\n\n// src/schemas/blob/blobAsync.ts\nfunction blobAsync(arg1, arg2) {\n  const [error, pipe] = getDefaultArgs(arg1, arg2);\n  return {\n    /**\n     * The schema type.\n     */\n    type: \"blob\",\n    /**\n     * Whether it's async.\n     */\n    async: true,\n    /**\n     * Parses unknown input based on its schema.\n     *\n     * @param input The input to be parsed.\n     * @param info The parse info.\n     *\n     * @returns The parsed output.\n     */\n    async _parse(input, info) {\n      if (!(input instanceof Blob)) {\n        return getSchemaIssues(\n          info,\n          \"type\",\n          \"blob\",\n          error || \"Invalid type\",\n          input\n        );\n      }\n      return executePipeAsync(input, pipe, info, \"blob\");\n    }\n  };\n}\n\n// src/schemas/boolean/boolean.ts\nfunction boolean(arg1, arg2) {\n  const [error, pipe] = getDefaultArgs(arg1, arg2);\n  return {\n    /**\n     * The schema type.\n     */\n    type: \"boolean\",\n    /**\n     * Whether it's async.\n     */\n    async: false,\n    /**\n     * Parses unknown input based on its schema.\n     *\n     * @param input The input to be parsed.\n     * @param info The parse info.\n     *\n     * @returns The parsed output.\n     */\n    _parse(input, info) {\n      if (typeof input !== \"boolean\") {\n        return getSchemaIssues(\n          info,\n          \"type\",\n          \"boolean\",\n          error || \"Invalid type\",\n          input\n        );\n      }\n      return executePipe(input, pipe, info, \"boolean\");\n    }\n  };\n}\n\n// src/schemas/boolean/booleanAsync.ts\nfunction booleanAsync(arg1, arg2) {\n  const [error, pipe] = getDefaultArgs(arg1, arg2);\n  return {\n    /**\n     * The schema type.\n     */\n    type: \"boolean\",\n    /**\n     * Whether it's async.\n     */\n    async: true,\n    /**\n     * Parses unknown input based on its schema.\n     *\n     * @param input The input to be parsed.\n     * @param info The parse info.\n     *\n     * @returns The parsed output.\n     */\n    async _parse(input, info) {\n      if (typeof input !== \"boolean\") {\n        return getSchemaIssues(\n          info,\n          \"type\",\n          \"boolean\",\n          error || \"Invalid type\",\n          input\n        );\n      }\n      return executePipeAsync(input, pipe, info, \"boolean\");\n    }\n  };\n}\n\n// src/schemas/date/date.ts\nfunction date(arg1, arg2) {\n  const [error, pipe] = getDefaultArgs(arg1, arg2);\n  return {\n    /**\n     * The schema type.\n     */\n    type: \"date\",\n    /**\n     * Whether it's async.\n     */\n    async: false,\n    /**\n     * Parses unknown input based on its schema.\n     *\n     * @param input The input to be parsed.\n     * @param info The parse info.\n     *\n     * @returns The parsed output.\n     */\n    _parse(input, info) {\n      if (!(input instanceof Date) || isNaN(input.getTime())) {\n        return getSchemaIssues(\n          info,\n          \"type\",\n          \"date\",\n          error || \"Invalid type\",\n          input\n        );\n      }\n      return executePipe(input, pipe, info, \"date\");\n    }\n  };\n}\n\n// src/schemas/date/dateAsync.ts\nfunction dateAsync(arg1, arg2) {\n  const [error, pipe] = getDefaultArgs(arg1, arg2);\n  return {\n    /**\n     * The schema type.\n     */\n    type: \"date\",\n    /**\n     * Whether it's async.\n     */\n    async: true,\n    /**\n     * Parses unknown input based on its schema.\n     *\n     * @param input The input to be parsed.\n     * @param info The parse info.\n     *\n     * @returns The parsed output.\n     */\n    async _parse(input, info) {\n      if (!(input instanceof Date) || isNaN(input.getTime())) {\n        return getSchemaIssues(\n          info,\n          \"type\",\n          \"date\",\n          error || \"Invalid type\",\n          input\n        );\n      }\n      return executePipeAsync(input, pipe, info, \"date\");\n    }\n  };\n}\n\n// src/schemas/enum/enum.ts\nfunction enum_(enum_2, error) {\n  return {\n    /**\n     * The schema type.\n     */\n    type: \"enum\",\n    /**\n     * The enum value.\n     */\n    enum: enum_2,\n    /**\n     * Whether it's async.\n     */\n    async: false,\n    /**\n     * Parses unknown input based on its schema.\n     *\n     * @param input The input to be parsed.\n     * @param info The parse info.\n     *\n     * @returns The parsed output.\n     */\n    _parse(input, info) {\n      if (!Object.values(enum_2).includes(input)) {\n        return getSchemaIssues(\n          info,\n          \"type\",\n          \"enum\",\n          error || \"Invalid type\",\n          input\n        );\n      }\n      return getOutput(input);\n    }\n  };\n}\nvar nativeEnum = enum_;\n\n// src/schemas/enum/enumAsync.ts\nfunction enumAsync(enum_2, error) {\n  return {\n    /**\n     * The schema type.\n     */\n    type: \"enum\",\n    /**\n     * The enum value.\n     */\n    enum: enum_2,\n    /**\n     * Whether it's async.\n     */\n    async: true,\n    /**\n     * Parses unknown input based on its schema.\n     *\n     * @param input The input to be parsed.\n     * @param info The parse info.\n     *\n     * @returns The parsed output.\n     */\n    async _parse(input, info) {\n      if (!Object.values(enum_2).includes(input)) {\n        return getSchemaIssues(\n          info,\n          \"type\",\n          \"enum\",\n          error || \"Invalid type\",\n          input\n        );\n      }\n      return getOutput(input);\n    }\n  };\n}\nvar nativeEnumAsync = enumAsync;\n\n// src/schemas/instance/instance.ts\nfunction instance(of, arg2, arg3) {\n  const [error, pipe] = getDefaultArgs(arg2, arg3);\n  return {\n    /**\n     * The schema type.\n     */\n    type: \"instance\",\n    /**\n     * The class of the instance.\n     */\n    class: of,\n    /**\n     * Whether it's async.\n     */\n    async: false,\n    /**\n     * Parses unknown input based on its schema.\n     *\n     * @param input The input to be parsed.\n     * @param info The parse info.\n     *\n     * @returns The parsed output.\n     */\n    _parse(input, info) {\n      if (!(input instanceof of)) {\n        return getSchemaIssues(\n          info,\n          \"type\",\n          \"instance\",\n          error || \"Invalid type\",\n          input\n        );\n      }\n      return executePipe(input, pipe, info, \"instance\");\n    }\n  };\n}\n\n// src/schemas/instance/instanceAsync.ts\nfunction instanceAsync(of, arg2, arg3) {\n  const [error, pipe] = getDefaultArgs(arg2, arg3);\n  return {\n    /**\n     * The schema type.\n     */\n    type: \"instance\",\n    /**\n     * The class of the instance.\n     */\n    class: of,\n    /**\n     * Whether it's async.\n     */\n    async: true,\n    /**\n     * Parses unknown input based on its schema.\n     *\n     * @param input The input to be parsed.\n     * @param info The parse info.\n     *\n     * @returns The parsed output.\n     */\n    async _parse(input, info) {\n      if (!(input instanceof of)) {\n        return getSchemaIssues(\n          info,\n          \"type\",\n          \"instance\",\n          error || \"Invalid type\",\n          input\n        );\n      }\n      return executePipeAsync(input, pipe, info, \"instance\");\n    }\n  };\n}\n\n// src/schemas/intersect/utils/mergeOutputs/mergeOutputs.ts\nfunction mergeOutputs(output1, output2) {\n  if (typeof output1 === typeof output2) {\n    if (output1 === output2 || output1 instanceof Date && output2 instanceof Date && +output1 === +output2) {\n      return getOutput(output1);\n    }\n    if (Array.isArray(output1) && Array.isArray(output2)) {\n      if (output1.length === output2.length) {\n        const array2 = [];\n        for (let index = 0; index < output1.length; index++) {\n          const result = mergeOutputs(output1[index], output2[index]);\n          if (result.invalid) {\n            return result;\n          }\n          array2.push(result.output);\n        }\n        return getOutput(array2);\n      }\n      return { invalid: true };\n    }\n    if (output1 && output2 && output1.constructor === Object && output2.constructor === Object) {\n      const object2 = { ...output1, ...output2 };\n      for (const key in output1) {\n        if (key in output2) {\n          const result = mergeOutputs(output1[key], output2[key]);\n          if (result.invalid) {\n            return result;\n          }\n          object2[key] = result.output;\n        }\n      }\n      return getOutput(object2);\n    }\n  }\n  return { invalid: true };\n}\n\n// src/schemas/intersect/intersect.ts\nfunction intersect(options, error) {\n  return {\n    /**\n     * The schema type.\n     */\n    type: \"intersect\",\n    /**\n     * The intersect options.\n     */\n    options,\n    /**\n     * Whether it's async.\n     */\n    async: false,\n    /**\n     * Parses unknown input based on its schema.\n     *\n     * @param input The input to be parsed.\n     * @param info The parse info.\n     *\n     * @returns The parsed output.\n     */\n    _parse(input, info) {\n      let issues;\n      let outputs;\n      for (const schema of options) {\n        const result = schema._parse(input, info);\n        if (result.issues) {\n          if (issues) {\n            for (const issue of result.issues) {\n              issues.push(issue);\n            }\n          } else {\n            issues = result.issues;\n          }\n          if (info?.abortEarly) {\n            break;\n          }\n        } else {\n          if (outputs) {\n            outputs.push(result.output);\n          } else {\n            outputs = [result.output];\n          }\n        }\n      }\n      if (issues) {\n        return getIssues(issues);\n      }\n      let output = outputs[0];\n      for (let index = 1; index < outputs.length; index++) {\n        const result = mergeOutputs(output, outputs[index]);\n        if (result.invalid) {\n          return getSchemaIssues(\n            info,\n            \"type\",\n            \"intersect\",\n            error || \"Invalid type\",\n            input\n          );\n        }\n        output = result.output;\n      }\n      return getOutput(output);\n    }\n  };\n}\nvar intersection = intersect;\n\n// src/schemas/literal/literal.ts\nfunction literal(literal2, error) {\n  return {\n    /**\n     * The schema type.\n     */\n    type: \"literal\",\n    /**\n     * The literal value.\n     */\n    literal: literal2,\n    /**\n     * Whether it's async.\n     */\n    async: false,\n    /**\n     * Parses unknown input based on its schema.\n     *\n     * @param input The input to be parsed.\n     * @param info The parse info.\n     *\n     * @returns The parsed output.\n     */\n    _parse(input, info) {\n      if (input !== literal2) {\n        return getSchemaIssues(\n          info,\n          \"type\",\n          \"literal\",\n          error || \"Invalid type\",\n          input\n        );\n      }\n      return getOutput(input);\n    }\n  };\n}\n\n// src/schemas/literal/literalAsync.ts\nfunction literalAsync(literal2, error) {\n  return {\n    /**\n     * The schema type.\n     */\n    type: \"literal\",\n    /**\n     * The literal value.\n     */\n    literal: literal2,\n    /**\n     * Whether it's async.\n     */\n    async: true,\n    /**\n     * Parses unknown input based on its schema.\n     *\n     * @param input The input to be parsed.\n     * @param info The parse info.\n     *\n     * @returns The parsed output.\n     */\n    async _parse(input, info) {\n      if (input !== literal2) {\n        return getSchemaIssues(\n          info,\n          \"type\",\n          \"literal\",\n          error || \"Invalid type\",\n          input\n        );\n      }\n      return getOutput(input);\n    }\n  };\n}\n\n// src/schemas/map/map.ts\nfunction map(key, value2, arg3, arg4) {\n  const [error, pipe] = getDefaultArgs(arg3, arg4);\n  return {\n    /**\n     * The schema type.\n     */\n    type: \"map\",\n    /**\n     * The key schema.\n     */\n    key,\n    /**\n     * The value schema.\n     */\n    value: value2,\n    /**\n     * Whether it's async.\n     */\n    async: false,\n    /**\n     * Parses unknown input based on its schema.\n     *\n     * @param input The input to be parsed.\n     * @param info The parse info.\n     *\n     * @returns The parsed output.\n     */\n    _parse(input, info) {\n      if (!(input instanceof Map)) {\n        return getSchemaIssues(\n          info,\n          \"type\",\n          \"map\",\n          error || \"Invalid type\",\n          input\n        );\n      }\n      let issues;\n      const output = /* @__PURE__ */ new Map();\n      for (const [inputKey, inputValue] of input.entries()) {\n        let pathItem;\n        const keyResult = key._parse(inputKey, {\n          origin: \"key\",\n          abortEarly: info?.abortEarly,\n          abortPipeEarly: info?.abortPipeEarly,\n          skipPipe: info?.skipPipe\n        });\n        if (keyResult.issues) {\n          pathItem = {\n            type: \"map\",\n            input,\n            key: inputKey,\n            value: inputValue\n          };\n          for (const issue of keyResult.issues) {\n            if (issue.path) {\n              issue.path.unshift(pathItem);\n            } else {\n              issue.path = [pathItem];\n            }\n            issues?.push(issue);\n          }\n          if (!issues) {\n            issues = keyResult.issues;\n          }\n          if (info?.abortEarly) {\n            break;\n          }\n        }\n        const valueResult = value2._parse(inputValue, info);\n        if (valueResult.issues) {\n          pathItem = pathItem || {\n            type: \"map\",\n            input,\n            key: inputKey,\n            value: inputValue\n          };\n          for (const issue of valueResult.issues) {\n            if (issue.path) {\n              issue.path.unshift(pathItem);\n            } else {\n              issue.path = [pathItem];\n            }\n            issues?.push(issue);\n          }\n          if (!issues) {\n            issues = valueResult.issues;\n          }\n          if (info?.abortEarly) {\n            break;\n          }\n        }\n        if (!keyResult.issues && !valueResult.issues) {\n          output.set(keyResult.output, valueResult.output);\n        }\n      }\n      return issues ? getIssues(issues) : executePipe(output, pipe, info, \"map\");\n    }\n  };\n}\n\n// src/schemas/map/mapAsync.ts\nfunction mapAsync(key, value2, arg3, arg4) {\n  const [error, pipe] = getDefaultArgs(arg3, arg4);\n  return {\n    /**\n     * The schema type.\n     */\n    type: \"map\",\n    /**\n     * The key schema.\n     */\n    key,\n    /**\n     * The  value schema.\n     */\n    value: value2,\n    /**\n     * Whether it's async.\n     */\n    async: true,\n    /**\n     * Parses unknown input based on its schema.\n     *\n     * @param input The input to be parsed.\n     * @param info The parse info.\n     *\n     * @returns The parsed output.\n     */\n    async _parse(input, info) {\n      if (!(input instanceof Map)) {\n        return getSchemaIssues(\n          info,\n          \"type\",\n          \"map\",\n          error || \"Invalid type\",\n          input\n        );\n      }\n      const output = /* @__PURE__ */ new Map();\n      let issues;\n      await Promise.all(\n        Array.from(input.entries()).map(async ([inputKey, inputValue]) => {\n          let pathItem;\n          const [keyResult, valueResult] = await Promise.all(\n            [\n              { schema: key, value: inputKey, origin: \"key\" },\n              { schema: value2, value: inputValue, origin: \"value\" }\n            ].map(async ({ schema, value: value3, origin }) => {\n              if (!(info?.abortEarly && issues)) {\n                const result = await schema._parse(value3, {\n                  origin,\n                  abortEarly: info?.abortEarly,\n                  abortPipeEarly: info?.abortPipeEarly,\n                  skipPipe: info?.skipPipe\n                });\n                if (!(info?.abortEarly && issues)) {\n                  if (result.issues) {\n                    pathItem = pathItem || {\n                      type: \"map\",\n                      input,\n                      key: inputKey,\n                      value: inputValue\n                    };\n                    for (const issue of result.issues) {\n                      if (issue.path) {\n                        issue.path.unshift(pathItem);\n                      } else {\n                        issue.path = [pathItem];\n                      }\n                      issues?.push(issue);\n                    }\n                    if (!issues) {\n                      issues = result.issues;\n                    }\n                    if (info?.abortEarly) {\n                      throw null;\n                    }\n                  } else {\n                    return result;\n                  }\n                }\n              }\n            })\n          ).catch(() => []);\n          if (keyResult && valueResult) {\n            output.set(keyResult.output, valueResult.output);\n          }\n        })\n      );\n      return issues ? getIssues(issues) : executePipeAsync(input, pipe, info, \"map\");\n    }\n  };\n}\n\n// src/schemas/nan/nan.ts\nfunction nan(error) {\n  return {\n    /**\n     * The schema type.\n     */\n    type: \"nan\",\n    /**\n     * Whether it's async.\n     */\n    async: false,\n    /**\n     * Parses unknown input based on its schema.\n     *\n     * @param input The input to be parsed.\n     * @param info The parse info.\n     *\n     * @returns The parsed output.\n     */\n    _parse(input, info) {\n      if (!Number.isNaN(input)) {\n        return getSchemaIssues(\n          info,\n          \"type\",\n          \"nan\",\n          error || \"Invalid type\",\n          input\n        );\n      }\n      return getOutput(input);\n    }\n  };\n}\n\n// src/schemas/nan/nanAsync.ts\nfunction nanAsync(error) {\n  return {\n    /**\n     * The schema type.\n     */\n    type: \"nan\",\n    /**\n     * Whether it's async.\n     */\n    async: true,\n    /**\n     * Parses unknown input based on its schema.\n     *\n     * @param input The input to be parsed.\n     * @param info The parse info.\n     *\n     * @returns The parsed output.\n     */\n    async _parse(input, info) {\n      if (!Number.isNaN(input)) {\n        return getSchemaIssues(\n          info,\n          \"type\",\n          \"nan\",\n          error || \"Invalid type\",\n          input\n        );\n      }\n      return getOutput(input);\n    }\n  };\n}\n\n// src/schemas/never/never.ts\nfunction never(error) {\n  return {\n    /**\n     * The schema type.\n     */\n    type: \"never\",\n    /**\n     * Whether it's async.\n     */\n    async: false,\n    /**\n     * Parses unknown input based on its schema.\n     *\n     * @param input The input to be parsed.\n     * @param info The parse info.\n     *\n     * @returns The parsed output.\n     */\n    _parse(input, info) {\n      return getSchemaIssues(\n        info,\n        \"type\",\n        \"never\",\n        error || \"Invalid type\",\n        input\n      );\n    }\n  };\n}\n\n// src/schemas/never/neverAsync.ts\nfunction neverAsync(error) {\n  return {\n    /**\n     * The schema type.\n     */\n    type: \"never\",\n    /**\n     * Whether it's async.\n     */\n    async: true,\n    /**\n     * Parses unknown input based on its schema.\n     *\n     * @param input The input to be parsed.\n     * @param info The parse info.\n     *\n     * @returns The parsed output.\n     */\n    async _parse(input, info) {\n      return getSchemaIssues(\n        info,\n        \"type\",\n        \"never\",\n        error || \"Invalid type\",\n        input\n      );\n    }\n  };\n}\n\n// src/schemas/nonNullable/nonNullable.ts\nfunction nonNullable(wrapped, error) {\n  return {\n    /**\n     * The schema type.\n     */\n    type: \"non_nullable\",\n    /**\n     * The wrapped schema.\n     */\n    wrapped,\n    /**\n     * Whether it's async.\n     */\n    async: false,\n    /**\n     * Parses unknown input based on its schema.\n     *\n     * @param input The input to be parsed.\n     * @param info The parse info.\n     *\n     * @returns The parsed output.\n     */\n    _parse(input, info) {\n      if (input === null) {\n        return getSchemaIssues(\n          info,\n          \"type\",\n          \"non_nullable\",\n          error || \"Invalid type\",\n          input\n        );\n      }\n      return wrapped._parse(input, info);\n    }\n  };\n}\n\n// src/schemas/nonNullable/nonNullableAsync.ts\nfunction nonNullableAsync(wrapped, error) {\n  return {\n    /**\n     * The schema type.\n     */\n    type: \"non_nullable\",\n    /**\n     * The wrapped schema.\n     */\n    wrapped,\n    /**\n     * Whether it's async.\n     */\n    async: true,\n    /**\n     * Parses unknown input based on its schema.\n     *\n     * @param input The input to be parsed.\n     * @param info The parse info.\n     *\n     * @returns The parsed output.\n     */\n    async _parse(input, info) {\n      if (input === null) {\n        return getSchemaIssues(\n          info,\n          \"type\",\n          \"non_nullable\",\n          error || \"Invalid type\",\n          input\n        );\n      }\n      return wrapped._parse(input, info);\n    }\n  };\n}\n\n// src/schemas/nonNullish/nonNullish.ts\nfunction nonNullish(wrapped, error) {\n  return {\n    /**\n     * The schema type.\n     */\n    type: \"non_nullish\",\n    /**\n     * The wrapped schema.\n     */\n    wrapped,\n    /**\n     * Whether it's async.\n     */\n    async: false,\n    /**\n     * Parses unknown input based on its schema.\n     *\n     * @param input The input to be parsed.\n     * @param info The parse info.\n     *\n     * @returns The parsed output.\n     */\n    _parse(input, info) {\n      if (input === null || input === void 0) {\n        return getSchemaIssues(\n          info,\n          \"type\",\n          \"non_nullish\",\n          error || \"Invalid type\",\n          input\n        );\n      }\n      return wrapped._parse(input, info);\n    }\n  };\n}\n\n// src/schemas/nonNullish/nonNullishAsync.ts\nfunction nonNullishAsync(wrapped, error) {\n  return {\n    /**\n     * The schema type.\n     */\n    type: \"non_nullish\",\n    /**\n     * The wrapped schema.\n     */\n    wrapped,\n    /**\n     * Whether it's async.\n     */\n    async: true,\n    /**\n     * Parses unknown input based on its schema.\n     *\n     * @param input The input to be parsed.\n     * @param info The parse info.\n     *\n     * @returns The parsed output.\n     */\n    async _parse(input, info) {\n      if (input === null || input === void 0) {\n        return getSchemaIssues(\n          info,\n          \"type\",\n          \"non_nullish\",\n          error || \"Invalid type\",\n          input\n        );\n      }\n      return wrapped._parse(input, info);\n    }\n  };\n}\n\n// src/schemas/nonOptional/nonOptional.ts\nfunction nonOptional(wrapped, error) {\n  return {\n    /**\n     * The schema type.\n     */\n    type: \"non_optional\",\n    /**\n     * The wrapped schema.\n     */\n    wrapped,\n    /**\n     * Whether it's async.\n     */\n    async: false,\n    /**\n     * Parses unknown input based on its schema.\n     *\n     * @param input The input to be parsed.\n     * @param info The parse info.\n     *\n     * @returns The parsed output.\n     */\n    _parse(input, info) {\n      if (input === void 0) {\n        return getSchemaIssues(\n          info,\n          \"type\",\n          \"non_optional\",\n          error || \"Invalid type\",\n          input\n        );\n      }\n      return wrapped._parse(input, info);\n    }\n  };\n}\n\n// src/schemas/nonOptional/nonOptionalAsync.ts\nfunction nonOptionalAsync(wrapped, error) {\n  return {\n    /**\n     * The schema type.\n     */\n    type: \"non_optional\",\n    /**\n     * The wrapped schema.\n     */\n    wrapped,\n    /**\n     * Whether it's async.\n     */\n    async: true,\n    /**\n     * Parses unknown input based on its schema.\n     *\n     * @param input The input to be parsed.\n     * @param info The parse info.\n     *\n     * @returns The parsed output.\n     */\n    async _parse(input, info) {\n      if (input === void 0) {\n        return getSchemaIssues(\n          info,\n          \"type\",\n          \"non_optional\",\n          error || \"Invalid type\",\n          input\n        );\n      }\n      return wrapped._parse(input, info);\n    }\n  };\n}\n\n// src/schemas/nullable/nullable.ts\nfunction nullable(wrapped, default_) {\n  return {\n    /**\n     * The schema type.\n     */\n    type: \"nullable\",\n    /**\n     * The wrapped schema.\n     */\n    wrapped,\n    /**\n     * Returns the default value.\n     */\n    getDefault() {\n      return typeof default_ === \"function\" ? default_() : default_;\n    },\n    /**\n     * Whether it's async.\n     */\n    async: false,\n    /**\n     * Parses unknown input based on its schema.\n     *\n     * @param input The input to be parsed.\n     * @param info The parse info.\n     *\n     * @returns The parsed output.\n     */\n    _parse(input, info) {\n      if (input === null) {\n        const override = this.getDefault();\n        if (override === void 0) {\n          return getOutput(input);\n        }\n        input = override;\n      }\n      return wrapped._parse(input, info);\n    }\n  };\n}\n\n// src/schemas/nullable/nullableAsync.ts\nfunction nullableAsync(wrapped, default_) {\n  return {\n    /**\n     * The schema type.\n     */\n    type: \"nullable\",\n    /**\n     * The wrapped schema.\n     */\n    wrapped,\n    /**\n     * Returns the default value.\n     */\n    async getDefault() {\n      return typeof default_ === \"function\" ? default_() : default_;\n    },\n    /**\n     * Whether it's async.\n     */\n    async: true,\n    /**\n     * Parses unknown input based on its schema.\n     *\n     * @param input The input to be parsed.\n     * @param info The parse info.\n     *\n     * @returns The parsed output.\n     */\n    async _parse(input, info) {\n      if (input === null) {\n        const override = await this.getDefault();\n        if (override === void 0) {\n          return getOutput(input);\n        }\n        input = override;\n      }\n      return wrapped._parse(input, info);\n    }\n  };\n}\n\n// src/schemas/nullish/nullish.ts\nfunction nullish(wrapped, default_) {\n  return {\n    /**\n     * The schema type.\n     */\n    type: \"nullish\",\n    /**\n     * The wrapped schema.\n     */\n    wrapped,\n    /**\n     * Returns the default value.\n     */\n    getDefault() {\n      return typeof default_ === \"function\" ? default_() : default_;\n    },\n    /**\n     * Whether it's async.\n     */\n    async: false,\n    /**\n     * Parses unknown input based on its schema.\n     *\n     * @param input The input to be parsed.\n     * @param info The parse info.\n     *\n     * @returns The parsed output.\n     */\n    _parse(input, info) {\n      if (input === null || input === void 0) {\n        const override = this.getDefault();\n        if (override === void 0) {\n          return getOutput(input);\n        }\n        input = override;\n      }\n      return wrapped._parse(input, info);\n    }\n  };\n}\n\n// src/schemas/nullish/nullishAsync.ts\nfunction nullishAsync(wrapped, default_) {\n  return {\n    /**\n     * The schema type.\n     */\n    type: \"nullish\",\n    /**\n     * The wrapped schema.\n     */\n    wrapped,\n    /**\n     * Retutns the default value.\n     */\n    async getDefault() {\n      return typeof default_ === \"function\" ? default_() : default_;\n    },\n    /**\n     * Whether it's async.\n     */\n    async: true,\n    /**\n     * Parses unknown input based on its schema.\n     *\n     * @param input The input to be parsed.\n     * @param info The parse info.\n     *\n     * @returns The parsed output.\n     */\n    async _parse(input, info) {\n      if (input === null || input === void 0) {\n        const override = await this.getDefault();\n        if (override === void 0) {\n          return getOutput(input);\n        }\n        input = override;\n      }\n      return wrapped._parse(input, info);\n    }\n  };\n}\n\n// src/schemas/null/null.ts\nfunction null_(error) {\n  return {\n    /**\n     * The schema type.\n     */\n    type: \"null\",\n    /**\n     * Whether it's async.\n     */\n    async: false,\n    /**\n     * Parses unknown input based on its schema.\n     *\n     * @param input The input to be parsed.\n     * @param info The parse info.\n     *\n     * @returns The parsed output.\n     */\n    _parse(input, info) {\n      if (input !== null) {\n        return getSchemaIssues(\n          info,\n          \"type\",\n          \"null\",\n          error || \"Invalid type\",\n          input\n        );\n      }\n      return getOutput(input);\n    }\n  };\n}\nvar nullType = null_;\n\n// src/schemas/null/nullAsync.ts\nfunction nullAsync(error) {\n  return {\n    /**\n     * The schema type.\n     */\n    type: \"null\",\n    /**\n     * Whether it's async.\n     */\n    async: true,\n    /**\n     * Parses unknown input based on its schema.\n     *\n     * @param input The input to be parsed.\n     * @param info The parse info.\n     *\n     * @returns The parsed output.\n     */\n    async _parse(input, info) {\n      if (input !== null) {\n        return getSchemaIssues(\n          info,\n          \"type\",\n          \"null\",\n          error || \"Invalid type\",\n          input\n        );\n      }\n      return getOutput(input);\n    }\n  };\n}\nvar nullTypeAsync = nullAsync;\n\n// src/schemas/number/number.ts\nfunction number(arg1, arg2) {\n  const [error, pipe] = getDefaultArgs(arg1, arg2);\n  return {\n    /**\n     * The schema type.\n     */\n    type: \"number\",\n    /**\n     * Whether it's async.\n     */\n    async: false,\n    /**\n     * Parses unknown input based on its schema.\n     *\n     * @param input The input to be parsed.\n     * @param info The parse info.\n     *\n     * @returns The parsed output.\n     */\n    _parse(input, info) {\n      if (typeof input !== \"number\" || isNaN(input)) {\n        return getSchemaIssues(\n          info,\n          \"type\",\n          \"number\",\n          error || \"Invalid type\",\n          input\n        );\n      }\n      return executePipe(input, pipe, info, \"number\");\n    }\n  };\n}\n\n// src/schemas/number/numberAsync.ts\nfunction numberAsync(arg1, arg2) {\n  const [error, pipe] = getDefaultArgs(arg1, arg2);\n  return {\n    /**\n     * The schema type.\n     */\n    type: \"number\",\n    /**\n     * Whether it's async.\n     */\n    async: true,\n    /**\n     * Parses unknown input based on its schema.\n     *\n     * @param input The input to be parsed.\n     * @param info The parse info.\n     *\n     * @returns The parsed output.\n     */\n    async _parse(input, info) {\n      if (typeof input !== \"number\" || isNaN(input)) {\n        return getSchemaIssues(\n          info,\n          \"type\",\n          \"number\",\n          error || \"Invalid type\",\n          input\n        );\n      }\n      return executePipeAsync(input, pipe, info, \"number\");\n    }\n  };\n}\n\n// src/schemas/object/object.ts\nfunction object(entries, arg2, arg3, arg4) {\n  const [rest, error, pipe] = getRestAndDefaultArgs(arg2, arg3, arg4);\n  let cachedEntries;\n  return {\n    /**\n     * The schema type.\n     */\n    type: \"object\",\n    /**\n     * The entries schema.\n     */\n    entries,\n    /**\n     * The rest schema.\n     */\n    rest,\n    /**\n     * Whether it's async.\n     */\n    async: false,\n    /**\n     * Parses unknown input based on its schema.\n     *\n     * @param input The input to be parsed.\n     * @param info The parse info.\n     *\n     * @returns The parsed output.\n     */\n    _parse(input, info) {\n      if (!input || typeof input !== \"object\") {\n        return getSchemaIssues(\n          info,\n          \"type\",\n          \"object\",\n          error || \"Invalid type\",\n          input\n        );\n      }\n      cachedEntries = cachedEntries || Object.entries(entries);\n      let issues;\n      const output = {};\n      for (const [key, schema] of cachedEntries) {\n        const value2 = input[key];\n        const result = schema._parse(value2, info);\n        if (result.issues) {\n          const pathItem = {\n            type: \"object\",\n            input,\n            key,\n            value: value2\n          };\n          for (const issue of result.issues) {\n            if (issue.path) {\n              issue.path.unshift(pathItem);\n            } else {\n              issue.path = [pathItem];\n            }\n            issues?.push(issue);\n          }\n          if (!issues) {\n            issues = result.issues;\n          }\n          if (info?.abortEarly) {\n            break;\n          }\n        } else if (result.output !== void 0 || key in input) {\n          output[key] = result.output;\n        }\n      }\n      if (rest && !(info?.abortEarly && issues)) {\n        for (const key in input) {\n          if (!(key in entries)) {\n            const value2 = input[key];\n            const result = rest._parse(value2, info);\n            if (result.issues) {\n              const pathItem = {\n                type: \"object\",\n                input,\n                key,\n                value: value2\n              };\n              for (const issue of result.issues) {\n                if (issue.path) {\n                  issue.path.unshift(pathItem);\n                } else {\n                  issue.path = [pathItem];\n                }\n                issues?.push(issue);\n              }\n              if (!issues) {\n                issues = result.issues;\n              }\n              if (info?.abortEarly) {\n                break;\n              }\n            } else {\n              output[key] = result.output;\n            }\n          }\n        }\n      }\n      return issues ? getIssues(issues) : executePipe(\n        output,\n        pipe,\n        info,\n        \"object\"\n      );\n    }\n  };\n}\n\n// src/schemas/object/objectAsync.ts\nfunction objectAsync(entries, arg2, arg3, arg4) {\n  const [rest, error, pipe] = getRestAndDefaultArgs(arg2, arg3, arg4);\n  let cachedEntries;\n  return {\n    /**\n     * The schema type.\n     */\n    type: \"object\",\n    /**\n     * The entries schema.\n     */\n    entries,\n    /**\n     * The rest schema.\n     */\n    rest,\n    /**\n     * Whether it's async.\n     */\n    async: true,\n    /**\n     * Parses unknown input based on its schema.\n     *\n     * @param input The input to be parsed.\n     * @param info The parse info.\n     *\n     * @returns The parsed output.\n     */\n    async _parse(input, info) {\n      if (!input || typeof input !== \"object\") {\n        return getSchemaIssues(\n          info,\n          \"type\",\n          \"object\",\n          error || \"Invalid type\",\n          input\n        );\n      }\n      cachedEntries = cachedEntries || Object.entries(entries);\n      let issues;\n      const output = {};\n      await Promise.all([\n        Promise.all(\n          cachedEntries.map(async ([key, schema]) => {\n            if (!(info?.abortEarly && issues)) {\n              const value2 = input[key];\n              const result = await schema._parse(value2, info);\n              if (!(info?.abortEarly && issues)) {\n                if (result.issues) {\n                  const pathItem = {\n                    type: \"object\",\n                    input,\n                    key,\n                    value: value2\n                  };\n                  for (const issue of result.issues) {\n                    if (issue.path) {\n                      issue.path.unshift(pathItem);\n                    } else {\n                      issue.path = [pathItem];\n                    }\n                    issues?.push(issue);\n                  }\n                  if (!issues) {\n                    issues = result.issues;\n                  }\n                  if (info?.abortEarly) {\n                    throw null;\n                  }\n                } else if (result.output !== void 0 || key in input) {\n                  output[key] = result.output;\n                }\n              }\n            }\n          })\n        ),\n        rest && Promise.all(\n          Object.entries(input).map(async ([key, value2]) => {\n            if (!(info?.abortEarly && issues)) {\n              if (!(key in entries)) {\n                const result = await rest._parse(value2, info);\n                if (!(info?.abortEarly && issues)) {\n                  if (result.issues) {\n                    const pathItem = {\n                      type: \"object\",\n                      input,\n                      key,\n                      value: value2\n                    };\n                    for (const issue of result.issues) {\n                      if (issue.path) {\n                        issue.path.unshift(pathItem);\n                      } else {\n                        issue.path = [pathItem];\n                      }\n                      issues?.push(issue);\n                    }\n                    if (!issues) {\n                      issues = result.issues;\n                    }\n                    if (info?.abortEarly) {\n                      throw null;\n                    }\n                  } else {\n                    output[key] = result.output;\n                  }\n                }\n              }\n            }\n          })\n        )\n      ]).catch(() => null);\n      return issues ? getIssues(issues) : executePipeAsync(\n        output,\n        pipe,\n        info,\n        \"object\"\n      );\n    }\n  };\n}\n\n// src/schemas/optional/optional.ts\nfunction optional(wrapped, default_) {\n  return {\n    /**\n     * The schema type.\n     */\n    type: \"optional\",\n    /**\n     * The wrapped schema.\n     */\n    wrapped,\n    /**\n     * Returns the default value.\n     */\n    getDefault() {\n      return typeof default_ === \"function\" ? default_() : default_;\n    },\n    /**\n     * Whether it's async.\n     */\n    async: false,\n    /**\n     * Parses unknown input based on its schema.\n     *\n     * @param input The input to be parsed.\n     * @param info The parse info.\n     *\n     * @returns The parsed output.\n     */\n    _parse(input, info) {\n      if (input === void 0) {\n        const override = this.getDefault();\n        if (override === void 0) {\n          return getOutput(input);\n        }\n        input = override;\n      }\n      return wrapped._parse(input, info);\n    }\n  };\n}\n\n// src/schemas/optional/optionalAsync.ts\nfunction optionalAsync(wrapped, default_) {\n  return {\n    /**\n     * The schema type.\n     */\n    type: \"optional\",\n    /**\n     * The wrapped schema.\n     */\n    wrapped,\n    /**\n     * Returns the default value.\n     */\n    async getDefault() {\n      return typeof default_ === \"function\" ? default_() : default_;\n    },\n    /**\n     * Whether it's async.\n     */\n    async: true,\n    /**\n     * Parses unknown input based on its schema.\n     *\n     * @param input The input to be parsed.\n     * @param info The parse info.\n     *\n     * @returns The parsed output.\n     */\n    async _parse(input, info) {\n      if (input === void 0) {\n        const override = await this.getDefault();\n        if (override === void 0) {\n          return getOutput(input);\n        }\n        input = override;\n      }\n      return wrapped._parse(input, info);\n    }\n  };\n}\n\n// src/schemas/picklist/picklist.ts\nfunction picklist(options, error) {\n  return {\n    /**\n     * The schema type.\n     */\n    type: \"picklist\",\n    /**\n     * The picklist options.\n     */\n    options,\n    /**\n     * Whether it's async.\n     */\n    async: false,\n    /**\n     * Parses unknown input based on its schema.\n     *\n     * @param input The input to be parsed.\n     * @param info The parse info.\n     *\n     * @returns The parsed output.\n     */\n    _parse(input, info) {\n      if (!options.includes(input)) {\n        return getSchemaIssues(\n          info,\n          \"type\",\n          \"picklist\",\n          error || \"Invalid type\",\n          input\n        );\n      }\n      return getOutput(input);\n    }\n  };\n}\nvar enumType = picklist;\n\n// src/schemas/picklist/picklistAsync.ts\nfunction picklistAsync(options, error) {\n  return {\n    /**\n     * The schema type.\n     */\n    type: \"picklist\",\n    /**\n     * The picklist value.\n     */\n    options,\n    /**\n     * Whether it's async.\n     */\n    async: true,\n    /**\n     * Parses unknown input based on its schema.\n     *\n     * @param input The input to be parsed.\n     * @param info The parse info.\n     *\n     * @returns The parsed output.\n     */\n    async _parse(input, info) {\n      if (!options.includes(input)) {\n        return getSchemaIssues(\n          info,\n          \"type\",\n          \"picklist\",\n          error || \"Invalid type\",\n          input\n        );\n      }\n      return getOutput(input);\n    }\n  };\n}\nvar enumTypeAsync = picklistAsync;\n\n// src/schemas/string/string.ts\nfunction string(arg1, arg2) {\n  const [error, pipe] = getDefaultArgs(arg1, arg2);\n  return {\n    /**\n     * The schema type.\n     */\n    type: \"string\",\n    /**\n     * Whether it's async.\n     */\n    async: false,\n    /**\n     * Parses unknown input based on its schema.\n     *\n     * @param input The input to be parsed.\n     * @param info The parse info.\n     *\n     * @returns The parsed output.\n     */\n    _parse(input, info) {\n      if (typeof input !== \"string\") {\n        return getSchemaIssues(\n          info,\n          \"type\",\n          \"string\",\n          error || \"Invalid type\",\n          input\n        );\n      }\n      return executePipe(input, pipe, info, \"string\");\n    }\n  };\n}\n\n// src/schemas/string/stringAsync.ts\nfunction stringAsync(arg1, arg2) {\n  const [error, pipe] = getDefaultArgs(arg1, arg2);\n  return {\n    /**\n     * The schema type.\n     */\n    type: \"string\",\n    /**\n     * Whether it's async.\n     */\n    async: true,\n    /**\n     * Parses unknown input based on its schema.\n     *\n     * @param input The input to be parsed.\n     * @param info The parse info.\n     *\n     * @returns The parsed output.\n     */\n    async _parse(input, info) {\n      if (typeof input !== \"string\") {\n        return getSchemaIssues(\n          info,\n          \"type\",\n          \"string\",\n          error || \"Invalid type\",\n          input\n        );\n      }\n      return executePipeAsync(input, pipe, info, \"string\");\n    }\n  };\n}\n\n// src/schemas/record/utils/getRecordArgs/getRecordArgs.ts\nfunction getRecordArgs(arg1, arg2, arg3, arg4) {\n  if (typeof arg2 === \"object\" && !Array.isArray(arg2)) {\n    const [error2, pipe2] = getDefaultArgs(arg3, arg4);\n    return [arg1, arg2, error2, pipe2];\n  }\n  const [error, pipe] = getDefaultArgs(\n    arg2,\n    arg3\n  );\n  return [string(), arg1, error, pipe];\n}\n\n// src/schemas/record/values.ts\nvar BLOCKED_KEYS = [\"__proto__\", \"prototype\", \"constructor\"];\n\n// src/schemas/record/record.ts\nfunction record(arg1, arg2, arg3, arg4) {\n  const [key, value2, error, pipe] = getRecordArgs(arg1, arg2, arg3, arg4);\n  return {\n    /**\n     * The schema type.\n     */\n    type: \"record\",\n    /**\n     * The key schema.\n     */\n    key,\n    /**\n     * The value schema.\n     */\n    value: value2,\n    /**\n     * Whether it's async.\n     */\n    async: false,\n    /**\n     * Parses unknown input based on its schema.\n     *\n     * @param input The input to be parsed.\n     * @param info The parse info.\n     *\n     * @returns The parsed output.\n     */\n    _parse(input, info) {\n      if (!input || typeof input !== \"object\") {\n        return getSchemaIssues(\n          info,\n          \"type\",\n          \"record\",\n          error || \"Invalid type\",\n          input\n        );\n      }\n      let issues;\n      const output = {};\n      for (const [inputKey, inputValue] of Object.entries(input)) {\n        if (!BLOCKED_KEYS.includes(inputKey)) {\n          let pathItem;\n          const keyResult = key._parse(inputKey, {\n            origin: \"key\",\n            abortEarly: info?.abortEarly,\n            abortPipeEarly: info?.abortPipeEarly,\n            skipPipe: info?.skipPipe\n          });\n          if (keyResult.issues) {\n            pathItem = {\n              type: \"record\",\n              input,\n              key: inputKey,\n              value: inputValue\n            };\n            for (const issue of keyResult.issues) {\n              issue.path = [pathItem];\n              issues?.push(issue);\n            }\n            if (!issues) {\n              issues = keyResult.issues;\n            }\n            if (info?.abortEarly) {\n              break;\n            }\n          }\n          const valueResult = value2._parse(inputValue, info);\n          if (valueResult.issues) {\n            pathItem = pathItem || {\n              type: \"record\",\n              input,\n              key: inputKey,\n              value: inputValue\n            };\n            for (const issue of valueResult.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              issues?.push(issue);\n            }\n            if (!issues) {\n              issues = valueResult.issues;\n            }\n            if (info?.abortEarly) {\n              break;\n            }\n          }\n          if (!keyResult.issues && !valueResult.issues) {\n            output[keyResult.output] = valueResult.output;\n          }\n        }\n      }\n      return issues ? getIssues(issues) : executePipe(\n        output,\n        pipe,\n        info,\n        \"record\"\n      );\n    }\n  };\n}\n\n// src/schemas/record/recordAsync.ts\nfunction recordAsync(arg1, arg2, arg3, arg4) {\n  const [key, value2, error, pipe] = getRecordArgs(arg1, arg2, arg3, arg4);\n  return {\n    /**\n     * The schema type.\n     */\n    type: \"record\",\n    /**\n     * The key schema.\n     */\n    key,\n    /**\n     * The value schema.\n     */\n    value: value2,\n    /**\n     * Whether it's async.\n     */\n    async: true,\n    /**\n     * Parses unknown input based on its schema.\n     *\n     * @param input The input to be parsed.\n     * @param info The parse info.\n     *\n     * @returns The parsed output.\n     */\n    async _parse(input, info) {\n      if (!input || typeof input !== \"object\") {\n        return getSchemaIssues(\n          info,\n          \"type\",\n          \"record\",\n          error || \"Invalid type\",\n          input\n        );\n      }\n      let issues;\n      const output = {};\n      await Promise.all(\n        // Note: `Object.entries(...)` converts each key to a string\n        Object.entries(input).map(async ([inputKey, inputValue]) => {\n          if (!BLOCKED_KEYS.includes(inputKey)) {\n            let pathItem;\n            const [keyResult, valueResult] = await Promise.all(\n              [\n                { schema: key, value: inputKey, origin: \"key\" },\n                { schema: value2, value: inputValue, origin: \"value\" }\n              ].map(async ({ schema, value: value3, origin }) => {\n                if (!(info?.abortEarly && issues)) {\n                  const result = await schema._parse(value3, {\n                    origin,\n                    abortEarly: info?.abortEarly,\n                    abortPipeEarly: info?.abortPipeEarly,\n                    skipPipe: info?.skipPipe\n                  });\n                  if (!(info?.abortEarly && issues)) {\n                    if (result.issues) {\n                      pathItem = pathItem || {\n                        type: \"record\",\n                        input,\n                        key: inputKey,\n                        value: inputValue\n                      };\n                      for (const issue of result.issues) {\n                        if (issue.path) {\n                          issue.path.unshift(pathItem);\n                        } else {\n                          issue.path = [pathItem];\n                        }\n                        issues?.push(issue);\n                      }\n                      if (!issues) {\n                        issues = result.issues;\n                      }\n                      if (info?.abortEarly) {\n                        throw null;\n                      }\n                    } else {\n                      return result;\n                    }\n                  }\n                }\n              })\n            ).catch(() => []);\n            if (keyResult && valueResult) {\n              output[keyResult.output] = valueResult.output;\n            }\n          }\n        })\n      );\n      return issues ? getIssues(issues) : executePipeAsync(\n        output,\n        pipe,\n        info,\n        \"record\"\n      );\n    }\n  };\n}\n\n// src/schemas/recursive/recursive.ts\nfunction recursive(getter) {\n  return {\n    /**\n     * The schema type.\n     */\n    type: \"recursive\",\n    /**\n     * The schema getter.\n     */\n    getter,\n    /**\n     * Whether it's async.\n     */\n    async: false,\n    /**\n     * Parses unknown input based on its schema.\n     *\n     * @param input The input to be parsed.\n     * @param info The parse info.\n     *\n     * @returns The parsed output.\n     */\n    _parse(input, info) {\n      return getter()._parse(input, info);\n    }\n  };\n}\n\n// src/schemas/recursive/recursiveAsync.ts\nfunction recursiveAsync(getter) {\n  return {\n    /**\n     * The schema type.\n     */\n    type: \"recursive\",\n    /**\n     * The schema getter.\n     */\n    getter,\n    /**\n     * Whether it's async.\n     */\n    async: true,\n    /**\n     * Parses unknown input based on its schema.\n     *\n     * @param input The input to be parsed.\n     * @param info The parse info.\n     *\n     * @returns The parsed output.\n     */\n    async _parse(input, info) {\n      return getter()._parse(input, info);\n    }\n  };\n}\n\n// src/schemas/set/set.ts\nfunction set(value2, arg2, arg3) {\n  const [error, pipe] = getDefaultArgs(arg2, arg3);\n  return {\n    /**\n     * The schema type.\n     */\n    type: \"set\",\n    /**\n     * The value schema.\n     */\n    value: value2,\n    /**\n     * Whether it's async.\n     */\n    async: false,\n    /**\n     * Parses unknown input based on its schema.\n     *\n     * @param input The input to be parsed.\n     * @param info The parse info.\n     *\n     * @returns The parsed output.\n     */\n    _parse(input, info) {\n      if (!(input instanceof Set)) {\n        return getSchemaIssues(\n          info,\n          \"type\",\n          \"set\",\n          error || \"Invalid type\",\n          input\n        );\n      }\n      let key = 0;\n      let issues;\n      const output = /* @__PURE__ */ new Set();\n      for (const inputValue of input) {\n        const result = value2._parse(inputValue, info);\n        if (result.issues) {\n          const pathItem = {\n            type: \"set\",\n            input,\n            key,\n            value: inputValue\n          };\n          for (const issue of result.issues) {\n            if (issue.path) {\n              issue.path.unshift(pathItem);\n            } else {\n              issue.path = [pathItem];\n            }\n            issues?.push(issue);\n          }\n          if (!issues) {\n            issues = result.issues;\n          }\n          if (info?.abortEarly) {\n            break;\n          }\n        } else {\n          output.add(result.output);\n        }\n        key++;\n      }\n      return issues ? getIssues(issues) : executePipe(output, pipe, info, \"set\");\n    }\n  };\n}\n\n// src/schemas/set/setAsync.ts\nfunction setAsync(value2, arg2, arg3) {\n  const [error, pipe] = getDefaultArgs(arg2, arg3);\n  return {\n    /**\n     * The schema type.\n     */\n    type: \"set\",\n    /**\n     * The value schema.\n     */\n    value: value2,\n    /**\n     * Whether it's async.\n     */\n    async: true,\n    /**\n     * Parses unknown input based on its schema.\n     *\n     * @param input The input to be parsed.\n     * @param info The parse info.\n     *\n     * @returns The parsed output.\n     */\n    async _parse(input, info) {\n      if (!(input instanceof Set)) {\n        return getSchemaIssues(\n          info,\n          \"type\",\n          \"set\",\n          error || \"Invalid type\",\n          input\n        );\n      }\n      let issues;\n      const output = /* @__PURE__ */ new Set();\n      await Promise.all(\n        Array.from(input.values()).map(async (inputValue, key) => {\n          if (!(info?.abortEarly && issues)) {\n            const result = await value2._parse(inputValue, info);\n            if (!(info?.abortEarly && issues)) {\n              if (result.issues) {\n                const pathItem = {\n                  type: \"set\",\n                  input,\n                  key,\n                  value: inputValue\n                };\n                for (const issue of result.issues) {\n                  if (issue.path) {\n                    issue.path.unshift(pathItem);\n                  } else {\n                    issue.path = [pathItem];\n                  }\n                  issues?.push(issue);\n                }\n                if (!issues) {\n                  issues = result.issues;\n                }\n                if (info?.abortEarly) {\n                  throw null;\n                }\n              } else {\n                output.add(result.output);\n              }\n            }\n          }\n        })\n      ).catch(() => null);\n      return issues ? getIssues(issues) : executePipeAsync(input, pipe, info, \"set\");\n    }\n  };\n}\n\n// src/schemas/special/special.ts\nfunction special(check, arg2, arg3) {\n  const [error, pipe] = getDefaultArgs(arg2, arg3);\n  return {\n    /**\n     * The schema type.\n     */\n    type: \"special\",\n    /**\n     * Whether it's async.\n     */\n    async: false,\n    /**\n     * Parses unknown input based on its schema.\n     *\n     * @param input The input to be parsed.\n     * @param info The parse info.\n     *\n     * @returns The parsed output.\n     */\n    _parse(input, info) {\n      if (!check(input)) {\n        return getSchemaIssues(\n          info,\n          \"type\",\n          \"special\",\n          error || \"Invalid type\",\n          input\n        );\n      }\n      return executePipe(input, pipe, info, \"special\");\n    }\n  };\n}\n\n// src/schemas/special/specialAsync.ts\nfunction specialAsync(check, arg2, arg3) {\n  const [error, pipe] = getDefaultArgs(arg2, arg3);\n  return {\n    /**\n     * The schema type.\n     */\n    type: \"special\",\n    /**\n     * Whether it's async.\n     */\n    async: true,\n    /**\n     * Parses unknown input based on its schema.\n     *\n     * @param input The input to be parsed.\n     * @param info The parse info.\n     *\n     * @returns The parsed output.\n     */\n    async _parse(input, info) {\n      if (!await check(input)) {\n        return getSchemaIssues(\n          info,\n          \"type\",\n          \"special\",\n          error || \"Invalid type\",\n          input\n        );\n      }\n      return executePipeAsync(input, pipe, info, \"special\");\n    }\n  };\n}\n\n// src/schemas/symbol/symbol.ts\nfunction symbol(error) {\n  return {\n    /**\n     * The schema type.\n     */\n    type: \"symbol\",\n    /**\n     * Whether it's async.\n     */\n    async: false,\n    /**\n     * Parses unknown input based on its schema.\n     *\n     * @param input The input to be parsed.\n     * @param info The parse info.\n     *\n     * @returns The parsed output.\n     */\n    _parse(input, info) {\n      if (typeof input !== \"symbol\") {\n        return getSchemaIssues(\n          info,\n          \"type\",\n          \"symbol\",\n          error || \"Invalid type\",\n          input\n        );\n      }\n      return getOutput(input);\n    }\n  };\n}\n\n// src/schemas/symbol/symbolAsync.ts\nfunction symbolAsync(error) {\n  return {\n    /**\n     * The schema type.\n     */\n    type: \"symbol\",\n    /**\n     * Whether it's async.\n     */\n    async: true,\n    /**\n     * Parses unknown input based on its schema.\n     *\n     * @param input The input to be parsed.\n     * @param info The parse info.\n     *\n     * @returns The parsed output.\n     */\n    async _parse(input, info) {\n      if (typeof input !== \"symbol\") {\n        return getSchemaIssues(\n          info,\n          \"type\",\n          \"symbol\",\n          error || \"Invalid type\",\n          input\n        );\n      }\n      return getOutput(input);\n    }\n  };\n}\n\n// src/schemas/tuple/tuple.ts\nfunction tuple(items, arg2, arg3, arg4) {\n  const [rest, error, pipe] = getRestAndDefaultArgs(arg2, arg3, arg4);\n  return {\n    /**\n     * The schema type.\n     */\n    type: \"tuple\",\n    /**\n     * The items schema.\n     */\n    items,\n    /**\n     * The rest schema.\n     */\n    rest,\n    /**\n     * Whether it's async.\n     */\n    async: false,\n    /**\n     * Parses unknown input based on its schema.\n     *\n     * @param input The input to be parsed.\n     * @param info The parse info.\n     *\n     * @returns The parsed output.\n     */\n    _parse(input, info) {\n      if (!Array.isArray(input) || items.length > input.length) {\n        return getSchemaIssues(\n          info,\n          \"type\",\n          \"tuple\",\n          error || \"Invalid type\",\n          input\n        );\n      }\n      let issues;\n      const output = [];\n      for (let key = 0; key < items.length; key++) {\n        const value2 = input[key];\n        const result = items[key]._parse(value2, info);\n        if (result.issues) {\n          const pathItem = {\n            type: \"tuple\",\n            input,\n            key,\n            value: value2\n          };\n          for (const issue of result.issues) {\n            if (issue.path) {\n              issue.path.unshift(pathItem);\n            } else {\n              issue.path = [pathItem];\n            }\n            issues?.push(issue);\n          }\n          if (!issues) {\n            issues = result.issues;\n          }\n          if (info?.abortEarly) {\n            break;\n          }\n        } else {\n          output[key] = result.output;\n        }\n      }\n      if (rest && !(info?.abortEarly && issues)) {\n        for (let key = items.length; key < input.length; key++) {\n          const value2 = input[key];\n          const result = rest._parse(value2, info);\n          if (result.issues) {\n            const pathItem = {\n              type: \"tuple\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of result.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              issues?.push(issue);\n            }\n            if (!issues) {\n              issues = result.issues;\n            }\n            if (info?.abortEarly) {\n              break;\n            }\n          } else {\n            output[key] = result.output;\n          }\n        }\n      }\n      return issues ? getIssues(issues) : executePipe(\n        output,\n        pipe,\n        info,\n        \"tuple\"\n      );\n    }\n  };\n}\n\n// src/schemas/tuple/tupleAsync.ts\nfunction tupleAsync(items, arg2, arg3, arg4) {\n  const [rest, error, pipe] = getRestAndDefaultArgs(arg2, arg3, arg4);\n  return {\n    /**\n     * The schema type.\n     */\n    type: \"tuple\",\n    /**\n     * The items schema.\n     */\n    items,\n    /**\n     * The rest schema.\n     */\n    rest,\n    /**\n     * Whether it's async.\n     */\n    async: true,\n    /**\n     * Parses unknown input based on its schema.\n     *\n     * @param input The input to be parsed.\n     * @param info The parse info.\n     *\n     * @returns The parsed output.\n     */\n    async _parse(input, info) {\n      if (!Array.isArray(input) || items.length > input.length) {\n        return getSchemaIssues(\n          info,\n          \"type\",\n          \"tuple\",\n          error || \"Invalid type\",\n          input\n        );\n      }\n      let issues;\n      const output = [];\n      await Promise.all([\n        // Parse schema of each tuple item\n        Promise.all(\n          items.map(async (schema, key) => {\n            if (!(info?.abortEarly && issues)) {\n              const value2 = input[key];\n              const result = await schema._parse(value2, info);\n              if (!(info?.abortEarly && issues)) {\n                if (result.issues) {\n                  const pathItem = {\n                    type: \"tuple\",\n                    input,\n                    key,\n                    value: value2\n                  };\n                  for (const issue of result.issues) {\n                    if (issue.path) {\n                      issue.path.unshift(pathItem);\n                    } else {\n                      issue.path = [pathItem];\n                    }\n                    issues?.push(issue);\n                  }\n                  if (!issues) {\n                    issues = result.issues;\n                  }\n                  if (info?.abortEarly) {\n                    throw null;\n                  }\n                } else {\n                  output[key] = result.output;\n                }\n              }\n            }\n          })\n        ),\n        // If necessary parse schema of each rest item\n        rest && Promise.all(\n          input.slice(items.length).map(async (value2, index) => {\n            if (!(info?.abortEarly && issues)) {\n              const key = items.length + index;\n              const result = await rest._parse(value2, info);\n              if (!(info?.abortEarly && issues)) {\n                if (result.issues) {\n                  const pathItem = {\n                    type: \"tuple\",\n                    input,\n                    key,\n                    value: value2\n                  };\n                  for (const issue of result.issues) {\n                    if (issue.path) {\n                      issue.path.unshift(pathItem);\n                    } else {\n                      issue.path = [pathItem];\n                    }\n                    issues?.push(issue);\n                  }\n                  if (!issues) {\n                    issues = result.issues;\n                  }\n                  if (info?.abortEarly) {\n                    throw null;\n                  }\n                } else {\n                  output[key] = result.output;\n                }\n              }\n            }\n          })\n        )\n      ]).catch(() => null);\n      return issues ? getIssues(issues) : executePipeAsync(\n        output,\n        pipe,\n        info,\n        \"tuple\"\n      );\n    }\n  };\n}\n\n// src/schemas/undefined/undefined.ts\nfunction undefined_(error) {\n  return {\n    /**\n     * The schema type.\n     */\n    type: \"undefined\",\n    /**\n     * Whether it's async.\n     */\n    async: false,\n    /**\n     * Parses unknown input based on its schema.\n     *\n     * @param input The input to be parsed.\n     * @param info The parse info.\n     *\n     * @returns The parsed output.\n     */\n    _parse(input, info) {\n      if (typeof input !== \"undefined\") {\n        return getSchemaIssues(\n          info,\n          \"type\",\n          \"undefined\",\n          error || \"Invalid type\",\n          input\n        );\n      }\n      return getOutput(input);\n    }\n  };\n}\nvar undefinedType = undefined_;\n\n// src/schemas/undefined/undefinedAsync.ts\nfunction undefinedAsync(error) {\n  return {\n    /**\n     * The schema type.\n     */\n    type: \"undefined\",\n    /**\n     * Whether it's async.\n     */\n    async: true,\n    /**\n     * Parses unknown input based on its schema.\n     *\n     * @param input The input to be parsed.\n     * @param info The parse info.\n     *\n     * @returns The parsed output.\n     */\n    async _parse(input, info) {\n      if (typeof input !== \"undefined\") {\n        return getSchemaIssues(\n          info,\n          \"type\",\n          \"undefined\",\n          error || \"Invalid type\",\n          input\n        );\n      }\n      return getOutput(input);\n    }\n  };\n}\nvar undefinedTypeAsync = undefinedAsync;\n\n// src/schemas/union/union.ts\nfunction union(options, error) {\n  return {\n    /**\n     * The schema type.\n     */\n    type: \"union\",\n    /**\n     * The union options.\n     */\n    options,\n    /**\n     * Whether it's async.\n     */\n    async: false,\n    /**\n     * Parses unknown input based on its schema.\n     *\n     * @param input The input to be parsed.\n     * @param info The parse info.\n     *\n     * @returns The parsed output.\n     */\n    _parse(input, info) {\n      let issues;\n      let output;\n      for (const schema of options) {\n        const result = schema._parse(input, info);\n        if (result.issues) {\n          if (issues) {\n            for (const issue of result.issues) {\n              issues.push(issue);\n            }\n          } else {\n            issues = result.issues;\n          }\n        } else {\n          output = [result.output];\n          break;\n        }\n      }\n      return output ? getOutput(output[0]) : getSchemaIssues(\n        info,\n        \"type\",\n        \"union\",\n        error || \"Invalid type\",\n        input,\n        issues\n      );\n    }\n  };\n}\n\n// src/schemas/union/unionAsync.ts\nfunction unionAsync(options, error) {\n  return {\n    /**\n     * The schema type.\n     */\n    type: \"union\",\n    /**\n     * The union options.\n     */\n    options,\n    /**\n     * Whether it's async.\n     */\n    async: true,\n    /**\n     * Parses unknown input based on its schema.\n     *\n     * @param input The input to be parsed.\n     * @param info The parse info.\n     *\n     * @returns The parsed output.\n     */\n    async _parse(input, info) {\n      let issues;\n      let output;\n      for (const schema of options) {\n        const result = await schema._parse(input, info);\n        if (result.issues) {\n          if (issues) {\n            for (const issue of result.issues) {\n              issues.push(issue);\n            }\n          } else {\n            issues = result.issues;\n          }\n        } else {\n          output = [result.output];\n          break;\n        }\n      }\n      return output ? getOutput(output[0]) : getSchemaIssues(\n        info,\n        \"type\",\n        \"union\",\n        error || \"Invalid type\",\n        input,\n        issues\n      );\n    }\n  };\n}\n\n// src/schemas/unknown/unknown.ts\nfunction unknown(pipe = []) {\n  return {\n    /**\n     * The schema type.\n     */\n    type: \"unknown\",\n    /**\n     * Whether it's async.\n     */\n    async: false,\n    /**\n     * Parses unknown input based on its schema.\n     *\n     * @param input The input to be parsed.\n     * @param info The parse info.\n     *\n     * @returns The parsed output.\n     */\n    _parse(input, info) {\n      return executePipe(input, pipe, info, \"unknown\");\n    }\n  };\n}\n\n// src/schemas/unknown/unknownAsync.ts\nfunction unknownAsync(pipe = []) {\n  return {\n    /**\n     * The schema type.\n     */\n    type: \"unknown\",\n    /**\n     * Whether it's async.\n     */\n    async: true,\n    /**\n     * Parses unknown input based on its schema.\n     *\n     * @param input The input to be parsed.\n     * @param info The parse info.\n     *\n     * @returns The parsed output.\n     */\n    async _parse(input, info) {\n      return executePipeAsync(input, pipe, info, \"unknown\");\n    }\n  };\n}\n\n// src/schemas/variant/variant.ts\nfunction variant(key, options, error) {\n  return {\n    /**\n     * The schema type.\n     */\n    type: \"variant\",\n    /**\n     * The variant options.\n     */\n    options,\n    /**\n     * Whether it's async.\n     */\n    async: false,\n    /**\n     * Parses unknown input based on its schema.\n     *\n     * @param input The input to be parsed.\n     * @param info The parse info.\n     *\n     * @returns The parsed output.\n     */\n    _parse(input, info) {\n      if (!input || typeof input !== \"object\" || !(key in input)) {\n        return getSchemaIssues(\n          info,\n          \"type\",\n          \"variant\",\n          error || \"Invalid type\",\n          input\n        );\n      }\n      let issues;\n      let output;\n      const parseOptions = (options2) => {\n        for (const schema of options2) {\n          if (schema.type === \"object\") {\n            const result = schema.entries[key]._parse(\n              input[key],\n              info\n            );\n            if (!result.issues) {\n              const result2 = schema._parse(input, info);\n              if (result2.issues) {\n                issues = result2.issues;\n              } else {\n                output = [result2.output];\n              }\n              break;\n            }\n          } else if (schema.type === \"variant\") {\n            parseOptions(schema.options);\n            if (issues || output) {\n              break;\n            }\n          }\n        }\n      };\n      parseOptions(options);\n      return output ? getOutput(output[0]) : issues ? getIssues(issues) : getSchemaIssues(\n        info,\n        \"type\",\n        \"variant\",\n        error || \"Invalid type\",\n        input\n      );\n    }\n  };\n}\nvar discriminatedUnion = variant;\n\n// src/schemas/variant/variantAsync.ts\nfunction variantAsync(key, options, error) {\n  return {\n    /**\n     * The schema type.\n     */\n    type: \"variant\",\n    /**\n     * The variant options.\n     */\n    options,\n    /**\n     * Whether it's async.\n     */\n    async: true,\n    /**\n     * Parses unknown input based on its schema.\n     *\n     * @param input The input to be parsed.\n     * @param info The parse info.\n     *\n     * @returns The parsed output.\n     */\n    async _parse(input, info) {\n      if (!input || typeof input !== \"object\" || !(key in input)) {\n        return getSchemaIssues(\n          info,\n          \"type\",\n          \"variant\",\n          error || \"Invalid type\",\n          input\n        );\n      }\n      let issues;\n      let output;\n      const parseOptions = async (options2) => {\n        for (const schema of options2) {\n          if (schema.type === \"object\") {\n            const result = await schema.entries[key]._parse(\n              input[key],\n              info\n            );\n            if (!result.issues) {\n              const result2 = await schema._parse(input, info);\n              if (result2.issues) {\n                issues = result2.issues;\n              } else {\n                output = [result2.output];\n              }\n              break;\n            }\n          } else if (schema.type === \"variant\") {\n            await parseOptions(schema.options);\n            if (issues || output) {\n              break;\n            }\n          }\n        }\n      };\n      await parseOptions(options);\n      return output ? getOutput(output[0]) : issues ? getIssues(issues) : getSchemaIssues(\n        info,\n        \"type\",\n        \"variant\",\n        error || \"Invalid type\",\n        input\n      );\n    }\n  };\n}\nvar discriminatedUnionAsync = variantAsync;\n\n// src/schemas/void/void.ts\nfunction void_(error) {\n  return {\n    /**\n     * The schema type.\n     */\n    type: \"void\",\n    /**\n     * Whether it's async.\n     */\n    async: false,\n    /**\n     * Parses unknown input based on its schema.\n     *\n     * @param input The input to be parsed.\n     * @param info The parse info.\n     *\n     * @returns The parsed output.\n     */\n    _parse(input, info) {\n      if (typeof input !== \"undefined\") {\n        return getSchemaIssues(\n          info,\n          \"type\",\n          \"void\",\n          error || \"Invalid type\",\n          input\n        );\n      }\n      return getOutput(input);\n    }\n  };\n}\nvar voidType = void_;\n\n// src/schemas/void/voidAsync.ts\nfunction voidAsync(error) {\n  return {\n    /**\n     * The schema type.\n     */\n    type: \"void\",\n    /**\n     * Whether it's async.\n     */\n    async: true,\n    /**\n     * Parses unknown input based on its schema.\n     *\n     * @param input The input to be parsed.\n     * @param info The parse info.\n     *\n     * @returns The parsed output.\n     */\n    async _parse(input, info) {\n      if (typeof input !== \"undefined\") {\n        return getSchemaIssues(\n          info,\n          \"type\",\n          \"void\",\n          error || \"Invalid type\",\n          input\n        );\n      }\n      return getOutput(input);\n    }\n  };\n}\nvar voidTypeAsync = voidAsync;\n\n// src/methods/keyof/keyof.ts\nfunction keyof(schema) {\n  return picklist(\n    Object.keys(schema.entries)\n  );\n}\n\n// src/methods/merge/merge.ts\nfunction merge(schemas, arg2, arg3, arg4) {\n  const [rest, error, pipe] = getRestAndDefaultArgs(arg2, arg3, arg4);\n  return object(\n    schemas.reduce(\n      (entries, schema) => ({ ...entries, ...schema.entries }),\n      {}\n    ),\n    rest,\n    error,\n    pipe\n  );\n}\n\n// src/methods/merge/mergeAsync.ts\nfunction mergeAsync(schemas, arg2, arg3, arg4) {\n  const [rest, error, pipe] = getRestAndDefaultArgs(arg2, arg3, arg4);\n  return objectAsync(\n    schemas.reduce(\n      (entries, schema) => ({ ...entries, ...schema.entries }),\n      {}\n    ),\n    rest,\n    error,\n    pipe\n  );\n}\n\n// src/methods/omit/omit.ts\nfunction omit(schema, keys, arg3, arg4, arg5) {\n  const [rest, error, pipe] = getRestAndDefaultArgs(arg3, arg4, arg5);\n  return object(\n    Object.entries(schema.entries).reduce(\n      (entries, [key, schema2]) => keys.includes(key) ? entries : { ...entries, [key]: schema2 },\n      {}\n    ),\n    rest,\n    error,\n    pipe\n  );\n}\n\n// src/methods/omit/omitAsync.ts\nfunction omitAsync(schema, keys, arg3, arg4, arg5) {\n  const [rest, error, pipe] = getRestAndDefaultArgs(arg3, arg4, arg5);\n  return objectAsync(\n    Object.entries(schema.entries).reduce(\n      (entries, [key, schema2]) => keys.includes(key) ? entries : { ...entries, [key]: schema2 },\n      {}\n    ),\n    rest,\n    error,\n    pipe\n  );\n}\n\n// src/methods/parse/parse.ts\nfunction parse(schema, input, info) {\n  const result = schema._parse(input, info);\n  if (result.issues) {\n    throw new ValiError(result.issues);\n  }\n  return result.output;\n}\n\n// src/methods/parse/parseAsync.ts\nasync function parseAsync(schema, input, info) {\n  const result = await schema._parse(input, info);\n  if (result.issues) {\n    throw new ValiError(result.issues);\n  }\n  return result.output;\n}\n\n// src/methods/partial/partial.ts\nfunction partial(schema, arg2, arg3, arg4) {\n  const [rest, error, pipe] = getRestAndDefaultArgs(arg2, arg3, arg4);\n  return object(\n    Object.entries(schema.entries).reduce(\n      (entries, [key, schema2]) => ({\n        ...entries,\n        [key]: optional(schema2)\n      }),\n      {}\n    ),\n    rest,\n    error,\n    pipe\n  );\n}\n\n// src/methods/partial/partialAsync.ts\nfunction partialAsync(schema, arg2, arg3, arg4) {\n  const [rest, error, pipe] = getRestAndDefaultArgs(arg2, arg3, arg4);\n  return objectAsync(\n    Object.entries(schema.entries).reduce(\n      (entries, [key, schema2]) => ({\n        ...entries,\n        [key]: optionalAsync(schema2)\n      }),\n      {}\n    ),\n    rest,\n    error,\n    pipe\n  );\n}\n\n// src/methods/passthrough/passthrough.ts\nfunction passthrough(schema) {\n  return {\n    ...schema,\n    /**\n     * Parses unknown input based on its schema.\n     *\n     * @param input The input to be parsed.\n     * @param info The parse info.\n     *\n     * @returns The parsed output.\n     */\n    _parse(input, info) {\n      const result = schema._parse(input, info);\n      return !result.issues ? getOutput({ ...input, ...result.output }) : result;\n    }\n  };\n}\n\n// src/methods/passthrough/passthroughAsync.ts\nfunction passthroughAsync(schema) {\n  return {\n    ...schema,\n    /**\n     * Parses unknown input based on its schema.\n     *\n     * @param input The input to be parsed.\n     * @param info The parse info.\n     *\n     * @returns The parsed output.\n     */\n    async _parse(input, info) {\n      const result = await schema._parse(input, info);\n      return !result.issues ? getOutput({ ...input, ...result.output }) : result;\n    }\n  };\n}\n\n// src/methods/pick/pick.ts\nfunction pick(schema, keys, arg3, arg4, arg5) {\n  const [rest, error, pipe] = getRestAndDefaultArgs(arg3, arg4, arg5);\n  return object(\n    Object.entries(schema.entries).reduce(\n      (entries, [key, schema2]) => keys.includes(key) ? { ...entries, [key]: schema2 } : entries,\n      {}\n    ),\n    rest,\n    error,\n    pipe\n  );\n}\n\n// src/methods/pick/pickAsync.ts\nfunction pickAsync(schema, keys, arg3, arg4, arg5) {\n  const [rest, error, pipe] = getRestAndDefaultArgs(arg3, arg4, arg5);\n  return objectAsync(\n    Object.entries(schema.entries).reduce(\n      (entries, [key, schema2]) => keys.includes(key) ? { ...entries, [key]: schema2 } : entries,\n      {}\n    ),\n    rest,\n    error,\n    pipe\n  );\n}\n\n// src/methods/required/required.ts\nfunction required(schema, arg2, arg3, arg4) {\n  const [rest, error, pipe] = getRestAndDefaultArgs(arg2, arg3, arg4);\n  return object(\n    Object.entries(schema.entries).reduce(\n      (entries, [key, schema2]) => ({\n        ...entries,\n        [key]: nonOptional(schema2)\n      }),\n      {}\n    ),\n    rest,\n    error,\n    pipe\n  );\n}\n\n// src/methods/required/requiredAsync.ts\nfunction requiredAsync(schema, arg2, arg3, arg4) {\n  const [rest, error, pipe] = getRestAndDefaultArgs(arg2, arg3, arg4);\n  return objectAsync(\n    Object.entries(schema.entries).reduce(\n      (entries, [key, schema2]) => ({\n        ...entries,\n        [key]: nonOptionalAsync(schema2)\n      }),\n      {}\n    ),\n    rest,\n    error,\n    pipe\n  );\n}\n\n// src/methods/safeParse/safeParse.ts\nfunction safeParse(schema, input, info) {\n  const result = schema._parse(input, info);\n  return result.issues ? {\n    success: false,\n    error: new ValiError(result.issues),\n    issues: result.issues\n  } : {\n    success: true,\n    data: result.output,\n    output: result.output\n  };\n}\n\n// src/methods/safeParse/safeParseAsync.ts\nasync function safeParseAsync(schema, input, info) {\n  const result = await schema._parse(input, info);\n  return result.issues ? {\n    success: false,\n    error: new ValiError(result.issues),\n    issues: result.issues\n  } : {\n    success: true,\n    data: result.output,\n    output: result.output\n  };\n}\n\n// src/methods/strict/strict.ts\nfunction strict(schema, error) {\n  return {\n    ...schema,\n    /**\n     * Parses unknown input based on its schema.\n     *\n     * @param input The input to be parsed.\n     * @param info The parse info.\n     *\n     * @returns The parsed output.\n     */\n    _parse(input, info) {\n      const result = schema._parse(input, info);\n      return !result.issues && Object.keys(input).some((key) => !(key in schema.entries)) ? getSchemaIssues(\n        info,\n        \"object\",\n        \"strict\",\n        error || \"Invalid keys\",\n        input\n      ) : result;\n    }\n  };\n}\n\n// src/methods/strict/strictAsync.ts\nfunction strictAsync(schema, error) {\n  return {\n    ...schema,\n    /**\n     * Parses unknown input based on its schema.\n     *\n     * @param input The input to be parsed.\n     * @param info The parse info.\n     *\n     * @returns The parsed output.\n     */\n    async _parse(input, info) {\n      const result = await schema._parse(input, info);\n      return !result.issues && Object.keys(input).some((key) => !(key in schema.entries)) ? getSchemaIssues(\n        info,\n        \"object\",\n        \"strict\",\n        error || \"Invalid keys\",\n        input\n      ) : result;\n    }\n  };\n}\n\n// src/methods/strip/strip.ts\nfunction strip(schema) {\n  let cachedKeys;\n  return {\n    ...schema,\n    /**\n     * Parses unknown input based on its schema.\n     *\n     * @param input The input to be parsed.\n     * @param info The parse info.\n     *\n     * @returns The parsed output.\n     */\n    _parse(input, info) {\n      const result = schema._parse(input, info);\n      if (result.issues) {\n        return result;\n      }\n      cachedKeys = cachedKeys || Object.keys(schema.entries);\n      const output = {};\n      for (const key of cachedKeys) {\n        output[key] = result.output[key];\n      }\n      return getOutput(output);\n    }\n  };\n}\n\n// src/methods/strip/stripAsync.ts\nfunction stripAsync(schema) {\n  let cachedKeys;\n  return {\n    ...schema,\n    /**\n     * Parses unknown input based on its schema.\n     *\n     * @param input The input to be parsed.\n     * @param info The parse info.\n     *\n     * @returns The parsed output.\n     */\n    async _parse(input, info) {\n      const result = await schema._parse(input, info);\n      if (result.issues) {\n        return result;\n      }\n      cachedKeys = cachedKeys || Object.keys(schema.entries);\n      const output = {};\n      for (const key of cachedKeys) {\n        output[key] = result.output[key];\n      }\n      return getOutput(output);\n    }\n  };\n}\n\n// src/methods/transform/transform.ts\nfunction transform(schema, action, arg1) {\n  return {\n    ...schema,\n    /**\n     * Parses unknown input based on its schema.\n     *\n     * @param input The input to be parsed.\n     * @param info The parse info.\n     *\n     * @returns The parsed output.\n     */\n    _parse(input, info) {\n      const result = schema._parse(input, info);\n      if (result.issues) {\n        return result;\n      }\n      const output = action(result.output);\n      if (arg1 && !Array.isArray(arg1)) {\n        return arg1._parse(output, info);\n      }\n      return executePipe(output, arg1, info, typeof output);\n    }\n  };\n}\n\n// src/methods/transform/transformAsync.ts\nfunction transformAsync(schema, action, arg1) {\n  return {\n    ...schema,\n    /**\n     * Whether it's async.\n     */\n    async: true,\n    /**\n     * Parses unknown input based on its schema.\n     *\n     * @param input The input to be parsed.\n     * @param info The parse info.\n     *\n     * @returns The parsed output.\n     */\n    async _parse(input, info) {\n      const result = await schema._parse(input, info);\n      if (result.issues) {\n        return result;\n      }\n      const output = await action(result.output);\n      if (arg1 && !Array.isArray(arg1)) {\n        return arg1._parse(output, info);\n      }\n      return executePipeAsync(output, arg1, info, typeof output);\n    }\n  };\n}\n\n// src/methods/unwrap/unwrap.ts\nfunction unwrap(schema) {\n  return schema.wrapped;\n}\n\n// src/methods/withDefault/withDefault.ts\nfunction withDefault(schema, value2) {\n  return {\n    ...schema,\n    /**\n     * Parses unknown input based on its schema.\n     *\n     * @param input The input to be parsed.\n     * @param info The parse info.\n     *\n     * @returns The parsed output.\n     */\n    _parse(input, info) {\n      return schema._parse(\n        input === void 0 ? typeof value2 === \"function\" ? value2() : value2 : input,\n        info\n      );\n    }\n  };\n}\nvar useDefault = withDefault;\n\n// src/regex.ts\nvar CUID2_REGEX = /^[a-z][\\da-z]*$/u;\nvar EMAIL_REGEX = /^[\\w+-]+(?:\\.[\\w+-]+)*@[\\da-z]+(?:[.-][\\da-z]+)*\\.[a-z]{2,}$/iu;\nvar EMOJI_REGEX = /^[\\p{Extended_Pictographic}\\p{Emoji_Component}]+$/u;\nvar IMEI_REGEX = /^\\d{2}(?:[ /|-]?\\d{6}){2}[ /|-]?\\d$/u;\nvar IPV4_REGEX = (\n  // eslint-disable-next-line redos-detector/no-unsafe-regex -- false positive\n  /^(?:(?:[1-9]|1\\d|2[0-4])?\\d|25[0-5])(?:\\.(?:(?:[1-9]|1\\d|2[0-4])?\\d|25[0-5])){3}$/u\n);\nvar IPV6_REGEX = /^(?:(?:[\\da-f]{1,4}:){7}[\\da-f]{1,4}|(?:[\\da-f]{1,4}:){1,7}:|(?:[\\da-f]{1,4}:){1,6}:[\\da-f]{1,4}|(?:[\\da-f]{1,4}:){1,5}(?::[\\da-f]{1,4}){1,2}|(?:[\\da-f]{1,4}:){1,4}(?::[\\da-f]{1,4}){1,3}|(?:[\\da-f]{1,4}:){1,3}(?::[\\da-f]{1,4}){1,4}|(?:[\\da-f]{1,4}:){1,2}(?::[\\da-f]{1,4}){1,5}|[\\da-f]{1,4}:(?::[\\da-f]{1,4}){1,6}|:(?:(?::[\\da-f]{1,4}){1,7}|:)|fe80:(?::[\\da-f]{0,4}){0,4}%[\\da-z]+|::(?:f{4}(?::0{1,4})?:)?(?:(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d)\\.){3}(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d)|(?:[\\da-f]{1,4}:){1,4}:(?:(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d)\\.){3}(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d))$/iu;\nvar ISO_DATE_REGEX = /^\\d{4}-(?:0[1-9]|1[0-2])-(?:[12]\\d|0[1-9]|3[01])$/u;\nvar ISO_DATE_TIME_REGEX = /^\\d{4}-(?:0[1-9]|1[0-2])-(?:[12]\\d|0[1-9]|3[01])T(?:0\\d|1\\d|2[0-3]):[0-5]\\d$/u;\nvar ISO_TIME_REGEX = /^(?:0\\d|1\\d|2[0-3]):[0-5]\\d$/u;\nvar ISO_TIME_SECOND_REGEX = /^(?:0\\d|1\\d|2[0-3])(?::[0-5]\\d){2}$/u;\nvar ISO_TIMESTAMP_REGEX = /^\\d{4}-(?:0[1-9]|1[0-2])-(?:[12]\\d|0[1-9]|3[01])T(?:0\\d|1\\d|2[0-3])(?::[0-5]\\d){2}\\.\\d{3}Z$/u;\nvar ISO_WEEK_REGEX = /^\\d{4}-W(?:0[1-9]|[1-4]\\d|5[0-3])$/u;\nvar ULID_REGEX = /^[\\da-hjkmnp-tv-z]{26}$/iu;\nvar UUID_REGEX = /^[\\da-f]{8}(?:-[\\da-f]{4}){3}-[\\da-f]{12}$/iu;\n\n// src/transformations/toCustom/toCustom.ts\nfunction toCustom(action) {\n  return (input) => getOutput(action(input));\n}\n\n// src/transformations/toCustom/toCustomAsync.ts\nfunction toCustomAsync(action) {\n  return async (input) => getOutput(await action(input));\n}\n\n// src/transformations/toLowerCase/toLowerCase.ts\nfunction toLowerCase() {\n  return (input) => getOutput(input.toLocaleLowerCase());\n}\n\n// src/transformations/toMaxValue/toMaxValue.ts\nfunction toMaxValue(requirement) {\n  return (input) => getOutput(input > requirement ? requirement : input);\n}\n\n// src/transformations/toMinValue/toMinValue.ts\nfunction toMinValue(requirement) {\n  return (input) => getOutput(input < requirement ? requirement : input);\n}\n\n// src/transformations/toTrimmed/toTrimmed.ts\nfunction toTrimmed() {\n  return (input) => getOutput(input.trim());\n}\n\n// src/transformations/toTrimmedEnd/toTrimmedEnd.ts\nfunction toTrimmedEnd() {\n  return (input) => getOutput(input.trimEnd());\n}\n\n// src/transformations/toTrimmedStart/toTrimmedStart.ts\nfunction toTrimmedStart() {\n  return (input) => getOutput(input.trimStart());\n}\n\n// src/transformations/toUpperCase/toUpperCase.ts\nfunction toUpperCase() {\n  return (input) => getOutput(input.toUpperCase());\n}\n\n// src/validations/bytes/bytes.ts\nfunction bytes(requirement, error) {\n  return (input) => new TextEncoder().encode(input).length !== requirement ? getPipeIssues(\"bytes\", error || \"Invalid byte length\", input) : getOutput(input);\n}\n\n// src/validations/cuid2/cuid2.ts\nfunction cuid2(error) {\n  return (input) => !CUID2_REGEX.test(input) ? getPipeIssues(\"cuid2\", error || \"Invalid cuid2\", input) : getOutput(input);\n}\n\n// src/validations/custom/custom.ts\nfunction custom(requirement, error) {\n  return (input) => !requirement(input) ? getPipeIssues(\"custom\", error || \"Invalid input\", input) : getOutput(input);\n}\n\n// src/validations/custom/customAsync.ts\nfunction customAsync(requirement, error) {\n  return async (input) => !await requirement(input) ? getPipeIssues(\"custom\", error || \"Invalid input\", input) : getOutput(input);\n}\n\n// src/validations/email/email.ts\nfunction email(error) {\n  return (input) => !EMAIL_REGEX.test(input) ? getPipeIssues(\"email\", error || \"Invalid email\", input) : getOutput(input);\n}\n\n// src/validations/emoji/emoji.ts\nfunction emoji(error) {\n  return (input) => !EMOJI_REGEX.test(input) ? getPipeIssues(\"emoji\", error || \"Invalid emoji\", input) : getOutput(input);\n}\n\n// src/validations/endsWith/endsWith.ts\nfunction endsWith(requirement, error) {\n  return (input) => !input.endsWith(requirement) ? getPipeIssues(\"ends_with\", error || \"Invalid end\", input) : getOutput(input);\n}\n\n// src/validations/equal/equal.ts\nfunction equal(requirement, error) {\n  return (input) => input !== requirement ? getPipeIssues(\"equal\", error || \"Invalid input\", input) : getOutput(input);\n}\n\n// src/validations/excludes/excludes.ts\nfunction excludes(requirement, error) {\n  return (input) => input.includes(requirement) ? getPipeIssues(\"excludes\", error || \"Invalid content\", input) : getOutput(input);\n}\n\n// src/validations/finite/finite.ts\nfunction finite(error) {\n  return (input) => !Number.isFinite(input) ? getPipeIssues(\"finite\", error || \"Invalid finite number\", input) : getOutput(input);\n}\n\n// src/validations/imei/imei.ts\nfunction imei(error) {\n  return (input) => !IMEI_REGEX.test(input) || !isLuhnAlgo(input) ? getPipeIssues(\"imei\", error || \"Invalid IMEI\", input) : getOutput(input);\n}\n\n// src/validations/includes/includes.ts\nfunction includes(requirement, error) {\n  return (input) => !input.includes(requirement) ? getPipeIssues(\"includes\", error || \"Invalid content\", input) : getOutput(input);\n}\n\n// src/validations/integer/integer.ts\nfunction integer(error) {\n  return (input) => !Number.isInteger(input) ? getPipeIssues(\"integer\", error || \"Invalid integer\", input) : getOutput(input);\n}\n\n// src/validations/ip/ip.ts\nfunction ip(error) {\n  return (input) => !IPV4_REGEX.test(input) && !IPV6_REGEX.test(input) ? getPipeIssues(\"ip\", error || \"Invalid IP\", input) : getOutput(input);\n}\n\n// src/validations/ipv4/ipv4.ts\nfunction ipv4(error) {\n  return (input) => !IPV4_REGEX.test(input) ? getPipeIssues(\"ipv4\", error || \"Invalid IP v4\", input) : getOutput(input);\n}\n\n// src/validations/ipv6/ipv6.ts\nfunction ipv6(error) {\n  return (input) => !IPV6_REGEX.test(input) ? getPipeIssues(\"ipv6\", error || \"Invalid IP v6\", input) : getOutput(input);\n}\n\n// src/validations/isoDate/isoDate.ts\nfunction isoDate(error) {\n  return (input) => !ISO_DATE_REGEX.test(input) ? getPipeIssues(\"iso_date\", error || \"Invalid date\", input) : getOutput(input);\n}\n\n// src/validations/isoDateTime/isoDateTime.ts\nfunction isoDateTime(error) {\n  return (input) => !ISO_DATE_TIME_REGEX.test(input) ? getPipeIssues(\"iso_date_time\", error || \"Invalid datetime\", input) : getOutput(input);\n}\n\n// src/validations/isoTime/isoTime.ts\nfunction isoTime(error) {\n  return (input) => !ISO_TIME_REGEX.test(input) ? getPipeIssues(\"iso_time\", error || \"Invalid time\", input) : getOutput(input);\n}\n\n// src/validations/isoTimeSecond/isoTimeSecond.ts\nfunction isoTimeSecond(error) {\n  return (input) => !ISO_TIME_SECOND_REGEX.test(input) ? getPipeIssues(\"iso_time_second\", error || \"Invalid time\", input) : getOutput(input);\n}\n\n// src/validations/isoTimestamp/isoTimestamp.ts\nfunction isoTimestamp(error) {\n  return (input) => !ISO_TIMESTAMP_REGEX.test(input) ? getPipeIssues(\"iso_timestamp\", error || \"Invalid timestamp\", input) : getOutput(input);\n}\n\n// src/validations/isoWeek/isoWeek.ts\nfunction isoWeek(error) {\n  return (input) => !ISO_WEEK_REGEX.test(input) ? getPipeIssues(\"iso_week\", error || \"Invalid week\", input) : getOutput(input);\n}\n\n// src/validations/length/length.ts\nfunction length(requirement, error) {\n  return (input) => input.length !== requirement ? getPipeIssues(\"length\", error || \"Invalid length\", input) : getOutput(input);\n}\n\n// src/validations/maxBytes/maxBytes.ts\nfunction maxBytes(requirement, error) {\n  return (input) => new TextEncoder().encode(input).length > requirement ? getPipeIssues(\"max_bytes\", error || \"Invalid byte length\", input) : getOutput(input);\n}\n\n// src/validations/maxLength/maxLength.ts\nfunction maxLength(requirement, error) {\n  return (input) => input.length > requirement ? getPipeIssues(\"max_length\", error || \"Invalid length\", input) : getOutput(input);\n}\n\n// src/validations/maxSize/maxSize.ts\nfunction maxSize(requirement, error) {\n  return (input) => input.size > requirement ? getPipeIssues(\"max_size\", error || \"Invalid size\", input) : getOutput(input);\n}\n\n// src/validations/maxValue/maxValue.ts\nfunction maxValue(requirement, error) {\n  return (input) => input > requirement ? getPipeIssues(\"max_value\", error || \"Invalid value\", input) : getOutput(input);\n}\nvar maxRange = maxValue;\n\n// src/validations/minBytes/minBytes.ts\nfunction minBytes(requirement, error) {\n  return (input) => new TextEncoder().encode(input).length < requirement ? getPipeIssues(\"min_bytes\", error || \"Invalid byte length\", input) : getOutput(input);\n}\n\n// src/validations/mimeType/mimeType.ts\nfunction mimeType(requirement, error) {\n  return (input) => !requirement.includes(input.type) ? getPipeIssues(\"mime_type\", error || \"Invalid MIME type\", input) : getOutput(input);\n}\n\n// src/validations/minLength/minLength.ts\nfunction minLength(requirement, error) {\n  return (input) => input.length < requirement ? getPipeIssues(\"min_length\", error || \"Invalid length\", input) : getOutput(input);\n}\n\n// src/validations/minSize/minSize.ts\nfunction minSize(requirement, error) {\n  return (input) => input.size < requirement ? getPipeIssues(\"min_size\", error || \"Invalid size\", input) : getOutput(input);\n}\n\n// src/validations/minValue/minValue.ts\nfunction minValue(requirement, error) {\n  return (input) => input < requirement ? getPipeIssues(\"min_value\", error || \"Invalid value\", input) : getOutput(input);\n}\nvar minRange = minValue;\n\n// src/validations/multipleOf/multipleOf.ts\nfunction multipleOf(requirement, error) {\n  return (input) => input % requirement !== 0 ? getPipeIssues(\"multiple_of\", error || \"Invalid multiple\", input) : getOutput(input);\n}\n\n// src/validations/notBytes/notBytes.ts\nfunction notBytes(requirement, error) {\n  return (input) => new TextEncoder().encode(input).length === requirement ? getPipeIssues(\"not_bytes\", error || \"Invalid byte length\", input) : getOutput(input);\n}\n\n// src/validations/notLength/notLength.ts\nfunction notLength(requirement, error) {\n  return (input) => input.length === requirement ? getPipeIssues(\"not_length\", error || \"Invalid length\", input) : getOutput(input);\n}\n\n// src/validations/notSize/notSize.ts\nfunction notSize(requirement, error) {\n  return (input) => input.size === requirement ? getPipeIssues(\"not_size\", error || \"Invalid size\", input) : getOutput(input);\n}\n\n// src/validations/notValue/notValue.ts\nfunction notValue(requirement, error) {\n  return (input) => input === requirement ? getPipeIssues(\"not_value\", error || \"Invalid value\", input) : getOutput(input);\n}\n\n// src/validations/regex/regex.ts\nfunction regex(requirement, error) {\n  return (input) => !requirement.test(input) ? getPipeIssues(\"regex\", error || \"Invalid regex\", input) : getOutput(input);\n}\n\n// src/validations/safeInteger/safeInteger.ts\nfunction safeInteger(error) {\n  return (input) => !Number.isSafeInteger(input) ? getPipeIssues(\"safe_integer\", error || \"Invalid safe integer\", input) : getOutput(input);\n}\n\n// src/validations/size/size.ts\nfunction size(requirement, error) {\n  return (input) => input.size !== requirement ? getPipeIssues(\"size\", error || \"Invalid size\", input) : getOutput(input);\n}\n\n// src/validations/startsWith/startsWith.ts\nfunction startsWith(requirement, error) {\n  return (input) => !input.startsWith(requirement) ? getPipeIssues(\"starts_with\", error || \"Invalid start\", input) : getOutput(input);\n}\n\n// src/validations/ulid/ulid.ts\nfunction ulid(error) {\n  return (input) => !ULID_REGEX.test(input) ? getPipeIssues(\"ulid\", error || \"Invalid ULID\", input) : getOutput(input);\n}\n\n// src/validations/url/url.ts\nfunction url(error) {\n  return (input) => {\n    try {\n      new URL(input);\n      return getOutput(input);\n    } catch (_) {\n      return getPipeIssues(\"url\", error || \"Invalid URL\", input);\n    }\n  };\n}\n\n// src/validations/uuid/uuid.ts\nfunction uuid(error) {\n  return (input) => !UUID_REGEX.test(input) ? getPipeIssues(\"uuid\", error || \"Invalid UUID\", input) : getOutput(input);\n}\n\n// src/validations/value/value.ts\nfunction value(requirement, error) {\n  return (input) => input !== requirement ? getPipeIssues(\"value\", error || \"Invalid value\", input) : getOutput(input);\n}\nexport {\n  BrandSymbol,\n  CUID2_REGEX,\n  EMAIL_REGEX,\n  EMOJI_REGEX,\n  IMEI_REGEX,\n  IPV4_REGEX,\n  IPV6_REGEX,\n  ISO_DATE_REGEX,\n  ISO_DATE_TIME_REGEX,\n  ISO_TIMESTAMP_REGEX,\n  ISO_TIME_REGEX,\n  ISO_TIME_SECOND_REGEX,\n  ISO_WEEK_REGEX,\n  ULID_REGEX,\n  UUID_REGEX,\n  ValiError,\n  any,\n  anyAsync,\n  array,\n  arrayAsync,\n  bigint,\n  bigintAsync,\n  blob,\n  blobAsync,\n  boolean,\n  booleanAsync,\n  brand,\n  bytes,\n  coerce,\n  coerceAsync,\n  cuid2,\n  custom,\n  customAsync,\n  date,\n  dateAsync,\n  discriminatedUnion,\n  discriminatedUnionAsync,\n  email,\n  emoji,\n  endsWith,\n  enumAsync,\n  enumType,\n  enumTypeAsync,\n  enum_,\n  equal,\n  excludes,\n  executePipe,\n  executePipeAsync,\n  fallback,\n  fallbackAsync,\n  finite,\n  flatten,\n  getDefault,\n  getDefaultArgs,\n  getDefaultAsync,\n  getDefaults,\n  getDefaultsAsync,\n  getFallback,\n  getFallbackAsync,\n  getFallbacks,\n  getFallbacksAsync,\n  getIssues,\n  getOutput,\n  getPipeIssues,\n  getRestAndDefaultArgs,\n  getSchemaIssues,\n  imei,\n  includes,\n  instance,\n  instanceAsync,\n  integer,\n  intersect,\n  intersection,\n  ip,\n  ipv4,\n  ipv6,\n  is,\n  isLuhnAlgo,\n  isoDate,\n  isoDateTime,\n  isoTime,\n  isoTimeSecond,\n  isoTimestamp,\n  isoWeek,\n  keyof,\n  length,\n  literal,\n  literalAsync,\n  map,\n  mapAsync,\n  maxBytes,\n  maxLength,\n  maxRange,\n  maxSize,\n  maxValue,\n  merge,\n  mergeAsync,\n  mimeType,\n  minBytes,\n  minLength,\n  minRange,\n  minSize,\n  minValue,\n  multipleOf,\n  nan,\n  nanAsync,\n  nativeEnum,\n  nativeEnumAsync,\n  never,\n  neverAsync,\n  nonNullable,\n  nonNullableAsync,\n  nonNullish,\n  nonNullishAsync,\n  nonOptional,\n  nonOptionalAsync,\n  notBytes,\n  notLength,\n  notSize,\n  notValue,\n  nullAsync,\n  nullType,\n  nullTypeAsync,\n  null_,\n  nullable,\n  nullableAsync,\n  nullish,\n  nullishAsync,\n  number,\n  numberAsync,\n  object,\n  objectAsync,\n  omit,\n  omitAsync,\n  optional,\n  optionalAsync,\n  parse,\n  parseAsync,\n  partial,\n  partialAsync,\n  passthrough,\n  passthroughAsync,\n  pick,\n  pickAsync,\n  picklist,\n  picklistAsync,\n  record,\n  recordAsync,\n  recursive,\n  recursiveAsync,\n  regex,\n  required,\n  requiredAsync,\n  safeInteger,\n  safeParse,\n  safeParseAsync,\n  set,\n  setAsync,\n  size,\n  special,\n  specialAsync,\n  startsWith,\n  strict,\n  strictAsync,\n  string,\n  stringAsync,\n  strip,\n  stripAsync,\n  symbol,\n  symbolAsync,\n  toCustom,\n  toCustomAsync,\n  toLowerCase,\n  toMaxValue,\n  toMinValue,\n  toTrimmed,\n  toTrimmedEnd,\n  toTrimmedStart,\n  toUpperCase,\n  transform,\n  transformAsync,\n  tuple,\n  tupleAsync,\n  ulid,\n  undefinedAsync,\n  undefinedType,\n  undefinedTypeAsync,\n  undefined_,\n  union,\n  unionAsync,\n  unknown,\n  unknownAsync,\n  unwrap,\n  url,\n  useDefault,\n  uuid,\n  value,\n  variant,\n  variantAsync,\n  voidAsync,\n  voidType,\n  voidTypeAsync,\n  void_,\n  withDefault\n};\n","function n(n){return\"object\"==typeof n&&null!==n&&!Array.isArray(n)}function e(n){return null!==n&&Array.isArray(n)}function t(n){let t=\"\";for(const r of n)\"string\"!=typeof r?\"number\"!=typeof r?e(r)?(t&&(t+=\":\"),t+=`${r.join(\",\")}}`):r._key&&(t&&(t+=\":\"),t+=`${r._key}`):(t&&(t+=\":\"),t+=`${r}`):(t&&(t+=\".\"),t+=r);return t}const r=/^([A-Za-z]+):([0-9]+)$/,o=/^([A-Za-z]+):([0-9]+),([0-9]+)$/,u=/^([A-Za-z]+):([a-z0-9]+)$/;function s(n){const e=[];for(const t of n.split(\".\")){const n=r.exec(t);if(n){e.push(n[1],Number(n[2]));continue}const s=o.exec(t);if(s){e.push(s[1],[Number(s[2]),Number(s[3])]);continue}const c=u.exec(t);c?e.push(c[1],{_key:c[2]}):e.push(t)}return e}export{e as a,n as i,t as p,s as u};//# sourceMappingURL=urlStringToPath-FefM00gz.js.map\n","import{resolveMapping as t,getPublishedId as e,studioPath as r,jsonPathToStudioPath as n,resolvedKeyedSourcePath as o}from\"@sanity/client/csm\";import{string as a,minLength as i,optional as s,object as c,is as u,safeParse as p,parse as f}from\"valibot\";import{p as l,u as d,i as h,a as m}from\"./_chunks/urlStringToPath-FefM00gz.js\";function y(a,i,s,c){const{mapping:u,pathSuffix:p}=t(s,i)||{};if(!u)return;if(\"literal\"===u.source.type)return;if(\"unknown\"===u.source.type)return;const f=i.documents[u.source.document],l=i.paths[u.source.path];return f&&l?{baseUrl:a.baseUrl,workspace:a.workspace,tool:a.tool,type:f._type,id:e(f._id),path:r.toString(n(o({keyedResultPath:c,pathSuffix:p,sourceBasePath:l})))}:void 0}const k=a([i(1)]),_=s(k),b=c({id:k,path:k,type:_,baseUrl:k,workspace:_,tool:_}),w=c({origin:k,href:k,data:_});function v(t){return u(b,t)}function g(t){return u(w,t)}function j(t){const{id:n,path:o,baseUrl:a,tool:i,workspace:s,type:c}=t;if(!v(t))return;return[[\"id\",e(n)],[\"type\",c],[\"path\",l(r.fromString(o))],[\"base\",encodeURIComponent(a)],[\"workspace\",s],[\"tool\",i]].filter((([,t])=>!!t)).map((t=>t.join(\"=\"))).join(\";\")}function S(t){const e=t.split(\";\").reduce(((t,e)=>{const[n,o]=e.split(\"=\");if(!n||!o)return t;switch(n){case\"id\":t.id=o;break;case\"type\":t.type=o;break;case\"path\":t.path=r.toString(d(o));break;case\"base\":t.baseUrl=decodeURIComponent(o);break;case\"tool\":t.tool=o;break;case\"workspace\":t.workspace=o}return t}),{});if(v(e))return e}function U(t){try{return function(t){const e=p(b,t);if(e.success)return e.output;const r=p(w,t);if(r.success)try{const t=new URL(r.output.href,\"undefined\"==typeof document?\"https://example.com\":location.origin);return t.searchParams.size>0?f(b,Object.fromEntries(t.searchParams.entries())):r.output}catch(t){return console.error(\"Failed to parse sanity node\",t),r.output}}(JSON.parse(t))}catch{return S(t)}}const $=[\"_createdAt\",\"_dataset\",\"_id\",\"_key\",\"_originalId\",\"_projectId\",\"_ref\",\"_rev\",\"_strengthenOnPublish\",\"_type\",\"_updatedAt\",\"_weak\"];function O(t){if(void 0!==t){if(null===t)return null;if(h(e=t)&&\"sanity\"===e.$$type$$)return t.value;var e;if(m(t))return t.map((t=>O(t)));if(h(t))return Object.fromEntries(Object.entries(t).map((([t,e])=>$.includes(t)?[t,e]:[t,O(e)])));throw new Error(\"invalid wrapped value\")}}function P(t,e,o,a=[],i=[]){if(void 0!==e)return null===e?null:m(e)?e.map(((e,r)=>P(t,e,o,a.concat(r),i.concat(h(e)&&\"_key\"in e&&\"string\"==typeof e._key?{_key:e._key,_index:r}:r)))):h(e)?Object.fromEntries(Object.entries(e).map((([e,r])=>$.includes(e)?[e,r]:[e,P(t,r,o,a.concat(e),i.concat(e))]))):{$$type$$:\"sanity\",path:r.toString(n(a))||void 0,source:o?y(t,o,a,i):void 0,value:e}}export{U as decodeSanityNodeData,S as decodeSanityString,j as encodeSanityNodeData,g as isValidSanityLegacyNode,v as isValidSanityNode,y as resolveSanityNode,O as unwrapData,P as wrapData};//# sourceMappingURL=csm.js.map\n","import type { HTMLProps, Ref } from 'react'\nimport { createElement, forwardRef } from 'react'\nimport {\n  encodeSanityNodeData,\n  type SourceNode,\n} from 'visual-editing-helpers/csm'\n\nexport interface SanityElementProps {\n  children?: SourceNode | null\n}\n\nexport const SanityElement = forwardRef(function SanityElement(\n  props: { as: string } & SanityElementProps &\n    Omit<HTMLProps<HTMLElement>, 'children'>,\n  ref: Ref<HTMLElement | SVGElement>,\n) {\n  const { as, children: node, ...restProps } = props\n\n  if (node?.source) {\n    return createElement(\n      as,\n      {\n        ...restProps,\n        'data-sanity': encodeSanityNodeData(node.source),\n        ref,\n      },\n      node.value,\n    )\n  }\n\n  return createElement(as, restProps, node?.value)\n})\n","export const svgElements = [\n  'animate',\n  'circle',\n  'defs',\n  'desc',\n  'ellipse',\n  'g',\n  'image',\n  'line',\n  'filter',\n  'marker',\n  'mask',\n  'metadata',\n  'path',\n  'pattern',\n  'polygon',\n  'polyline',\n  'rect',\n  'stop',\n  'svg',\n  'switch',\n  'symbol',\n  'text',\n  'tspan',\n  'use',\n  'view',\n  'clipPath',\n  'feBlend',\n  'feColorMatrix',\n  'feComponentTransfer',\n  'feComposite',\n  'feConvolveMatrix',\n  'feDiffuseLighting',\n  'feDisplacementMap',\n  'feDistantLight',\n  'feDropShadow',\n  'feFlood',\n  'feFuncA',\n  'feFuncB',\n  'feFuncG',\n  'feFuncR',\n  'feGaussianBlur',\n  'feImage',\n  'feMerge',\n  'feMergeNode',\n  'feMorphology',\n  'feOffset',\n  'fePointLight',\n  'feSpecularLighting',\n  'feSpotLight',\n  'feTile',\n  'feTurbulence',\n  'foreignObject',\n  'linearGradient',\n  'radialGradient',\n  'textPath',\n] as const\n","import type {\n  ForwardRefExoticComponent,\n  HTMLProps,\n  ReactElement,\n  Ref,\n  SVGProps,\n} from 'react'\nimport { createElement, forwardRef } from 'react'\n\nimport { htmlElements } from './html'\nimport type { SanityElementProps } from './SanityElement'\nimport { SanityElement } from './SanityElement'\nimport { svgElements } from './svg'\n\nexport type SanityHTMLElements = Record<\n  (typeof htmlElements)[number],\n  ForwardRefExoticComponent<\n    SanityElementProps & Omit<HTMLProps<HTMLElement>, 'children' | 'ref'>\n  >\n>\n\nexport type SanitySVGElements = Record<\n  (typeof svgElements)[number],\n  ForwardRefExoticComponent<\n    SanityElementProps & Omit<SVGProps<SVGElement>, 'children' | 'ref'>\n  >\n>\n\nexport type SanityElements = SanityHTMLElements & SanitySVGElements\n\nfunction isHTMLElement(name: string): name is keyof SanityHTMLElements {\n  return htmlElements.includes(name as any)\n}\n\nfunction isSVGElement(name: string): name is keyof SanitySVGElements {\n  return svgElements.includes(name as any)\n}\n\nconst sanity = new Proxy({} as SanityElements, {\n  get(target: SanityElements, prop: string) {\n    if (isHTMLElement(prop)) {\n      if (target[prop]) return target[prop]\n\n      const SanityComponent = forwardRef(function SanityComponent(\n        props: SanityElementProps &\n          Omit<HTMLProps<HTMLElement>, 'children' | 'ref'>,\n        ref: Ref<HTMLElement>,\n      ): ReactElement {\n        return createElement(SanityElement, { as: prop, ref, ...props })\n      })\n\n      SanityComponent.displayName = `sanity.${prop}`\n\n      target[prop] = SanityComponent\n\n      return SanityComponent\n    }\n\n    if (isSVGElement(prop)) {\n      if (target[prop]) return target[prop]\n\n      const SanityComponent = forwardRef(function SanityComponent(\n        props: SanityElementProps &\n          Omit<SVGProps<SVGElement>, 'children' | 'ref'>,\n        ref: Ref<SVGElement>,\n      ): ReactElement {\n        return createElement(SanityElement, { as: prop, ref, ...props } as any)\n      })\n\n      SanityComponent.displayName = `sanity.${prop}`\n\n      target[prop] = SanityComponent as any\n\n      return SanityComponent\n    }\n\n    throw new Error(`No such element: ${prop}`)\n  },\n})\n\nexport { sanity }\n"],"names":["Object","defineProperty","exports","value","react","require","csm","htmlElements","getIssues","issues","getOutput","output","getIssue","info","issue","reason","validation","origin","message","input","path","abortEarly","abortPipeEarly","skipPipe","getPipeInfo","executePipe","pipe","parseInfo","length","pipeInfo","action","result","issueInfo","push","getDefaultArgs","arg1","arg2","Array","isArray","getErrorMessage","error","getSchemaIssues","n","e","t","r","join","_key","y","a","i","s","c","mapping","u","pathSuffix","p","source","type","f","documents","document","l","paths","baseUrl","workspace","tool","_type","id","_id","studioPath","toString","jsonPathToStudioPath","o","resolvedKeyedSourcePath","keyedResultPath","sourceBasePath","k","async","_parse","requirement","getPipeIssues","_","wrapped","getDefault","default_","override","this","b","entries","arg3","arg4","rest","error2","pipe2","getRestAndDefaultArgs","cachedEntries","key","schema","value2","pathItem","unshift","j","v","fromString","encodeURIComponent","filter","map","$","SanityElement","forwardRef","props","ref","as","children","node","restProps","createElement","encodeSanityNodeData","svgElements","sanity","Proxy","get","target","prop","name","includes","SanityComponent","displayName","isSVGElement","Error","unwrapData","O","h","$$type$$","m","fromEntries","wrapData","P","concat","_index"],"mappings":"AAAO,aAAAA,OAAAC,eAAAC,QAAA,aAAA,CAAAC,OAAA,IAAA,IAAAC,EAAAC,QAAA,SAAAC,EAAAD,QAAA,sBAAA,MAAME,EAAe,CAC1B,IACA,OACA,UACA,OACA,UACA,QACA,QACA,IACA,OACA,MACA,MACA,MACA,aACA,OACA,KACA,SACA,SACA,UACA,OACA,OACA,MACA,WACA,OACA,WACA,KACA,MACA,UACA,MACA,SACA,MACA,KACA,KACA,KACA,QACA,WACA,aACA,SACA,SACA,OACA,KACA,KACA,KACA,KACA,KACA,KACA,OACA,SACA,SACA,KACA,OACA,IACA,SACA,MACA,QACA,MACA,MACA,SACA,QACA,SACA,KACA,OACA,OACA,MACA,OACA,OACA,WACA,OACA,QACA,MACA,WACA,SACA,KACA,WACA,SACA,SACA,IACA,QACA,UACA,MACA,WACA,IACA,KACA,KACA,OACA,IACA,OACA,SACA,UACA,SACA,QACA,SACA,OACA,SACA,QACA,MACA,UACA,MACA,QACA,QACA,KACA,WACA,QACA,KACA,QACA,OACA,QACA,KACA,QACA,IACA,KACA,MACA,QACA,MACA,WC5BF,SAASC,EAAUC,GACjB,MAAO,CAAEA,SACX,CAGA,SAASC,EAAUC,GACjB,MAAO,CAAEA,SACX,CAGA,SAASC,EAASC,EAAMC,GACtB,MAAO,CACLC,OAAQF,GAAME,OACdC,WAAYF,EAAME,WAClBC,OAAQJ,GAAMI,QAAU,QACxBC,QAASJ,EAAMI,QACfC,MAAOL,EAAMK,MACbC,KAAMN,EAAMM,KACZC,WAAYR,GAAMQ,WAClBC,eAAgBT,GAAMS,eACtBC,SAAUV,GAAMU,SAEpB,CAGA,SAASC,EAAYX,EAAME,GACzB,MAAO,CACLA,SACAE,OAAQJ,GAAMI,OACdI,WAAYR,GAAMQ,WAClBC,eAAgBT,GAAMS,eACtBC,SAAUV,GAAMU,SAEpB,CAGA,SAASE,EAAYN,EAAOO,EAAMC,EAAWZ,GAC3C,IAAKW,IAASA,EAAKE,QAAUD,GAAWJ,SACtC,OAAOb,EAAUS,GAEnB,IAAIU,EACApB,EACAE,EAA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","x_google_ignoreList":[1]}
\ No newline at end of file
+{"version":3,"file":"jsx.cjs","sources":["../src/jsx/html.ts","../../../node_modules/.pnpm/valibot@0.21.0/node_modules/valibot/dist/index.js","../../visual-editing-helpers/dist/_chunks/urlStringToPath-ntyJ_1w6.js","../../visual-editing-helpers/dist/csm.js","../src/jsx/SanityElement.tsx","../src/jsx/svg.ts","../src/jsx/jsx.ts"],"sourcesContent":["export const htmlElements = [\n  'a',\n  'abbr',\n  'address',\n  'area',\n  'article',\n  'aside',\n  'audio',\n  'b',\n  'base',\n  'bdi',\n  'bdo',\n  'big',\n  'blockquote',\n  'body',\n  'br',\n  'button',\n  'canvas',\n  'caption',\n  'cite',\n  'code',\n  'col',\n  'colgroup',\n  'data',\n  'datalist',\n  'dd',\n  'del',\n  'details',\n  'dfn',\n  'dialog',\n  'div',\n  'dl',\n  'dt',\n  'em',\n  'embed',\n  'fieldset',\n  'figcaption',\n  'figure',\n  'footer',\n  'form',\n  'h1',\n  'h2',\n  'h3',\n  'h4',\n  'h5',\n  'h6',\n  'head',\n  'header',\n  'hgroup',\n  'hr',\n  'html',\n  'i',\n  'iframe',\n  'img',\n  'input',\n  'ins',\n  'kbd',\n  'keygen',\n  'label',\n  'legend',\n  'li',\n  'link',\n  'main',\n  'map',\n  'mark',\n  'menu',\n  'menuitem',\n  'meta',\n  'meter',\n  'nav',\n  'noscript',\n  'object',\n  'ol',\n  'optgroup',\n  'option',\n  'output',\n  'p',\n  'param',\n  'picture',\n  'pre',\n  'progress',\n  'q',\n  'rp',\n  'rt',\n  'ruby',\n  's',\n  'samp',\n  'script',\n  'section',\n  'select',\n  'small',\n  'source',\n  'span',\n  'strong',\n  'style',\n  'sub',\n  'summary',\n  'sup',\n  'table',\n  'tbody',\n  'td',\n  'textarea',\n  'tfoot',\n  'th',\n  'thead',\n  'time',\n  'title',\n  'tr',\n  'track',\n  'u',\n  'ul',\n  'var',\n  'video',\n  'wbr',\n  'webview',\n] as const\n","// src/error/flatten/flatten.ts\nfunction flatten(arg1) {\n  return (Array.isArray(arg1) ? arg1 : arg1.issues).reduce(\n    (flatErrors, issue) => {\n      if (issue.path) {\n        if (issue.path.every(\n          ({ key }) => typeof key === \"string\" || typeof key === \"number\"\n        )) {\n          const path = issue.path.map(({ key }) => key).join(\".\");\n          if (flatErrors.nested[path]) {\n            flatErrors.nested[path].push(issue.message);\n          } else {\n            flatErrors.nested[path] = [issue.message];\n          }\n        }\n      } else {\n        if (flatErrors.root) {\n          flatErrors.root.push(issue.message);\n        } else {\n          flatErrors.root = [issue.message];\n        }\n      }\n      return flatErrors;\n    },\n    { nested: {} }\n  );\n}\n\n// src/error/ValiError/ValiError.ts\nvar ValiError = class extends Error {\n  issues;\n  /**\n   * Creates a Valibot error with useful information.\n   *\n   * @param issues The error issues.\n   */\n  constructor(issues) {\n    super(issues[0].message);\n    this.name = \"ValiError\";\n    this.issues = issues;\n  }\n};\n\n// src/methods/brand/brand.ts\nvar BrandSymbol = Symbol(\"brand\");\nfunction brand(schema, name) {\n  return schema;\n}\n\n// src/methods/coerce/coerce.ts\nfunction coerce(schema, action) {\n  return {\n    ...schema,\n    _parse(input, info) {\n      return schema._parse(action(input), info);\n    }\n  };\n}\n\n// src/methods/coerce/coerceAsync.ts\nfunction coerceAsync(schema, action) {\n  return {\n    ...schema,\n    async _parse(input, info) {\n      return schema._parse(await action(input), info);\n    }\n  };\n}\n\n// src/utils/getIssues/getIssues.ts\nfunction getIssues(issues) {\n  return { issues };\n}\n\n// src/utils/getOutput/getOutput.ts\nfunction getOutput(output) {\n  return { output };\n}\n\n// src/utils/executePipe/utils/getIssue/getIssue.ts\nfunction getIssue(info, issue) {\n  return {\n    reason: info?.reason,\n    validation: issue.validation,\n    origin: info?.origin || \"value\",\n    message: issue.message,\n    input: issue.input,\n    path: issue.path,\n    abortEarly: info?.abortEarly,\n    abortPipeEarly: info?.abortPipeEarly,\n    skipPipe: info?.skipPipe\n  };\n}\n\n// src/utils/executePipe/utils/getPipeInfo/getPipeInfo.ts\nfunction getPipeInfo(info, reason) {\n  return {\n    reason,\n    origin: info?.origin,\n    abortEarly: info?.abortEarly,\n    abortPipeEarly: info?.abortPipeEarly,\n    skipPipe: info?.skipPipe\n  };\n}\n\n// src/utils/executePipe/executePipe.ts\nfunction executePipe(input, pipe, parseInfo, reason) {\n  if (!pipe || !pipe.length || parseInfo?.skipPipe) {\n    return getOutput(input);\n  }\n  let pipeInfo;\n  let issues;\n  let output = input;\n  for (const action of pipe) {\n    const result = action._parse(output);\n    if (result.issues) {\n      pipeInfo = pipeInfo || getPipeInfo(parseInfo, reason);\n      for (const issueInfo of result.issues) {\n        const issue = getIssue(pipeInfo, issueInfo);\n        issues ? issues.push(issue) : issues = [issue];\n      }\n      if (pipeInfo.abortEarly || pipeInfo.abortPipeEarly) {\n        break;\n      }\n    } else {\n      output = result.output;\n    }\n  }\n  return issues ? getIssues(issues) : getOutput(output);\n}\n\n// src/utils/executePipe/executePipeAsync.ts\nasync function executePipeAsync(input, pipe, parseInfo, reason) {\n  if (!pipe || !pipe.length || parseInfo?.skipPipe) {\n    return getOutput(input);\n  }\n  let pipeInfo;\n  let issues;\n  let output = input;\n  for (const action of pipe) {\n    const result = await action._parse(output);\n    if (result.issues) {\n      pipeInfo = pipeInfo || getPipeInfo(parseInfo, reason);\n      for (const issueInfo of result.issues) {\n        const issue = getIssue(pipeInfo, issueInfo);\n        issues ? issues.push(issue) : issues = [issue];\n      }\n      if (pipeInfo.abortEarly || pipeInfo.abortPipeEarly) {\n        break;\n      }\n    } else {\n      output = result.output;\n    }\n  }\n  return issues ? getIssues(issues) : getOutput(output);\n}\n\n// src/utils/getDefaultArgs/getDefaultArgs.ts\nfunction getDefaultArgs(arg1, arg2) {\n  return Array.isArray(arg1) ? [void 0, arg1] : [arg1, arg2];\n}\n\n// src/utils/getErrorMessage/getErrorMessage.ts\nfunction getErrorMessage(message) {\n  return typeof message === \"function\" ? message() : message;\n}\n\n// src/utils/getPipeIssues/getPipeIssues.ts\nfunction getPipeIssues(validation, message, input, requirement) {\n  return getIssues([\n    {\n      validation,\n      message: getErrorMessage(message),\n      input,\n      requirement\n    }\n  ]);\n}\n\n// src/utils/getRestAndDefaultArgs/getRestAndDefaultArgs.ts\nfunction getRestAndDefaultArgs(arg1, arg2, arg3) {\n  if (!arg1 || typeof arg1 === \"object\" && !Array.isArray(arg1)) {\n    const [error2, pipe2] = getDefaultArgs(arg2, arg3);\n    return [arg1, error2, pipe2];\n  }\n  const [error, pipe] = getDefaultArgs(\n    arg1,\n    arg2\n  );\n  return [void 0, error, pipe];\n}\n\n// src/utils/getSchemaIssues/getSchemaIssues.ts\nfunction getSchemaIssues(info, reason, validation, message, input, issues) {\n  return {\n    issues: [\n      {\n        reason,\n        validation,\n        origin: info?.origin || \"value\",\n        message: getErrorMessage(message),\n        input,\n        issues,\n        abortEarly: info?.abortEarly,\n        abortPipeEarly: info?.abortPipeEarly,\n        skipPipe: info?.skipPipe\n      }\n    ]\n  };\n}\n\n// src/utils/isLuhnAlgo/isLuhnAlgo.ts\nvar NON_DIGIT_REGEX = /\\D/gu;\nfunction isLuhnAlgo(input) {\n  const number2 = input.replaceAll(NON_DIGIT_REGEX, \"\");\n  let length2 = number2.length;\n  let bit = 1;\n  let sum = 0;\n  while (length2) {\n    const value2 = +number2[--length2];\n    bit ^= 1;\n    sum += bit ? [0, 2, 4, 6, 8, 1, 3, 5, 7, 9][value2] : value2;\n  }\n  return sum % 10 === 0;\n}\n\n// src/methods/getFallback/getFallback.ts\nfunction getFallback(schema, info) {\n  return typeof schema.fallback === \"function\" ? schema.fallback(info) : schema.fallback;\n}\n\n// src/methods/getFallback/getFallbackAsync.ts\nasync function getFallbackAsync(schema, info) {\n  return typeof schema.fallback === \"function\" ? await schema.fallback(info) : schema.fallback;\n}\n\n// src/methods/fallback/fallback.ts\nfunction fallback(schema, fallback2) {\n  return {\n    ...schema,\n    fallback: fallback2,\n    _parse(input, info) {\n      const result = schema._parse(input, info);\n      return getOutput(\n        result.issues ? getFallback(this, { input, issues: result.issues }) : result.output\n      );\n    }\n  };\n}\n\n// src/methods/fallback/fallbackAsync.ts\nfunction fallbackAsync(schema, fallback2) {\n  return {\n    ...schema,\n    fallback: fallback2,\n    async _parse(input, info) {\n      const result = await schema._parse(input, info);\n      return getOutput(\n        result.issues ? await getFallbackAsync(this, { input, issues: result.issues }) : result.output\n      );\n    }\n  };\n}\n\n// src/methods/getDefault/getDefault.ts\nfunction getDefault(schema) {\n  return typeof schema.default === \"function\" ? schema.default() : schema.default;\n}\n\n// src/methods/getDefault/getDefaultAsync.ts\nasync function getDefaultAsync(schema) {\n  return typeof schema.default === \"function\" ? await schema.default() : schema.default;\n}\n\n// src/methods/getDefaults/getDefaults.ts\nfunction getDefaults(schema) {\n  let defaults;\n  if (schema.default) {\n    defaults = getDefault(schema);\n  } else if (\"type\" in schema) {\n    if (schema.type === \"object\") {\n      defaults = {};\n      for (const key in schema.entries) {\n        defaults[key] = getDefaults(schema.entries[key]);\n      }\n    } else if (schema.type === \"tuple\") {\n      defaults = [];\n      for (let key = 0; key < schema.items.length; key++) {\n        defaults.push(getDefaults(schema.items[key]));\n      }\n    }\n  }\n  return defaults;\n}\n\n// src/methods/getDefaults/getDefaultsAsync.ts\nasync function getDefaultsAsync(schema) {\n  let defaults;\n  if (schema.default) {\n    defaults = await getDefaultAsync(schema);\n  } else if (\"type\" in schema) {\n    if (schema.type === \"object\") {\n      defaults = {};\n      for (const key in schema.entries) {\n        defaults[key] = await getDefaultsAsync(schema.entries[key]);\n      }\n    } else if (schema.type === \"tuple\") {\n      defaults = [];\n      for (let key = 0; key < schema.items.length; key++) {\n        defaults.push(await getDefaultsAsync(schema.items[key]));\n      }\n    }\n  }\n  return defaults;\n}\n\n// src/methods/getFallbacks/getFallbacks.ts\nfunction getFallbacks(schema) {\n  let fallbacks;\n  if (schema.fallback) {\n    fallbacks = getFallback(schema);\n  } else if (\"type\" in schema) {\n    if (schema.type === \"object\") {\n      fallbacks = {};\n      for (const key in schema.entries) {\n        fallbacks[key] = getFallbacks(schema.entries[key]);\n      }\n    } else if (schema.type === \"tuple\") {\n      fallbacks = [];\n      for (let key = 0; key < schema.items.length; key++) {\n        fallbacks.push(getFallbacks(schema.items[key]));\n      }\n    }\n  }\n  return fallbacks;\n}\n\n// src/methods/getFallbacks/getFallbacksAsync.ts\nasync function getFallbacksAsync(schema) {\n  let fallbacks;\n  if (schema.fallback) {\n    fallbacks = await getFallbackAsync(schema);\n  } else if (\"type\" in schema) {\n    if (schema.type === \"object\") {\n      fallbacks = {};\n      await Promise.all(\n        Object.entries(schema.entries).map(async ([key, schema2]) => {\n          fallbacks[key] = await getFallbacksAsync(schema2);\n        })\n      );\n    } else if (schema.type === \"tuple\") {\n      fallbacks = await Promise.all(\n        schema.items.map((schema2) => getFallbacksAsync(schema2))\n      );\n    }\n  }\n  return fallbacks;\n}\n\n// src/methods/is/is.ts\nfunction is(schema, input) {\n  return !schema._parse(input, { abortEarly: true }).issues;\n}\n\n// src/schemas/any/any.ts\nfunction any(pipe) {\n  return {\n    type: \"any\",\n    async: false,\n    pipe,\n    _parse(input, info) {\n      return executePipe(input, this.pipe, info, \"any\");\n    }\n  };\n}\n\n// src/schemas/any/anyAsync.ts\nfunction anyAsync(pipe) {\n  return {\n    type: \"any\",\n    async: true,\n    pipe,\n    async _parse(input, info) {\n      return executePipeAsync(input, this.pipe, info, \"any\");\n    }\n  };\n}\n\n// src/schemas/array/array.ts\nfunction array(item, arg2, arg3) {\n  const [message = \"Invalid type\", pipe] = getDefaultArgs(arg2, arg3);\n  return {\n    type: \"array\",\n    async: false,\n    item,\n    message,\n    pipe,\n    _parse(input, info) {\n      if (!Array.isArray(input)) {\n        return getSchemaIssues(info, \"type\", \"array\", this.message, input);\n      }\n      let issues;\n      const output = [];\n      for (let key = 0; key < input.length; key++) {\n        const value2 = input[key];\n        const result = this.item._parse(value2, info);\n        if (result.issues) {\n          const pathItem = {\n            type: \"array\",\n            input,\n            key,\n            value: value2\n          };\n          for (const issue of result.issues) {\n            if (issue.path) {\n              issue.path.unshift(pathItem);\n            } else {\n              issue.path = [pathItem];\n            }\n            issues?.push(issue);\n          }\n          if (!issues) {\n            issues = result.issues;\n          }\n          if (info?.abortEarly) {\n            break;\n          }\n        } else {\n          output.push(result.output);\n        }\n      }\n      return issues ? getIssues(issues) : executePipe(output, this.pipe, info, \"array\");\n    }\n  };\n}\n\n// src/schemas/array/arrayAsync.ts\nfunction arrayAsync(item, arg2, arg3) {\n  const [message = \"Invalid type\", pipe] = getDefaultArgs(arg2, arg3);\n  return {\n    type: \"array\",\n    async: true,\n    item,\n    message,\n    pipe,\n    async _parse(input, info) {\n      if (!Array.isArray(input)) {\n        return getSchemaIssues(info, \"type\", \"array\", this.message, input);\n      }\n      let issues;\n      const output = [];\n      await Promise.all(\n        input.map(async (value2, key) => {\n          if (!(info?.abortEarly && issues)) {\n            const result = await this.item._parse(value2, info);\n            if (!(info?.abortEarly && issues)) {\n              if (result.issues) {\n                const pathItem = {\n                  type: \"array\",\n                  input,\n                  key,\n                  value: value2\n                };\n                for (const issue of result.issues) {\n                  if (issue.path) {\n                    issue.path.unshift(pathItem);\n                  } else {\n                    issue.path = [pathItem];\n                  }\n                  issues?.push(issue);\n                }\n                if (!issues) {\n                  issues = result.issues;\n                }\n                if (info?.abortEarly) {\n                  throw null;\n                }\n              } else {\n                output[key] = result.output;\n              }\n            }\n          }\n        })\n      ).catch(() => null);\n      return issues ? getIssues(issues) : executePipeAsync(output, this.pipe, info, \"array\");\n    }\n  };\n}\n\n// src/schemas/bigint/bigint.ts\nfunction bigint(arg1, arg2) {\n  const [message = \"Invalid type\", pipe] = getDefaultArgs(arg1, arg2);\n  return {\n    type: \"bigint\",\n    async: false,\n    message,\n    pipe,\n    _parse(input, info) {\n      if (typeof input !== \"bigint\") {\n        return getSchemaIssues(info, \"type\", \"bigint\", this.message, input);\n      }\n      return executePipe(input, this.pipe, info, \"bigint\");\n    }\n  };\n}\n\n// src/schemas/bigint/bigintAsync.ts\nfunction bigintAsync(arg1, arg2) {\n  const [message = \"Invalid type\", pipe] = getDefaultArgs(arg1, arg2);\n  return {\n    type: \"bigint\",\n    async: true,\n    message,\n    pipe,\n    async _parse(input, info) {\n      if (typeof input !== \"bigint\") {\n        return getSchemaIssues(info, \"type\", \"bigint\", this.message, input);\n      }\n      return executePipeAsync(input, this.pipe, info, \"bigint\");\n    }\n  };\n}\n\n// src/schemas/blob/blob.ts\nfunction blob(arg1, arg2) {\n  const [message = \"Invalid type\", pipe] = getDefaultArgs(arg1, arg2);\n  return {\n    type: \"blob\",\n    async: false,\n    message,\n    pipe,\n    _parse(input, info) {\n      if (!(input instanceof Blob)) {\n        return getSchemaIssues(info, \"type\", \"blob\", this.message, input);\n      }\n      return executePipe(input, this.pipe, info, \"blob\");\n    }\n  };\n}\n\n// src/schemas/blob/blobAsync.ts\nfunction blobAsync(arg1, arg2) {\n  const [message = \"Invalid type\", pipe] = getDefaultArgs(arg1, arg2);\n  return {\n    type: \"blob\",\n    async: true,\n    message,\n    pipe,\n    async _parse(input, info) {\n      if (!(input instanceof Blob)) {\n        return getSchemaIssues(info, \"type\", \"blob\", this.message, input);\n      }\n      return executePipeAsync(input, this.pipe, info, \"blob\");\n    }\n  };\n}\n\n// src/schemas/boolean/boolean.ts\nfunction boolean(arg1, arg2) {\n  const [message = \"Invalid type\", pipe] = getDefaultArgs(arg1, arg2);\n  return {\n    type: \"boolean\",\n    async: false,\n    message,\n    pipe,\n    _parse(input, info) {\n      if (typeof input !== \"boolean\") {\n        return getSchemaIssues(info, \"type\", \"boolean\", this.message, input);\n      }\n      return executePipe(input, this.pipe, info, \"boolean\");\n    }\n  };\n}\n\n// src/schemas/boolean/booleanAsync.ts\nfunction booleanAsync(arg1, arg2) {\n  const [message = \"Invalid type\", pipe] = getDefaultArgs(arg1, arg2);\n  return {\n    type: \"boolean\",\n    async: true,\n    message,\n    pipe,\n    async _parse(input, info) {\n      if (typeof input !== \"boolean\") {\n        return getSchemaIssues(info, \"type\", \"boolean\", this.message, input);\n      }\n      return executePipeAsync(input, this.pipe, info, \"boolean\");\n    }\n  };\n}\n\n// src/schemas/date/date.ts\nfunction date(arg1, arg2) {\n  const [message = \"Invalid type\", pipe] = getDefaultArgs(arg1, arg2);\n  return {\n    type: \"date\",\n    async: false,\n    message,\n    pipe,\n    _parse(input, info) {\n      if (!(input instanceof Date) || isNaN(input.getTime())) {\n        return getSchemaIssues(info, \"type\", \"date\", this.message, input);\n      }\n      return executePipe(input, this.pipe, info, \"date\");\n    }\n  };\n}\n\n// src/schemas/date/dateAsync.ts\nfunction dateAsync(arg1, arg2) {\n  const [message = \"Invalid type\", pipe] = getDefaultArgs(arg1, arg2);\n  return {\n    type: \"date\",\n    async: true,\n    message,\n    pipe,\n    async _parse(input, info) {\n      if (!(input instanceof Date) || isNaN(input.getTime())) {\n        return getSchemaIssues(info, \"type\", \"date\", this.message, input);\n      }\n      return executePipeAsync(input, this.pipe, info, \"date\");\n    }\n  };\n}\n\n// src/schemas/enum/enum.ts\nfunction enum_(enum_2, message = \"Invalid type\") {\n  return {\n    type: \"enum\",\n    async: false,\n    enum: enum_2,\n    message,\n    _parse(input, info) {\n      if (!Object.values(this.enum).includes(input)) {\n        return getSchemaIssues(info, \"type\", \"enum\", this.message, input);\n      }\n      return getOutput(input);\n    }\n  };\n}\nvar nativeEnum = enum_;\n\n// src/schemas/enum/enumAsync.ts\nfunction enumAsync(enum_2, message = \"Invalid type\") {\n  return {\n    type: \"enum\",\n    async: true,\n    enum: enum_2,\n    message,\n    async _parse(input, info) {\n      if (!Object.values(this.enum).includes(input)) {\n        return getSchemaIssues(info, \"type\", \"enum\", this.message, input);\n      }\n      return getOutput(input);\n    }\n  };\n}\nvar nativeEnumAsync = enumAsync;\n\n// src/schemas/instance/instance.ts\nfunction instance(class_, arg2, arg3) {\n  const [message = \"Invalid type\", pipe] = getDefaultArgs(arg2, arg3);\n  return {\n    type: \"instance\",\n    async: false,\n    class: class_,\n    message,\n    pipe,\n    _parse(input, info) {\n      if (!(input instanceof this.class)) {\n        return getSchemaIssues(info, \"type\", \"instance\", this.message, input);\n      }\n      return executePipe(input, this.pipe, info, \"instance\");\n    }\n  };\n}\n\n// src/schemas/instance/instanceAsync.ts\nfunction instanceAsync(class_, arg2, arg3) {\n  const [message = \"Invalid type\", pipe] = getDefaultArgs(arg2, arg3);\n  return {\n    type: \"instance\",\n    async: true,\n    class: class_,\n    message,\n    pipe,\n    async _parse(input, info) {\n      if (!(input instanceof this.class)) {\n        return getSchemaIssues(info, \"type\", \"instance\", this.message, input);\n      }\n      return executePipeAsync(input, this.pipe, info, \"instance\");\n    }\n  };\n}\n\n// src/schemas/intersect/utils/mergeOutputs/mergeOutputs.ts\nfunction mergeOutputs(output1, output2) {\n  if (typeof output1 === typeof output2) {\n    if (output1 === output2 || output1 instanceof Date && output2 instanceof Date && +output1 === +output2) {\n      return getOutput(output1);\n    }\n    if (Array.isArray(output1) && Array.isArray(output2)) {\n      if (output1.length === output2.length) {\n        const array2 = [];\n        for (let index = 0; index < output1.length; index++) {\n          const result = mergeOutputs(output1[index], output2[index]);\n          if (result.invalid) {\n            return result;\n          }\n          array2.push(result.output);\n        }\n        return getOutput(array2);\n      }\n      return { invalid: true };\n    }\n    if (output1 && output2 && output1.constructor === Object && output2.constructor === Object) {\n      const object2 = { ...output1, ...output2 };\n      for (const key in output1) {\n        if (key in output2) {\n          const result = mergeOutputs(output1[key], output2[key]);\n          if (result.invalid) {\n            return result;\n          }\n          object2[key] = result.output;\n        }\n      }\n      return getOutput(object2);\n    }\n  }\n  return { invalid: true };\n}\n\n// src/schemas/intersect/intersect.ts\nfunction intersect(options, message = \"Invalid type\") {\n  return {\n    type: \"intersect\",\n    async: false,\n    options,\n    message,\n    _parse(input, info) {\n      let issues;\n      let outputs;\n      for (const schema of this.options) {\n        const result = schema._parse(input, info);\n        if (result.issues) {\n          if (issues) {\n            for (const issue of result.issues) {\n              issues.push(issue);\n            }\n          } else {\n            issues = result.issues;\n          }\n          if (info?.abortEarly) {\n            break;\n          }\n        } else {\n          if (outputs) {\n            outputs.push(result.output);\n          } else {\n            outputs = [result.output];\n          }\n        }\n      }\n      if (issues) {\n        return getIssues(issues);\n      }\n      let output = outputs[0];\n      for (let index = 1; index < outputs.length; index++) {\n        const result = mergeOutputs(output, outputs[index]);\n        if (result.invalid) {\n          return getSchemaIssues(\n            info,\n            \"type\",\n            \"intersect\",\n            this.message,\n            input\n          );\n        }\n        output = result.output;\n      }\n      return getOutput(output);\n    }\n  };\n}\nvar intersection = intersect;\n\n// src/schemas/literal/literal.ts\nfunction literal(literal2, message = \"Invalid type\") {\n  return {\n    type: \"literal\",\n    async: false,\n    literal: literal2,\n    message,\n    _parse(input, info) {\n      if (input !== this.literal) {\n        return getSchemaIssues(info, \"type\", \"literal\", this.message, input);\n      }\n      return getOutput(input);\n    }\n  };\n}\n\n// src/schemas/literal/literalAsync.ts\nfunction literalAsync(literal2, message = \"Invalid type\") {\n  return {\n    type: \"literal\",\n    async: true,\n    literal: literal2,\n    message,\n    async _parse(input, info) {\n      if (input !== this.literal) {\n        return getSchemaIssues(info, \"type\", \"literal\", this.message, input);\n      }\n      return getOutput(input);\n    }\n  };\n}\n\n// src/schemas/map/map.ts\nfunction map(key, value2, arg3, arg4) {\n  const [message = \"Invalid type\", pipe] = getDefaultArgs(arg3, arg4);\n  return {\n    type: \"map\",\n    async: false,\n    key,\n    value: value2,\n    message,\n    pipe,\n    _parse(input, info) {\n      if (!(input instanceof Map)) {\n        return getSchemaIssues(info, \"type\", \"map\", this.message, input);\n      }\n      let issues;\n      const output = /* @__PURE__ */ new Map();\n      for (const [inputKey, inputValue] of input.entries()) {\n        let pathItem;\n        const keyResult = this.key._parse(inputKey, {\n          origin: \"key\",\n          abortEarly: info?.abortEarly,\n          abortPipeEarly: info?.abortPipeEarly,\n          skipPipe: info?.skipPipe\n        });\n        if (keyResult.issues) {\n          pathItem = {\n            type: \"map\",\n            input,\n            key: inputKey,\n            value: inputValue\n          };\n          for (const issue of keyResult.issues) {\n            if (issue.path) {\n              issue.path.unshift(pathItem);\n            } else {\n              issue.path = [pathItem];\n            }\n            issues?.push(issue);\n          }\n          if (!issues) {\n            issues = keyResult.issues;\n          }\n          if (info?.abortEarly) {\n            break;\n          }\n        }\n        const valueResult = this.value._parse(inputValue, info);\n        if (valueResult.issues) {\n          pathItem = pathItem || {\n            type: \"map\",\n            input,\n            key: inputKey,\n            value: inputValue\n          };\n          for (const issue of valueResult.issues) {\n            if (issue.path) {\n              issue.path.unshift(pathItem);\n            } else {\n              issue.path = [pathItem];\n            }\n            issues?.push(issue);\n          }\n          if (!issues) {\n            issues = valueResult.issues;\n          }\n          if (info?.abortEarly) {\n            break;\n          }\n        }\n        if (!keyResult.issues && !valueResult.issues) {\n          output.set(keyResult.output, valueResult.output);\n        }\n      }\n      return issues ? getIssues(issues) : executePipe(output, this.pipe, info, \"map\");\n    }\n  };\n}\n\n// src/schemas/map/mapAsync.ts\nfunction mapAsync(key, value2, arg3, arg4) {\n  const [message = \"Invalid type\", pipe] = getDefaultArgs(arg3, arg4);\n  return {\n    type: \"map\",\n    async: true,\n    key,\n    value: value2,\n    message,\n    pipe,\n    async _parse(input, info) {\n      if (!(input instanceof Map)) {\n        return getSchemaIssues(info, \"type\", \"map\", this.message, input);\n      }\n      const output = /* @__PURE__ */ new Map();\n      let issues;\n      await Promise.all(\n        Array.from(input.entries()).map(async ([inputKey, inputValue]) => {\n          let pathItem;\n          const [keyResult, valueResult] = await Promise.all(\n            [\n              { schema: this.key, value: inputKey, origin: \"key\" },\n              { schema: this.value, value: inputValue, origin: \"value\" }\n            ].map(async ({ schema, value: value3, origin }) => {\n              if (!(info?.abortEarly && issues)) {\n                const result = await schema._parse(value3, {\n                  origin,\n                  abortEarly: info?.abortEarly,\n                  abortPipeEarly: info?.abortPipeEarly,\n                  skipPipe: info?.skipPipe\n                });\n                if (!(info?.abortEarly && issues)) {\n                  if (result.issues) {\n                    pathItem = pathItem || {\n                      type: \"map\",\n                      input,\n                      key: inputKey,\n                      value: inputValue\n                    };\n                    for (const issue of result.issues) {\n                      if (issue.path) {\n                        issue.path.unshift(pathItem);\n                      } else {\n                        issue.path = [pathItem];\n                      }\n                      issues?.push(issue);\n                    }\n                    if (!issues) {\n                      issues = result.issues;\n                    }\n                    if (info?.abortEarly) {\n                      throw null;\n                    }\n                  } else {\n                    return result;\n                  }\n                }\n              }\n            })\n          ).catch(() => []);\n          if (keyResult && valueResult) {\n            output.set(keyResult.output, valueResult.output);\n          }\n        })\n      );\n      return issues ? getIssues(issues) : executePipeAsync(input, this.pipe, info, \"map\");\n    }\n  };\n}\n\n// src/schemas/nan/nan.ts\nfunction nan(message = \"Invalid type\") {\n  return {\n    type: \"nan\",\n    async: false,\n    message,\n    _parse(input, info) {\n      if (!Number.isNaN(input)) {\n        return getSchemaIssues(info, \"type\", \"nan\", this.message, input);\n      }\n      return getOutput(input);\n    }\n  };\n}\n\n// src/schemas/nan/nanAsync.ts\nfunction nanAsync(message = \"Invalid type\") {\n  return {\n    type: \"nan\",\n    async: true,\n    message,\n    async _parse(input, info) {\n      if (!Number.isNaN(input)) {\n        return getSchemaIssues(info, \"type\", \"nan\", this.message, input);\n      }\n      return getOutput(input);\n    }\n  };\n}\n\n// src/schemas/never/never.ts\nfunction never(message = \"Invalid type\") {\n  return {\n    type: \"never\",\n    async: false,\n    message,\n    _parse(input, info) {\n      return getSchemaIssues(info, \"type\", \"never\", this.message, input);\n    }\n  };\n}\n\n// src/schemas/never/neverAsync.ts\nfunction neverAsync(message = \"Invalid type\") {\n  return {\n    type: \"never\",\n    async: true,\n    message,\n    async _parse(input, info) {\n      return getSchemaIssues(info, \"type\", \"never\", this.message, input);\n    }\n  };\n}\n\n// src/schemas/nonNullable/nonNullable.ts\nfunction nonNullable(wrapped, message = \"Invalid type\") {\n  return {\n    type: \"non_nullable\",\n    async: false,\n    wrapped,\n    message,\n    _parse(input, info) {\n      if (input === null) {\n        return getSchemaIssues(\n          info,\n          \"type\",\n          \"non_nullable\",\n          this.message,\n          input\n        );\n      }\n      return this.wrapped._parse(input, info);\n    }\n  };\n}\n\n// src/schemas/nonNullable/nonNullableAsync.ts\nfunction nonNullableAsync(wrapped, message = \"Invalid type\") {\n  return {\n    type: \"non_nullable\",\n    async: true,\n    wrapped,\n    message,\n    async _parse(input, info) {\n      if (input === null) {\n        return getSchemaIssues(\n          info,\n          \"type\",\n          \"non_nullable\",\n          this.message,\n          input\n        );\n      }\n      return this.wrapped._parse(input, info);\n    }\n  };\n}\n\n// src/schemas/nonNullish/nonNullish.ts\nfunction nonNullish(wrapped, message = \"Invalid type\") {\n  return {\n    type: \"non_nullish\",\n    async: false,\n    wrapped,\n    message,\n    _parse(input, info) {\n      if (input === null || input === void 0) {\n        return getSchemaIssues(\n          info,\n          \"type\",\n          \"non_nullish\",\n          this.message,\n          input\n        );\n      }\n      return this.wrapped._parse(input, info);\n    }\n  };\n}\n\n// src/schemas/nonNullish/nonNullishAsync.ts\nfunction nonNullishAsync(wrapped, message = \"Invalid type\") {\n  return {\n    type: \"non_nullish\",\n    async: true,\n    wrapped,\n    message,\n    async _parse(input, info) {\n      if (input === null || input === void 0) {\n        return getSchemaIssues(\n          info,\n          \"type\",\n          \"non_nullish\",\n          this.message,\n          input\n        );\n      }\n      return this.wrapped._parse(input, info);\n    }\n  };\n}\n\n// src/schemas/nonOptional/nonOptional.ts\nfunction nonOptional(wrapped, message = \"Invalid type\") {\n  return {\n    type: \"non_optional\",\n    async: false,\n    wrapped,\n    message,\n    _parse(input, info) {\n      if (input === void 0) {\n        return getSchemaIssues(\n          info,\n          \"type\",\n          \"non_optional\",\n          this.message,\n          input\n        );\n      }\n      return this.wrapped._parse(input, info);\n    }\n  };\n}\n\n// src/schemas/nonOptional/nonOptionalAsync.ts\nfunction nonOptionalAsync(wrapped, message = \"Invalid type\") {\n  return {\n    type: \"non_optional\",\n    async: true,\n    wrapped,\n    message,\n    async _parse(input, info) {\n      if (input === void 0) {\n        return getSchemaIssues(\n          info,\n          \"type\",\n          \"non_optional\",\n          this.message,\n          input\n        );\n      }\n      return this.wrapped._parse(input, info);\n    }\n  };\n}\n\n// src/schemas/nullable/nullable.ts\nfunction nullable(wrapped, default_) {\n  return {\n    type: \"nullable\",\n    async: false,\n    wrapped,\n    default: default_,\n    _parse(input, info) {\n      if (input === null) {\n        const override = getDefault(this);\n        if (override === void 0) {\n          return getOutput(input);\n        }\n        input = override;\n      }\n      return this.wrapped._parse(input, info);\n    }\n  };\n}\n\n// src/schemas/nullable/nullableAsync.ts\nfunction nullableAsync(wrapped, default_) {\n  return {\n    type: \"nullable\",\n    async: true,\n    wrapped,\n    default: default_,\n    async _parse(input, info) {\n      if (input === null) {\n        const override = await getDefaultAsync(this);\n        if (override === void 0) {\n          return getOutput(input);\n        }\n        input = override;\n      }\n      return this.wrapped._parse(input, info);\n    }\n  };\n}\n\n// src/schemas/nullish/nullish.ts\nfunction nullish(wrapped, default_) {\n  return {\n    type: \"nullish\",\n    async: false,\n    wrapped,\n    default: default_,\n    _parse(input, info) {\n      if (input === null || input === void 0) {\n        const override = getDefault(this);\n        if (override === void 0) {\n          return getOutput(input);\n        }\n        input = override;\n      }\n      return this.wrapped._parse(input, info);\n    }\n  };\n}\n\n// src/schemas/nullish/nullishAsync.ts\nfunction nullishAsync(wrapped, default_) {\n  return {\n    type: \"nullish\",\n    async: true,\n    wrapped,\n    default: default_,\n    async _parse(input, info) {\n      if (input === null || input === void 0) {\n        const override = await getDefaultAsync(this);\n        if (override === void 0) {\n          return getOutput(input);\n        }\n        input = override;\n      }\n      return this.wrapped._parse(input, info);\n    }\n  };\n}\n\n// src/schemas/null/null.ts\nfunction null_(message = \"Invalid type\") {\n  return {\n    type: \"null\",\n    async: false,\n    message,\n    _parse(input, info) {\n      if (input !== null) {\n        return getSchemaIssues(info, \"type\", \"null\", this.message, input);\n      }\n      return getOutput(input);\n    }\n  };\n}\nvar nullType = null_;\n\n// src/schemas/null/nullAsync.ts\nfunction nullAsync(message = \"Invalid type\") {\n  return {\n    type: \"null\",\n    async: true,\n    message,\n    async _parse(input, info) {\n      if (input !== null) {\n        return getSchemaIssues(info, \"type\", \"null\", this.message, input);\n      }\n      return getOutput(input);\n    }\n  };\n}\nvar nullTypeAsync = nullAsync;\n\n// src/schemas/number/number.ts\nfunction number(arg1, arg2) {\n  const [message = \"Invalid type\", pipe] = getDefaultArgs(arg1, arg2);\n  return {\n    type: \"number\",\n    async: false,\n    message,\n    pipe,\n    _parse(input, info) {\n      if (typeof input !== \"number\" || isNaN(input)) {\n        return getSchemaIssues(info, \"type\", \"number\", this.message, input);\n      }\n      return executePipe(input, this.pipe, info, \"number\");\n    }\n  };\n}\n\n// src/schemas/number/numberAsync.ts\nfunction numberAsync(arg1, arg2) {\n  const [message = \"Invalid type\", pipe] = getDefaultArgs(arg1, arg2);\n  return {\n    type: \"number\",\n    async: true,\n    message,\n    pipe,\n    async _parse(input, info) {\n      if (typeof input !== \"number\" || isNaN(input)) {\n        return getSchemaIssues(info, \"type\", \"number\", this.message, input);\n      }\n      return executePipeAsync(input, this.pipe, info, \"number\");\n    }\n  };\n}\n\n// src/schemas/object/object.ts\nfunction object(entries, arg2, arg3, arg4) {\n  const [rest, message = \"Invalid type\", pipe] = getRestAndDefaultArgs(arg2, arg3, arg4);\n  let cachedEntries;\n  return {\n    type: \"object\",\n    async: false,\n    entries,\n    rest,\n    message,\n    pipe,\n    _parse(input, info) {\n      if (!input || typeof input !== \"object\") {\n        return getSchemaIssues(info, \"type\", \"object\", this.message, input);\n      }\n      cachedEntries = cachedEntries || Object.entries(this.entries);\n      let issues;\n      const output = {};\n      for (const [key, schema] of cachedEntries) {\n        const value2 = input[key];\n        const result = schema._parse(value2, info);\n        if (result.issues) {\n          const pathItem = {\n            type: \"object\",\n            input,\n            key,\n            value: value2\n          };\n          for (const issue of result.issues) {\n            if (issue.path) {\n              issue.path.unshift(pathItem);\n            } else {\n              issue.path = [pathItem];\n            }\n            issues?.push(issue);\n          }\n          if (!issues) {\n            issues = result.issues;\n          }\n          if (info?.abortEarly) {\n            break;\n          }\n        } else if (result.output !== void 0 || key in input) {\n          output[key] = result.output;\n        }\n      }\n      if (this.rest && !(info?.abortEarly && issues)) {\n        for (const key in input) {\n          if (!(key in this.entries)) {\n            const value2 = input[key];\n            const result = this.rest._parse(value2, info);\n            if (result.issues) {\n              const pathItem = {\n                type: \"object\",\n                input,\n                key,\n                value: value2\n              };\n              for (const issue of result.issues) {\n                if (issue.path) {\n                  issue.path.unshift(pathItem);\n                } else {\n                  issue.path = [pathItem];\n                }\n                issues?.push(issue);\n              }\n              if (!issues) {\n                issues = result.issues;\n              }\n              if (info?.abortEarly) {\n                break;\n              }\n            } else {\n              output[key] = result.output;\n            }\n          }\n        }\n      }\n      return issues ? getIssues(issues) : executePipe(\n        output,\n        this.pipe,\n        info,\n        \"object\"\n      );\n    }\n  };\n}\n\n// src/schemas/object/objectAsync.ts\nfunction objectAsync(entries, arg2, arg3, arg4) {\n  const [rest, message = \"Invalid type\", pipe] = getRestAndDefaultArgs(arg2, arg3, arg4);\n  let cachedEntries;\n  return {\n    type: \"object\",\n    async: true,\n    entries,\n    rest,\n    message,\n    pipe,\n    async _parse(input, info) {\n      if (!input || typeof input !== \"object\") {\n        return getSchemaIssues(info, \"type\", \"object\", this.message, input);\n      }\n      cachedEntries = cachedEntries || Object.entries(this.entries);\n      let issues;\n      const output = {};\n      await Promise.all([\n        Promise.all(\n          cachedEntries.map(async ([key, schema]) => {\n            if (!(info?.abortEarly && issues)) {\n              const value2 = input[key];\n              const result = await schema._parse(value2, info);\n              if (!(info?.abortEarly && issues)) {\n                if (result.issues) {\n                  const pathItem = {\n                    type: \"object\",\n                    input,\n                    key,\n                    value: value2\n                  };\n                  for (const issue of result.issues) {\n                    if (issue.path) {\n                      issue.path.unshift(pathItem);\n                    } else {\n                      issue.path = [pathItem];\n                    }\n                    issues?.push(issue);\n                  }\n                  if (!issues) {\n                    issues = result.issues;\n                  }\n                  if (info?.abortEarly) {\n                    throw null;\n                  }\n                } else if (result.output !== void 0 || key in input) {\n                  output[key] = result.output;\n                }\n              }\n            }\n          })\n        ),\n        this.rest && Promise.all(\n          Object.entries(input).map(async ([key, value2]) => {\n            if (!(info?.abortEarly && issues)) {\n              if (!(key in this.entries)) {\n                const result = await this.rest._parse(value2, info);\n                if (!(info?.abortEarly && issues)) {\n                  if (result.issues) {\n                    const pathItem = {\n                      type: \"object\",\n                      input,\n                      key,\n                      value: value2\n                    };\n                    for (const issue of result.issues) {\n                      if (issue.path) {\n                        issue.path.unshift(pathItem);\n                      } else {\n                        issue.path = [pathItem];\n                      }\n                      issues?.push(issue);\n                    }\n                    if (!issues) {\n                      issues = result.issues;\n                    }\n                    if (info?.abortEarly) {\n                      throw null;\n                    }\n                  } else {\n                    output[key] = result.output;\n                  }\n                }\n              }\n            }\n          })\n        )\n      ]).catch(() => null);\n      return issues ? getIssues(issues) : executePipeAsync(\n        output,\n        this.pipe,\n        info,\n        \"object\"\n      );\n    }\n  };\n}\n\n// src/schemas/optional/optional.ts\nfunction optional(wrapped, default_) {\n  return {\n    type: \"optional\",\n    async: false,\n    wrapped,\n    default: default_,\n    _parse(input, info) {\n      if (input === void 0) {\n        const override = getDefault(this);\n        if (override === void 0) {\n          return getOutput(input);\n        }\n        input = override;\n      }\n      return this.wrapped._parse(input, info);\n    }\n  };\n}\n\n// src/schemas/optional/optionalAsync.ts\nfunction optionalAsync(wrapped, default_) {\n  return {\n    type: \"optional\",\n    async: true,\n    wrapped,\n    default: default_,\n    async _parse(input, info) {\n      if (input === void 0) {\n        const override = await getDefaultAsync(this);\n        if (override === void 0) {\n          return getOutput(input);\n        }\n        input = override;\n      }\n      return this.wrapped._parse(input, info);\n    }\n  };\n}\n\n// src/schemas/picklist/picklist.ts\nfunction picklist(options, message = \"Invalid type\") {\n  return {\n    type: \"picklist\",\n    async: false,\n    options,\n    message,\n    _parse(input, info) {\n      if (!this.options.includes(input)) {\n        return getSchemaIssues(info, \"type\", \"picklist\", this.message, input);\n      }\n      return getOutput(input);\n    }\n  };\n}\nvar enumType = picklist;\n\n// src/schemas/picklist/picklistAsync.ts\nfunction picklistAsync(options, message = \"Invalid type\") {\n  return {\n    type: \"picklist\",\n    async: true,\n    options,\n    message,\n    async _parse(input, info) {\n      if (!this.options.includes(input)) {\n        return getSchemaIssues(info, \"type\", \"picklist\", this.message, input);\n      }\n      return getOutput(input);\n    }\n  };\n}\nvar enumTypeAsync = picklistAsync;\n\n// src/schemas/string/string.ts\nfunction string(arg1, arg2) {\n  const [message = \"Invalid type\", pipe] = getDefaultArgs(arg1, arg2);\n  return {\n    type: \"string\",\n    async: false,\n    message,\n    pipe,\n    _parse(input, info) {\n      if (typeof input !== \"string\") {\n        return getSchemaIssues(info, \"type\", \"string\", this.message, input);\n      }\n      return executePipe(input, this.pipe, info, \"string\");\n    }\n  };\n}\n\n// src/schemas/string/stringAsync.ts\nfunction stringAsync(arg1, arg2) {\n  const [message = \"Invalid type\", pipe] = getDefaultArgs(arg1, arg2);\n  return {\n    type: \"string\",\n    async: true,\n    message,\n    pipe,\n    async _parse(input, info) {\n      if (typeof input !== \"string\") {\n        return getSchemaIssues(info, \"type\", \"string\", this.message, input);\n      }\n      return executePipeAsync(input, this.pipe, info, \"string\");\n    }\n  };\n}\n\n// src/schemas/record/utils/getRecordArgs/getRecordArgs.ts\nfunction getRecordArgs(arg1, arg2, arg3, arg4) {\n  if (typeof arg2 === \"object\" && !Array.isArray(arg2)) {\n    const [message2, pipe2] = getDefaultArgs(arg3, arg4);\n    return [arg1, arg2, message2, pipe2];\n  }\n  const [message, pipe] = getDefaultArgs(\n    arg2,\n    arg3\n  );\n  return [string(), arg1, message, pipe];\n}\n\n// src/schemas/record/values.ts\nvar BLOCKED_KEYS = [\"__proto__\", \"prototype\", \"constructor\"];\n\n// src/schemas/record/record.ts\nfunction record(arg1, arg2, arg3, arg4) {\n  const [key, value2, message = \"Invalid type\", pipe] = getRecordArgs(arg1, arg2, arg3, arg4);\n  return {\n    type: \"record\",\n    async: false,\n    key,\n    value: value2,\n    message,\n    pipe,\n    _parse(input, info) {\n      if (!input || typeof input !== \"object\") {\n        return getSchemaIssues(info, \"type\", \"record\", this.message, input);\n      }\n      let issues;\n      const output = {};\n      for (const [inputKey, inputValue] of Object.entries(input)) {\n        if (!BLOCKED_KEYS.includes(inputKey)) {\n          let pathItem;\n          const keyResult = this.key._parse(inputKey, {\n            origin: \"key\",\n            abortEarly: info?.abortEarly,\n            abortPipeEarly: info?.abortPipeEarly,\n            skipPipe: info?.skipPipe\n          });\n          if (keyResult.issues) {\n            pathItem = {\n              type: \"record\",\n              input,\n              key: inputKey,\n              value: inputValue\n            };\n            for (const issue of keyResult.issues) {\n              issue.path = [pathItem];\n              issues?.push(issue);\n            }\n            if (!issues) {\n              issues = keyResult.issues;\n            }\n            if (info?.abortEarly) {\n              break;\n            }\n          }\n          const valueResult = this.value._parse(inputValue, info);\n          if (valueResult.issues) {\n            pathItem = pathItem || {\n              type: \"record\",\n              input,\n              key: inputKey,\n              value: inputValue\n            };\n            for (const issue of valueResult.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              issues?.push(issue);\n            }\n            if (!issues) {\n              issues = valueResult.issues;\n            }\n            if (info?.abortEarly) {\n              break;\n            }\n          }\n          if (!keyResult.issues && !valueResult.issues) {\n            output[keyResult.output] = valueResult.output;\n          }\n        }\n      }\n      return issues ? getIssues(issues) : executePipe(\n        output,\n        this.pipe,\n        info,\n        \"record\"\n      );\n    }\n  };\n}\n\n// src/schemas/record/recordAsync.ts\nfunction recordAsync(arg1, arg2, arg3, arg4) {\n  const [key, value2, message = \"Invalid type\", pipe] = getRecordArgs(arg1, arg2, arg3, arg4);\n  return {\n    type: \"record\",\n    async: true,\n    key,\n    value: value2,\n    message,\n    pipe,\n    async _parse(input, info) {\n      if (!input || typeof input !== \"object\") {\n        return getSchemaIssues(info, \"type\", \"record\", this.message, input);\n      }\n      let issues;\n      const output = {};\n      await Promise.all(\n        // Note: `Object.entries(...)` converts each key to a string\n        Object.entries(input).map(async ([inputKey, inputValue]) => {\n          if (!BLOCKED_KEYS.includes(inputKey)) {\n            let pathItem;\n            const [keyResult, valueResult] = await Promise.all(\n              [\n                { schema: this.key, value: inputKey, origin: \"key\" },\n                { schema: this.value, value: inputValue, origin: \"value\" }\n              ].map(async ({ schema, value: value3, origin }) => {\n                if (!(info?.abortEarly && issues)) {\n                  const result = await schema._parse(value3, {\n                    origin,\n                    abortEarly: info?.abortEarly,\n                    abortPipeEarly: info?.abortPipeEarly,\n                    skipPipe: info?.skipPipe\n                  });\n                  if (!(info?.abortEarly && issues)) {\n                    if (result.issues) {\n                      pathItem = pathItem || {\n                        type: \"record\",\n                        input,\n                        key: inputKey,\n                        value: inputValue\n                      };\n                      for (const issue of result.issues) {\n                        if (issue.path) {\n                          issue.path.unshift(pathItem);\n                        } else {\n                          issue.path = [pathItem];\n                        }\n                        issues?.push(issue);\n                      }\n                      if (!issues) {\n                        issues = result.issues;\n                      }\n                      if (info?.abortEarly) {\n                        throw null;\n                      }\n                    } else {\n                      return result;\n                    }\n                  }\n                }\n              })\n            ).catch(() => []);\n            if (keyResult && valueResult) {\n              output[keyResult.output] = valueResult.output;\n            }\n          }\n        })\n      );\n      return issues ? getIssues(issues) : executePipeAsync(\n        output,\n        this.pipe,\n        info,\n        \"record\"\n      );\n    }\n  };\n}\n\n// src/schemas/recursive/recursive.ts\nfunction recursive(getter) {\n  return {\n    type: \"recursive\",\n    async: false,\n    getter,\n    _parse(input, info) {\n      return this.getter()._parse(input, info);\n    }\n  };\n}\n\n// src/schemas/recursive/recursiveAsync.ts\nfunction recursiveAsync(getter) {\n  return {\n    type: \"recursive\",\n    async: true,\n    getter,\n    async _parse(input, info) {\n      return this.getter()._parse(input, info);\n    }\n  };\n}\n\n// src/schemas/set/set.ts\nfunction set(value2, arg2, arg3) {\n  const [message = \"Invalid type\", pipe] = getDefaultArgs(arg2, arg3);\n  return {\n    type: \"set\",\n    async: false,\n    value: value2,\n    message,\n    pipe,\n    _parse(input, info) {\n      if (!(input instanceof Set)) {\n        return getSchemaIssues(info, \"type\", \"set\", this.message, input);\n      }\n      let key = 0;\n      let issues;\n      const output = /* @__PURE__ */ new Set();\n      for (const inputValue of input) {\n        const result = this.value._parse(inputValue, info);\n        if (result.issues) {\n          const pathItem = {\n            type: \"set\",\n            input,\n            key,\n            value: inputValue\n          };\n          for (const issue of result.issues) {\n            if (issue.path) {\n              issue.path.unshift(pathItem);\n            } else {\n              issue.path = [pathItem];\n            }\n            issues?.push(issue);\n          }\n          if (!issues) {\n            issues = result.issues;\n          }\n          if (info?.abortEarly) {\n            break;\n          }\n        } else {\n          output.add(result.output);\n        }\n        key++;\n      }\n      return issues ? getIssues(issues) : executePipe(output, this.pipe, info, \"set\");\n    }\n  };\n}\n\n// src/schemas/set/setAsync.ts\nfunction setAsync(value2, arg2, arg3) {\n  const [message = \"Invalid type\", pipe] = getDefaultArgs(arg2, arg3);\n  return {\n    type: \"set\",\n    async: true,\n    value: value2,\n    message,\n    pipe,\n    async _parse(input, info) {\n      if (!(input instanceof Set)) {\n        return getSchemaIssues(info, \"type\", \"set\", this.message, input);\n      }\n      let issues;\n      const output = /* @__PURE__ */ new Set();\n      await Promise.all(\n        Array.from(input.values()).map(async (inputValue, key) => {\n          if (!(info?.abortEarly && issues)) {\n            const result = await this.value._parse(inputValue, info);\n            if (!(info?.abortEarly && issues)) {\n              if (result.issues) {\n                const pathItem = {\n                  type: \"set\",\n                  input,\n                  key,\n                  value: inputValue\n                };\n                for (const issue of result.issues) {\n                  if (issue.path) {\n                    issue.path.unshift(pathItem);\n                  } else {\n                    issue.path = [pathItem];\n                  }\n                  issues?.push(issue);\n                }\n                if (!issues) {\n                  issues = result.issues;\n                }\n                if (info?.abortEarly) {\n                  throw null;\n                }\n              } else {\n                output.add(result.output);\n              }\n            }\n          }\n        })\n      ).catch(() => null);\n      return issues ? getIssues(issues) : executePipeAsync(input, this.pipe, info, \"set\");\n    }\n  };\n}\n\n// src/schemas/special/special.ts\nfunction special(check, arg2, arg3) {\n  const [message = \"Invalid type\", pipe] = getDefaultArgs(arg2, arg3);\n  return {\n    type: \"special\",\n    async: false,\n    check,\n    message,\n    pipe,\n    _parse(input, info) {\n      if (!this.check(input)) {\n        return getSchemaIssues(info, \"type\", \"special\", this.message, input);\n      }\n      return executePipe(input, this.pipe, info, \"special\");\n    }\n  };\n}\n\n// src/schemas/special/specialAsync.ts\nfunction specialAsync(check, arg2, arg3) {\n  const [message = \"Invalid type\", pipe] = getDefaultArgs(arg2, arg3);\n  return {\n    type: \"special\",\n    async: true,\n    check,\n    message,\n    pipe,\n    async _parse(input, info) {\n      if (!await this.check(input)) {\n        return getSchemaIssues(info, \"type\", \"special\", this.message, input);\n      }\n      return executePipeAsync(input, this.pipe, info, \"special\");\n    }\n  };\n}\n\n// src/schemas/symbol/symbol.ts\nfunction symbol(message = \"Invalid type\") {\n  return {\n    type: \"symbol\",\n    async: false,\n    message,\n    _parse(input, info) {\n      if (typeof input !== \"symbol\") {\n        return getSchemaIssues(info, \"type\", \"symbol\", this.message, input);\n      }\n      return getOutput(input);\n    }\n  };\n}\n\n// src/schemas/symbol/symbolAsync.ts\nfunction symbolAsync(message = \"Invalid type\") {\n  return {\n    type: \"symbol\",\n    async: true,\n    message,\n    async _parse(input, info) {\n      if (typeof input !== \"symbol\") {\n        return getSchemaIssues(info, \"type\", \"symbol\", this.message, input);\n      }\n      return getOutput(input);\n    }\n  };\n}\n\n// src/schemas/tuple/tuple.ts\nfunction tuple(items, arg2, arg3, arg4) {\n  const [rest, message = \"Invalid type\", pipe] = getRestAndDefaultArgs(arg2, arg3, arg4);\n  return {\n    type: \"tuple\",\n    async: false,\n    items,\n    rest,\n    message,\n    pipe,\n    _parse(input, info) {\n      if (!Array.isArray(input) || this.items.length > input.length) {\n        return getSchemaIssues(info, \"type\", \"tuple\", this.message, input);\n      }\n      let issues;\n      const output = [];\n      for (let key = 0; key < this.items.length; key++) {\n        const value2 = input[key];\n        const result = this.items[key]._parse(value2, info);\n        if (result.issues) {\n          const pathItem = {\n            type: \"tuple\",\n            input,\n            key,\n            value: value2\n          };\n          for (const issue of result.issues) {\n            if (issue.path) {\n              issue.path.unshift(pathItem);\n            } else {\n              issue.path = [pathItem];\n            }\n            issues?.push(issue);\n          }\n          if (!issues) {\n            issues = result.issues;\n          }\n          if (info?.abortEarly) {\n            break;\n          }\n        } else {\n          output[key] = result.output;\n        }\n      }\n      if (this.rest && !(info?.abortEarly && issues)) {\n        for (let key = this.items.length; key < input.length; key++) {\n          const value2 = input[key];\n          const result = this.rest._parse(value2, info);\n          if (result.issues) {\n            const pathItem = {\n              type: \"tuple\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of result.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              issues?.push(issue);\n            }\n            if (!issues) {\n              issues = result.issues;\n            }\n            if (info?.abortEarly) {\n              break;\n            }\n          } else {\n            output[key] = result.output;\n          }\n        }\n      }\n      return issues ? getIssues(issues) : executePipe(\n        output,\n        this.pipe,\n        info,\n        \"tuple\"\n      );\n    }\n  };\n}\n\n// src/schemas/tuple/tupleAsync.ts\nfunction tupleAsync(items, arg2, arg3, arg4) {\n  const [rest, message = \"Invalid type\", pipe] = getRestAndDefaultArgs(arg2, arg3, arg4);\n  return {\n    type: \"tuple\",\n    async: true,\n    items,\n    rest,\n    message,\n    pipe,\n    async _parse(input, info) {\n      if (!Array.isArray(input) || this.items.length > input.length) {\n        return getSchemaIssues(info, \"type\", \"tuple\", this.message, input);\n      }\n      let issues;\n      const output = [];\n      await Promise.all([\n        // Parse schema of each tuple item\n        Promise.all(\n          this.items.map(async (schema, key) => {\n            if (!(info?.abortEarly && issues)) {\n              const value2 = input[key];\n              const result = await schema._parse(value2, info);\n              if (!(info?.abortEarly && issues)) {\n                if (result.issues) {\n                  const pathItem = {\n                    type: \"tuple\",\n                    input,\n                    key,\n                    value: value2\n                  };\n                  for (const issue of result.issues) {\n                    if (issue.path) {\n                      issue.path.unshift(pathItem);\n                    } else {\n                      issue.path = [pathItem];\n                    }\n                    issues?.push(issue);\n                  }\n                  if (!issues) {\n                    issues = result.issues;\n                  }\n                  if (info?.abortEarly) {\n                    throw null;\n                  }\n                } else {\n                  output[key] = result.output;\n                }\n              }\n            }\n          })\n        ),\n        // If necessary parse schema of each rest item\n        this.rest && Promise.all(\n          input.slice(this.items.length).map(async (value2, index) => {\n            if (!(info?.abortEarly && issues)) {\n              const key = this.items.length + index;\n              const result = await this.rest._parse(value2, info);\n              if (!(info?.abortEarly && issues)) {\n                if (result.issues) {\n                  const pathItem = {\n                    type: \"tuple\",\n                    input,\n                    key,\n                    value: value2\n                  };\n                  for (const issue of result.issues) {\n                    if (issue.path) {\n                      issue.path.unshift(pathItem);\n                    } else {\n                      issue.path = [pathItem];\n                    }\n                    issues?.push(issue);\n                  }\n                  if (!issues) {\n                    issues = result.issues;\n                  }\n                  if (info?.abortEarly) {\n                    throw null;\n                  }\n                } else {\n                  output[key] = result.output;\n                }\n              }\n            }\n          })\n        )\n      ]).catch(() => null);\n      return issues ? getIssues(issues) : executePipeAsync(\n        output,\n        this.pipe,\n        info,\n        \"tuple\"\n      );\n    }\n  };\n}\n\n// src/schemas/undefined/undefined.ts\nfunction undefined_(message = \"Invalid type\") {\n  return {\n    type: \"undefined\",\n    async: false,\n    message,\n    _parse(input, info) {\n      if (typeof input !== \"undefined\") {\n        return getSchemaIssues(info, \"type\", \"undefined\", this.message, input);\n      }\n      return getOutput(input);\n    }\n  };\n}\nvar undefinedType = undefined_;\n\n// src/schemas/undefined/undefinedAsync.ts\nfunction undefinedAsync(message = \"Invalid type\") {\n  return {\n    type: \"undefined\",\n    async: true,\n    message,\n    async _parse(input, info) {\n      if (typeof input !== \"undefined\") {\n        return getSchemaIssues(info, \"type\", \"undefined\", this.message, input);\n      }\n      return getOutput(input);\n    }\n  };\n}\nvar undefinedTypeAsync = undefinedAsync;\n\n// src/schemas/union/union.ts\nfunction union(options, message = \"Invalid type\") {\n  return {\n    type: \"union\",\n    async: false,\n    options,\n    message,\n    _parse(input, info) {\n      let issues;\n      let output;\n      for (const schema of this.options) {\n        const result = schema._parse(input, info);\n        if (result.issues) {\n          if (issues) {\n            for (const issue of result.issues) {\n              issues.push(issue);\n            }\n          } else {\n            issues = result.issues;\n          }\n        } else {\n          output = [result.output];\n          break;\n        }\n      }\n      return output ? getOutput(output[0]) : getSchemaIssues(info, \"type\", \"union\", this.message, input, issues);\n    }\n  };\n}\n\n// src/schemas/union/unionAsync.ts\nfunction unionAsync(options, message = \"Invalid type\") {\n  return {\n    type: \"union\",\n    async: true,\n    options,\n    message,\n    async _parse(input, info) {\n      let issues;\n      let output;\n      for (const schema of this.options) {\n        const result = await schema._parse(input, info);\n        if (result.issues) {\n          if (issues) {\n            for (const issue of result.issues) {\n              issues.push(issue);\n            }\n          } else {\n            issues = result.issues;\n          }\n        } else {\n          output = [result.output];\n          break;\n        }\n      }\n      return output ? getOutput(output[0]) : getSchemaIssues(info, \"type\", \"union\", this.message, input, issues);\n    }\n  };\n}\n\n// src/schemas/unknown/unknown.ts\nfunction unknown(pipe) {\n  return {\n    type: \"unknown\",\n    async: false,\n    pipe,\n    _parse(input, info) {\n      return executePipe(input, this.pipe, info, \"unknown\");\n    }\n  };\n}\n\n// src/schemas/unknown/unknownAsync.ts\nfunction unknownAsync(pipe) {\n  return {\n    type: \"unknown\",\n    async: true,\n    pipe,\n    async _parse(input, info) {\n      return executePipeAsync(input, this.pipe, info, \"unknown\");\n    }\n  };\n}\n\n// src/schemas/variant/variant.ts\nfunction variant(key, options, message = \"Invalid type\") {\n  return {\n    type: \"variant\",\n    async: false,\n    key,\n    options,\n    message,\n    _parse(input, info) {\n      if (!input || typeof input !== \"object\" || !(this.key in input)) {\n        return getSchemaIssues(info, \"type\", \"variant\", this.message, input);\n      }\n      let issues;\n      let output;\n      const parseOptions = (options2) => {\n        for (const schema of options2) {\n          if (schema.type === \"object\") {\n            const result = schema.entries[this.key]._parse(\n              input[this.key],\n              info\n            );\n            if (!result.issues) {\n              const result2 = schema._parse(input, info);\n              if (result2.issues) {\n                issues = result2.issues;\n              } else {\n                output = [result2.output];\n              }\n              break;\n            }\n          } else if (schema.type === \"variant\") {\n            parseOptions(schema.options);\n            if (issues || output) {\n              break;\n            }\n          }\n        }\n      };\n      parseOptions(this.options);\n      return output ? getOutput(output[0]) : issues ? getIssues(issues) : getSchemaIssues(info, \"type\", \"variant\", this.message, input);\n    }\n  };\n}\nvar discriminatedUnion = variant;\n\n// src/schemas/variant/variantAsync.ts\nfunction variantAsync(key, options, message = \"Invalid type\") {\n  return {\n    type: \"variant\",\n    async: true,\n    key,\n    options,\n    message,\n    async _parse(input, info) {\n      if (!input || typeof input !== \"object\" || !(this.key in input)) {\n        return getSchemaIssues(info, \"type\", \"variant\", this.message, input);\n      }\n      let issues;\n      let output;\n      const parseOptions = async (options2) => {\n        for (const schema of options2) {\n          if (schema.type === \"object\") {\n            const result = await schema.entries[this.key]._parse(\n              input[this.key],\n              info\n            );\n            if (!result.issues) {\n              const result2 = await schema._parse(input, info);\n              if (result2.issues) {\n                issues = result2.issues;\n              } else {\n                output = [result2.output];\n              }\n              break;\n            }\n          } else if (schema.type === \"variant\") {\n            await parseOptions(schema.options);\n            if (issues || output) {\n              break;\n            }\n          }\n        }\n      };\n      await parseOptions(this.options);\n      return output ? getOutput(output[0]) : issues ? getIssues(issues) : getSchemaIssues(info, \"type\", \"variant\", this.message, input);\n    }\n  };\n}\nvar discriminatedUnionAsync = variantAsync;\n\n// src/schemas/void/void.ts\nfunction void_(message = \"Invalid type\") {\n  return {\n    type: \"void\",\n    async: false,\n    message,\n    _parse(input, info) {\n      if (typeof input !== \"undefined\") {\n        return getSchemaIssues(info, \"type\", \"void\", this.message, input);\n      }\n      return getOutput(input);\n    }\n  };\n}\nvar voidType = void_;\n\n// src/schemas/void/voidAsync.ts\nfunction voidAsync(message = \"Invalid type\") {\n  return {\n    type: \"void\",\n    async: true,\n    message,\n    async _parse(input, info) {\n      if (typeof input !== \"undefined\") {\n        return getSchemaIssues(info, \"type\", \"void\", this.message, input);\n      }\n      return getOutput(input);\n    }\n  };\n}\nvar voidTypeAsync = voidAsync;\n\n// src/methods/keyof/keyof.ts\nfunction keyof(schema) {\n  return picklist(\n    Object.keys(schema.entries)\n  );\n}\n\n// src/methods/merge/merge.ts\nfunction merge(schemas, arg2, arg3, arg4) {\n  const [rest, message, pipe] = getRestAndDefaultArgs(arg2, arg3, arg4);\n  return object(\n    schemas.reduce(\n      (entries, schema) => ({ ...entries, ...schema.entries }),\n      {}\n    ),\n    rest,\n    message,\n    pipe\n  );\n}\n\n// src/methods/merge/mergeAsync.ts\nfunction mergeAsync(schemas, arg2, arg3, arg4) {\n  const [rest, message, pipe] = getRestAndDefaultArgs(arg2, arg3, arg4);\n  return objectAsync(\n    schemas.reduce(\n      (entries, schema) => ({ ...entries, ...schema.entries }),\n      {}\n    ),\n    rest,\n    message,\n    pipe\n  );\n}\n\n// src/methods/omit/omit.ts\nfunction omit(schema, keys, arg3, arg4, arg5) {\n  const [rest, message, pipe] = getRestAndDefaultArgs(arg3, arg4, arg5);\n  return object(\n    Object.entries(schema.entries).reduce(\n      (entries, [key, schema2]) => keys.includes(key) ? entries : { ...entries, [key]: schema2 },\n      {}\n    ),\n    rest,\n    message,\n    pipe\n  );\n}\n\n// src/methods/omit/omitAsync.ts\nfunction omitAsync(schema, keys, arg3, arg4, arg5) {\n  const [rest, message, pipe] = getRestAndDefaultArgs(arg3, arg4, arg5);\n  return objectAsync(\n    Object.entries(schema.entries).reduce(\n      (entries, [key, schema2]) => keys.includes(key) ? entries : { ...entries, [key]: schema2 },\n      {}\n    ),\n    rest,\n    message,\n    pipe\n  );\n}\n\n// src/methods/parse/parse.ts\nfunction parse(schema, input, info) {\n  const result = schema._parse(input, info);\n  if (result.issues) {\n    throw new ValiError(result.issues);\n  }\n  return result.output;\n}\n\n// src/methods/parse/parseAsync.ts\nasync function parseAsync(schema, input, info) {\n  const result = await schema._parse(input, info);\n  if (result.issues) {\n    throw new ValiError(result.issues);\n  }\n  return result.output;\n}\n\n// src/methods/partial/partial.ts\nfunction partial(schema, arg2, arg3, arg4) {\n  const [rest, message, pipe] = getRestAndDefaultArgs(arg2, arg3, arg4);\n  return object(\n    Object.entries(schema.entries).reduce(\n      (entries, [key, schema2]) => ({\n        ...entries,\n        [key]: optional(schema2)\n      }),\n      {}\n    ),\n    rest,\n    message,\n    pipe\n  );\n}\n\n// src/methods/partial/partialAsync.ts\nfunction partialAsync(schema, arg2, arg3, arg4) {\n  const [rest, message, pipe] = getRestAndDefaultArgs(arg2, arg3, arg4);\n  return objectAsync(\n    Object.entries(schema.entries).reduce(\n      (entries, [key, schema2]) => ({\n        ...entries,\n        [key]: optionalAsync(schema2)\n      }),\n      {}\n    ),\n    rest,\n    message,\n    pipe\n  );\n}\n\n// src/methods/passthrough/passthrough.ts\nfunction passthrough(schema) {\n  return {\n    ...schema,\n    _parse(input, info) {\n      const result = schema._parse(input, info);\n      return !result.issues ? getOutput({ ...input, ...result.output }) : result;\n    }\n  };\n}\n\n// src/methods/passthrough/passthroughAsync.ts\nfunction passthroughAsync(schema) {\n  return {\n    ...schema,\n    async _parse(input, info) {\n      const result = await schema._parse(input, info);\n      return !result.issues ? getOutput({ ...input, ...result.output }) : result;\n    }\n  };\n}\n\n// src/methods/pick/pick.ts\nfunction pick(schema, keys, arg3, arg4, arg5) {\n  const [rest, message, pipe] = getRestAndDefaultArgs(arg3, arg4, arg5);\n  return object(\n    Object.entries(schema.entries).reduce(\n      (entries, [key, schema2]) => keys.includes(key) ? { ...entries, [key]: schema2 } : entries,\n      {}\n    ),\n    rest,\n    message,\n    pipe\n  );\n}\n\n// src/methods/pick/pickAsync.ts\nfunction pickAsync(schema, keys, arg3, arg4, arg5) {\n  const [rest, message, pipe] = getRestAndDefaultArgs(arg3, arg4, arg5);\n  return objectAsync(\n    Object.entries(schema.entries).reduce(\n      (entries, [key, schema2]) => keys.includes(key) ? { ...entries, [key]: schema2 } : entries,\n      {}\n    ),\n    rest,\n    message,\n    pipe\n  );\n}\n\n// src/methods/required/required.ts\nfunction required(schema, arg2, arg3, arg4) {\n  const [rest, message, pipe] = getRestAndDefaultArgs(arg2, arg3, arg4);\n  return object(\n    Object.entries(schema.entries).reduce(\n      (entries, [key, schema2]) => ({\n        ...entries,\n        [key]: nonOptional(schema2)\n      }),\n      {}\n    ),\n    rest,\n    message,\n    pipe\n  );\n}\n\n// src/methods/required/requiredAsync.ts\nfunction requiredAsync(schema, arg2, arg3, arg4) {\n  const [rest, message, pipe] = getRestAndDefaultArgs(arg2, arg3, arg4);\n  return objectAsync(\n    Object.entries(schema.entries).reduce(\n      (entries, [key, schema2]) => ({\n        ...entries,\n        [key]: nonOptionalAsync(schema2)\n      }),\n      {}\n    ),\n    rest,\n    message,\n    pipe\n  );\n}\n\n// src/methods/safeParse/safeParse.ts\nfunction safeParse(schema, input, info) {\n  const result = schema._parse(input, info);\n  return result.issues ? {\n    success: false,\n    error: new ValiError(result.issues),\n    issues: result.issues\n  } : {\n    success: true,\n    data: result.output,\n    output: result.output\n  };\n}\n\n// src/methods/safeParse/safeParseAsync.ts\nasync function safeParseAsync(schema, input, info) {\n  const result = await schema._parse(input, info);\n  return result.issues ? {\n    success: false,\n    error: new ValiError(result.issues),\n    issues: result.issues\n  } : {\n    success: true,\n    data: result.output,\n    output: result.output\n  };\n}\n\n// src/methods/strict/strict.ts\nfunction strict(schema, message = \"Invalid keys\") {\n  return {\n    ...schema,\n    _parse(input, info) {\n      const result = schema._parse(input, info);\n      return !result.issues && Object.keys(input).some((key) => !(key in schema.entries)) ? getSchemaIssues(info, \"object\", \"strict\", message, input) : result;\n    }\n  };\n}\n\n// src/methods/strict/strictAsync.ts\nfunction strictAsync(schema, message = \"Invalid keys\") {\n  return {\n    ...schema,\n    message,\n    async _parse(input, info) {\n      const result = await schema._parse(input, info);\n      return !result.issues && Object.keys(input).some((key) => !(key in schema.entries)) ? getSchemaIssues(info, \"object\", \"strict\", message, input) : result;\n    }\n  };\n}\n\n// src/methods/strip/strip.ts\nfunction strip(schema) {\n  let cachedKeys;\n  return {\n    ...schema,\n    _parse(input, info) {\n      const result = schema._parse(input, info);\n      if (result.issues) {\n        return result;\n      }\n      cachedKeys = cachedKeys || Object.keys(schema.entries);\n      const output = {};\n      for (const key of cachedKeys) {\n        output[key] = result.output[key];\n      }\n      return getOutput(output);\n    }\n  };\n}\n\n// src/methods/strip/stripAsync.ts\nfunction stripAsync(schema) {\n  let cachedKeys;\n  return {\n    ...schema,\n    async _parse(input, info) {\n      const result = await schema._parse(input, info);\n      if (result.issues) {\n        return result;\n      }\n      cachedKeys = cachedKeys || Object.keys(schema.entries);\n      const output = {};\n      for (const key of cachedKeys) {\n        output[key] = result.output[key];\n      }\n      return getOutput(output);\n    }\n  };\n}\n\n// src/methods/transform/transform.ts\nfunction transform(schema, action, arg1) {\n  return {\n    ...schema,\n    _parse(input, info) {\n      const result = schema._parse(input, info);\n      if (result.issues) {\n        return result;\n      }\n      const output = action(result.output);\n      if (arg1 && !Array.isArray(arg1)) {\n        return arg1._parse(output, info);\n      }\n      return executePipe(output, arg1, info, typeof output);\n    }\n  };\n}\n\n// src/methods/transform/transformAsync.ts\nfunction transformAsync(schema, action, arg1) {\n  return {\n    ...schema,\n    async: true,\n    async _parse(input, info) {\n      const result = await schema._parse(input, info);\n      if (result.issues) {\n        return result;\n      }\n      const output = await action(result.output);\n      if (arg1 && !Array.isArray(arg1)) {\n        return arg1._parse(output, info);\n      }\n      return executePipeAsync(output, arg1, info, typeof output);\n    }\n  };\n}\n\n// src/methods/unwrap/unwrap.ts\nfunction unwrap(schema) {\n  return schema.wrapped;\n}\n\n// src/methods/withDefault/withDefault.ts\nfunction withDefault(schema, value2) {\n  return {\n    ...schema,\n    _parse(input, info) {\n      return schema._parse(\n        input === void 0 ? typeof value2 === \"function\" ? value2() : value2 : input,\n        info\n      );\n    }\n  };\n}\nvar useDefault = withDefault;\n\n// src/regex.ts\nvar CUID2_REGEX = /^[a-z][\\da-z]*$/u;\nvar EMAIL_REGEX = /^[\\w+-]+(?:\\.[\\w+-]+)*@[\\da-z]+(?:[.-][\\da-z]+)*\\.[a-z]{2,}$/iu;\nvar EMOJI_REGEX = /^[\\p{Extended_Pictographic}\\p{Emoji_Component}]+$/u;\nvar IMEI_REGEX = /^\\d{2}(?:[ /|-]?\\d{6}){2}[ /|-]?\\d$/u;\nvar IPV4_REGEX = (\n  // eslint-disable-next-line redos-detector/no-unsafe-regex -- false positive\n  /^(?:(?:[1-9]|1\\d|2[0-4])?\\d|25[0-5])(?:\\.(?:(?:[1-9]|1\\d|2[0-4])?\\d|25[0-5])){3}$/u\n);\nvar IPV6_REGEX = /^(?:(?:[\\da-f]{1,4}:){7}[\\da-f]{1,4}|(?:[\\da-f]{1,4}:){1,7}:|(?:[\\da-f]{1,4}:){1,6}:[\\da-f]{1,4}|(?:[\\da-f]{1,4}:){1,5}(?::[\\da-f]{1,4}){1,2}|(?:[\\da-f]{1,4}:){1,4}(?::[\\da-f]{1,4}){1,3}|(?:[\\da-f]{1,4}:){1,3}(?::[\\da-f]{1,4}){1,4}|(?:[\\da-f]{1,4}:){1,2}(?::[\\da-f]{1,4}){1,5}|[\\da-f]{1,4}:(?::[\\da-f]{1,4}){1,6}|:(?:(?::[\\da-f]{1,4}){1,7}|:)|fe80:(?::[\\da-f]{0,4}){0,4}%[\\da-z]+|::(?:f{4}(?::0{1,4})?:)?(?:(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d)\\.){3}(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d)|(?:[\\da-f]{1,4}:){1,4}:(?:(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d)\\.){3}(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d))$/iu;\nvar ISO_DATE_REGEX = /^\\d{4}-(?:0[1-9]|1[0-2])-(?:[12]\\d|0[1-9]|3[01])$/u;\nvar ISO_DATE_TIME_REGEX = /^\\d{4}-(?:0[1-9]|1[0-2])-(?:[12]\\d|0[1-9]|3[01])T(?:0\\d|1\\d|2[0-3]):[0-5]\\d$/u;\nvar ISO_TIME_REGEX = /^(?:0\\d|1\\d|2[0-3]):[0-5]\\d$/u;\nvar ISO_TIME_SECOND_REGEX = /^(?:0\\d|1\\d|2[0-3])(?::[0-5]\\d){2}$/u;\nvar ISO_TIMESTAMP_REGEX = /^\\d{4}-(?:0[1-9]|1[0-2])-(?:[12]\\d|0[1-9]|3[01])T(?:0\\d|1\\d|2[0-3])(?::[0-5]\\d){2}\\.\\d{3}Z$/u;\nvar ISO_WEEK_REGEX = /^\\d{4}-W(?:0[1-9]|[1-4]\\d|5[0-3])$/u;\nvar ULID_REGEX = /^[\\da-hjkmnp-tv-z]{26}$/iu;\nvar UUID_REGEX = /^[\\da-f]{8}(?:-[\\da-f]{4}){3}-[\\da-f]{12}$/iu;\n\n// src/transformations/toCustom/toCustom.ts\nfunction toCustom(action) {\n  return {\n    type: \"to_custom\",\n    async: false,\n    _parse(input) {\n      return getOutput(action(input));\n    }\n  };\n}\n\n// src/transformations/toCustom/toCustomAsync.ts\nfunction toCustomAsync(action) {\n  return {\n    type: \"to_custom\",\n    async: true,\n    async _parse(input) {\n      return getOutput(await action(input));\n    }\n  };\n}\n\n// src/transformations/toLowerCase/toLowerCase.ts\nfunction toLowerCase() {\n  return {\n    type: \"to_lower_case\",\n    async: false,\n    _parse(input) {\n      return getOutput(input.toLocaleLowerCase());\n    }\n  };\n}\n\n// src/transformations/toMaxValue/toMaxValue.ts\nfunction toMaxValue(requirement) {\n  return {\n    type: \"to_max_value\",\n    async: false,\n    requirement,\n    _parse(input) {\n      return getOutput(input > this.requirement ? this.requirement : input);\n    }\n  };\n}\n\n// src/transformations/toMinValue/toMinValue.ts\nfunction toMinValue(requirement) {\n  return {\n    type: \"to_min_value\",\n    async: false,\n    requirement,\n    _parse(input) {\n      return getOutput(input < this.requirement ? this.requirement : input);\n    }\n  };\n}\n\n// src/transformations/toTrimmed/toTrimmed.ts\nfunction toTrimmed() {\n  return {\n    type: \"to_trimmed\",\n    async: false,\n    _parse(input) {\n      return getOutput(input.trim());\n    }\n  };\n}\n\n// src/transformations/toTrimmedEnd/toTrimmedEnd.ts\nfunction toTrimmedEnd() {\n  return {\n    type: \"to_trimmed_end\",\n    async: false,\n    _parse(input) {\n      return getOutput(input.trimEnd());\n    }\n  };\n}\n\n// src/transformations/toTrimmedStart/toTrimmedStart.ts\nfunction toTrimmedStart() {\n  return {\n    type: \"to_trimmed_start\",\n    async: false,\n    _parse(input) {\n      return getOutput(input.trimStart());\n    }\n  };\n}\n\n// src/transformations/toUpperCase/toUpperCase.ts\nfunction toUpperCase() {\n  return {\n    type: \"to_upper_case\",\n    async: false,\n    _parse(input) {\n      return getOutput(input.toUpperCase());\n    }\n  };\n}\n\n// src/validations/bytes/bytes.ts\nfunction bytes(requirement, message = \"Invalid byte length\") {\n  return {\n    type: \"bytes\",\n    async: false,\n    message,\n    requirement,\n    _parse(input) {\n      return new TextEncoder().encode(input).length !== this.requirement ? getPipeIssues(this.type, this.message, input, this.requirement) : getOutput(input);\n    }\n  };\n}\n\n// src/validations/cuid2/cuid2.ts\nfunction cuid2(message = \"Invalid Cuid2\") {\n  return {\n    type: \"cuid2\",\n    async: false,\n    message,\n    requirement: CUID2_REGEX,\n    _parse(input) {\n      return !this.requirement.test(input) ? getPipeIssues(this.type, this.message, input, this.requirement) : getOutput(input);\n    }\n  };\n}\n\n// src/validations/custom/custom.ts\nfunction custom(requirement, message = \"Invalid input\") {\n  return {\n    type: \"custom\",\n    async: false,\n    message,\n    requirement,\n    _parse(input) {\n      return !this.requirement(input) ? getPipeIssues(this.type, this.message, input, this.requirement) : getOutput(input);\n    }\n  };\n}\n\n// src/validations/custom/customAsync.ts\nfunction customAsync(requirement, message = \"Invalid input\") {\n  return {\n    type: \"custom\",\n    async: true,\n    message,\n    requirement,\n    async _parse(input) {\n      return !await this.requirement(input) ? getPipeIssues(this.type, this.message, input, this.requirement) : getOutput(input);\n    }\n  };\n}\n\n// src/validations/email/email.ts\nfunction email(message = \"Invalid email\") {\n  return {\n    type: \"email\",\n    async: false,\n    message,\n    requirement: EMAIL_REGEX,\n    _parse(input) {\n      return !this.requirement.test(input) ? getPipeIssues(this.type, this.message, input, this.requirement) : getOutput(input);\n    }\n  };\n}\n\n// src/validations/emoji/emoji.ts\nfunction emoji(message = \"Invalid emoji\") {\n  return {\n    type: \"emoji\",\n    async: false,\n    message,\n    requirement: EMOJI_REGEX,\n    _parse(input) {\n      return !this.requirement.test(input) ? getPipeIssues(this.type, this.message, input, this.requirement) : getOutput(input);\n    }\n  };\n}\n\n// src/validations/endsWith/endsWith.ts\nfunction endsWith(requirement, message = \"Invalid end\") {\n  return {\n    type: \"ends_with\",\n    async: false,\n    message,\n    requirement,\n    _parse(input) {\n      return !input.endsWith(this.requirement) ? getPipeIssues(this.type, this.message, input, this.requirement) : getOutput(input);\n    }\n  };\n}\n\n// src/validations/equal/equal.ts\nfunction equal(requirement, message = \"Invalid input\") {\n  return {\n    type: \"equal\",\n    async: false,\n    message,\n    requirement,\n    _parse(input) {\n      return input !== this.requirement ? getPipeIssues(this.type, this.message, input, this.requirement) : getOutput(input);\n    }\n  };\n}\n\n// src/validations/excludes/excludes.ts\nfunction excludes(requirement, message = \"Invalid content\") {\n  return {\n    type: \"excludes\",\n    async: false,\n    message,\n    requirement,\n    _parse(input) {\n      return input.includes(this.requirement) ? getPipeIssues(this.type, this.message, input, this.requirement) : getOutput(input);\n    }\n  };\n}\n\n// src/validations/finite/finite.ts\nfunction finite(message = \"Invalid finite number\") {\n  return {\n    type: \"finite\",\n    async: false,\n    message,\n    requirement: Number.isFinite,\n    _parse(input) {\n      return !this.requirement(input) ? getPipeIssues(this.type, this.message, input, this.requirement) : getOutput(input);\n    }\n  };\n}\n\n// src/validations/imei/imei.ts\nfunction imei(message = \"Invalid IMEI\") {\n  return {\n    type: \"imei\",\n    async: false,\n    message,\n    requirement: [IMEI_REGEX, isLuhnAlgo],\n    _parse(input) {\n      return !this.requirement[0].test(input) || !this.requirement[1](input) ? getPipeIssues(this.type, this.message, input, this.requirement) : getOutput(input);\n    }\n  };\n}\n\n// src/validations/includes/includes.ts\nfunction includes(requirement, message = \"Invalid content\") {\n  return {\n    type: \"includes\",\n    async: false,\n    message,\n    requirement,\n    _parse(input) {\n      return !input.includes(requirement) ? getPipeIssues(this.type, this.message, input, this.requirement) : getOutput(input);\n    }\n  };\n}\n\n// src/validations/integer/integer.ts\nfunction integer(message = \"Invalid integer\") {\n  return {\n    type: \"integer\",\n    async: false,\n    message,\n    requirement: Number.isInteger,\n    _parse(input) {\n      return !this.requirement(input) ? getPipeIssues(this.type, this.message, input, this.requirement) : getOutput(input);\n    }\n  };\n}\n\n// src/validations/ip/ip.ts\nfunction ip(message = \"Invalid IP\") {\n  return {\n    type: \"ip\",\n    async: false,\n    message,\n    requirement: [IPV4_REGEX, IPV6_REGEX],\n    _parse(input) {\n      return !this.requirement[0].test(input) && !this.requirement[1].test(input) ? getPipeIssues(this.type, this.message, input, this.requirement) : getOutput(input);\n    }\n  };\n}\n\n// src/validations/ipv4/ipv4.ts\nfunction ipv4(message = \"Invalid IPv4\") {\n  return {\n    type: \"ipv4\",\n    async: false,\n    message,\n    requirement: IPV4_REGEX,\n    _parse(input) {\n      return !this.requirement.test(input) ? getPipeIssues(this.type, this.message, input, this.requirement) : getOutput(input);\n    }\n  };\n}\n\n// src/validations/ipv6/ipv6.ts\nfunction ipv6(message = \"Invalid IPv6\") {\n  return {\n    type: \"ipv6\",\n    async: false,\n    message,\n    requirement: IPV6_REGEX,\n    _parse(input) {\n      return !this.requirement.test(input) ? getPipeIssues(this.type, this.message, input, this.requirement) : getOutput(input);\n    }\n  };\n}\n\n// src/validations/isoDate/isoDate.ts\nfunction isoDate(message = \"Invalid date\") {\n  return {\n    type: \"iso_date\",\n    async: false,\n    message,\n    requirement: ISO_DATE_REGEX,\n    _parse(input) {\n      return !this.requirement.test(input) ? getPipeIssues(this.type, this.message, input, this.requirement) : getOutput(input);\n    }\n  };\n}\n\n// src/validations/isoDateTime/isoDateTime.ts\nfunction isoDateTime(message = \"Invalid date-time\") {\n  return {\n    type: \"iso_date_time\",\n    async: false,\n    message,\n    requirement: ISO_DATE_TIME_REGEX,\n    _parse(input) {\n      return !this.requirement.test(input) ? getPipeIssues(this.type, this.message, input, this.requirement) : getOutput(input);\n    }\n  };\n}\n\n// src/validations/isoTime/isoTime.ts\nfunction isoTime(message = \"Invalid time\") {\n  return {\n    type: \"iso_time\",\n    async: false,\n    message,\n    requirement: ISO_TIME_REGEX,\n    _parse(input) {\n      return !this.requirement.test(input) ? getPipeIssues(this.type, this.message, input, this.requirement) : getOutput(input);\n    }\n  };\n}\n\n// src/validations/isoTimeSecond/isoTimeSecond.ts\nfunction isoTimeSecond(message = \"Invalid time second\") {\n  return {\n    type: \"iso_time_second\",\n    async: false,\n    message,\n    requirement: ISO_TIME_SECOND_REGEX,\n    _parse(input) {\n      return !this.requirement.test(input) ? getPipeIssues(this.type, this.message, input, this.requirement) : getOutput(input);\n    }\n  };\n}\n\n// src/validations/isoTimestamp/isoTimestamp.ts\nfunction isoTimestamp(message = \"Invalid timestamp\") {\n  return {\n    type: \"iso_timestamp\",\n    async: false,\n    message,\n    requirement: ISO_TIMESTAMP_REGEX,\n    _parse(input) {\n      return !this.requirement.test(input) ? getPipeIssues(this.type, this.message, input, this.requirement) : getOutput(input);\n    }\n  };\n}\n\n// src/validations/isoWeek/isoWeek.ts\nfunction isoWeek(message = \"Invalid week\") {\n  return {\n    type: \"iso_week\",\n    async: false,\n    message,\n    requirement: ISO_WEEK_REGEX,\n    _parse(input) {\n      return !this.requirement.test(input) ? getPipeIssues(this.type, this.message, input, this.requirement) : getOutput(input);\n    }\n  };\n}\n\n// src/validations/length/length.ts\nfunction length(requirement, message = \"Invalid length\") {\n  return {\n    type: \"length\",\n    async: false,\n    message,\n    requirement,\n    _parse(input) {\n      return input.length !== this.requirement ? getPipeIssues(this.type, this.message, input, this.requirement) : getOutput(input);\n    }\n  };\n}\n\n// src/validations/maxBytes/maxBytes.ts\nfunction maxBytes(requirement, message = \"Invalid byte length\") {\n  return {\n    type: \"max_bytes\",\n    async: false,\n    message,\n    requirement,\n    _parse(input) {\n      return new TextEncoder().encode(input).length > this.requirement ? getPipeIssues(this.type, this.message, input, this.requirement) : getOutput(input);\n    }\n  };\n}\n\n// src/validations/maxLength/maxLength.ts\nfunction maxLength(requirement, message = \"Invalid length\") {\n  return {\n    type: \"max_length\",\n    async: false,\n    message,\n    requirement,\n    _parse(input) {\n      return input.length > this.requirement ? getPipeIssues(this.type, this.message, input, this.requirement) : getOutput(input);\n    }\n  };\n}\n\n// src/validations/maxSize/maxSize.ts\nfunction maxSize(requirement, message = \"Invalid size\") {\n  return {\n    type: \"max_size\",\n    async: false,\n    message,\n    requirement,\n    _parse(input) {\n      return input.size > this.requirement ? getPipeIssues(this.type, this.message, input, this.requirement) : getOutput(input);\n    }\n  };\n}\n\n// src/validations/maxValue/maxValue.ts\nfunction maxValue(requirement, message = \"Invalid value\") {\n  return {\n    type: \"max_value\",\n    async: false,\n    message,\n    requirement,\n    _parse(input) {\n      return input > this.requirement ? getPipeIssues(this.type, this.message, input, this.requirement) : getOutput(input);\n    }\n  };\n}\nvar maxRange = maxValue;\n\n// src/validations/minBytes/minBytes.ts\nfunction minBytes(requirement, message = \"Invalid byte length\") {\n  return {\n    type: \"min_bytes\",\n    async: false,\n    message,\n    requirement,\n    _parse(input) {\n      return new TextEncoder().encode(input).length < this.requirement ? getPipeIssues(this.type, this.message, input, this.requirement) : getOutput(input);\n    }\n  };\n}\n\n// src/validations/mimeType/mimeType.ts\nfunction mimeType(requirement, message = \"Invalid MIME type\") {\n  return {\n    type: \"mime_type\",\n    async: false,\n    message,\n    requirement,\n    _parse(input) {\n      return !this.requirement.includes(input.type) ? getPipeIssues(this.type, this.message, input, this.requirement) : getOutput(input);\n    }\n  };\n}\n\n// src/validations/minLength/minLength.ts\nfunction minLength(requirement, message = \"Invalid length\") {\n  return {\n    type: \"min_length\",\n    async: false,\n    message,\n    requirement,\n    _parse(input) {\n      return input.length < this.requirement ? getPipeIssues(this.type, this.message, input, this.requirement) : getOutput(input);\n    }\n  };\n}\n\n// src/validations/minSize/minSize.ts\nfunction minSize(requirement, message = \"Invalid size\") {\n  return {\n    type: \"min_size\",\n    async: false,\n    message,\n    requirement,\n    _parse(input) {\n      return input.size < this.requirement ? getPipeIssues(this.type, this.message, input, this.requirement) : getOutput(input);\n    }\n  };\n}\n\n// src/validations/minValue/minValue.ts\nfunction minValue(requirement, message = \"Invalid value\") {\n  return {\n    type: \"min_value\",\n    async: false,\n    message,\n    requirement,\n    _parse(input) {\n      return input < this.requirement ? getPipeIssues(this.type, this.message, input, this.requirement) : getOutput(input);\n    }\n  };\n}\nvar minRange = minValue;\n\n// src/validations/multipleOf/multipleOf.ts\nfunction multipleOf(requirement, message = \"Invalid multiple\") {\n  return {\n    type: \"multiple_of\",\n    async: false,\n    message,\n    requirement,\n    _parse(input) {\n      return input % this.requirement !== 0 ? getPipeIssues(this.type, this.message, input, this.requirement) : getOutput(input);\n    }\n  };\n}\n\n// src/validations/notBytes/notBytes.ts\nfunction notBytes(requirement, message = \"Invalid byte length\") {\n  return {\n    type: \"not_bytes\",\n    async: false,\n    message,\n    requirement,\n    _parse(input) {\n      return new TextEncoder().encode(input).length === this.requirement ? getPipeIssues(this.type, this.message, input, this.requirement) : getOutput(input);\n    }\n  };\n}\n\n// src/validations/notLength/notLength.ts\nfunction notLength(requirement, message = \"Invalid length\") {\n  return {\n    type: \"not_length\",\n    async: false,\n    message,\n    requirement,\n    _parse(input) {\n      return input.length === this.requirement ? getPipeIssues(this.type, this.message, input, this.requirement) : getOutput(input);\n    }\n  };\n}\n\n// src/validations/notSize/notSize.ts\nfunction notSize(requirement, message = \"Invalid size\") {\n  return {\n    type: \"not_size\",\n    async: false,\n    message,\n    requirement,\n    _parse(input) {\n      return input.size === this.requirement ? getPipeIssues(this.type, this.message, input, this.requirement) : getOutput(input);\n    }\n  };\n}\n\n// src/validations/notValue/notValue.ts\nfunction notValue(requirement, message = \"Invalid value\") {\n  return {\n    type: \"not_value\",\n    async: false,\n    message,\n    requirement,\n    _parse(input) {\n      return input === this.requirement ? getPipeIssues(this.type, this.message, input, this.requirement) : getOutput(input);\n    }\n  };\n}\n\n// src/validations/regex/regex.ts\nfunction regex(requirement, message = \"Invalid regex\") {\n  return {\n    type: \"regex\",\n    async: false,\n    message,\n    requirement,\n    _parse(input) {\n      return !this.requirement.test(input) ? getPipeIssues(this.type, this.message, input, this.requirement) : getOutput(input);\n    }\n  };\n}\n\n// src/validations/safeInteger/safeInteger.ts\nfunction safeInteger(message = \"Invalid safe integer\") {\n  return {\n    type: \"safe_integer\",\n    async: false,\n    message,\n    requirement: Number.isSafeInteger,\n    _parse(input) {\n      return !this.requirement(input) ? getPipeIssues(this.type, this.message, input, this.requirement) : getOutput(input);\n    }\n  };\n}\n\n// src/validations/size/size.ts\nfunction size(requirement, message = \"Invalid size\") {\n  return {\n    type: \"size\",\n    async: false,\n    message,\n    requirement,\n    _parse(input) {\n      return input.size !== this.requirement ? getPipeIssues(this.type, this.message, input, this.requirement) : getOutput(input);\n    }\n  };\n}\n\n// src/validations/startsWith/startsWith.ts\nfunction startsWith(requirement, message = \"Invalid start\") {\n  return {\n    type: \"stars_with\",\n    async: false,\n    message,\n    requirement,\n    _parse(input) {\n      return !input.startsWith(this.requirement) ? getPipeIssues(this.type, this.message, input, this.requirement) : getOutput(input);\n    }\n  };\n}\n\n// src/validations/ulid/ulid.ts\nfunction ulid(message = \"Invalid ULID\") {\n  return {\n    type: \"ulid\",\n    async: false,\n    message,\n    requirement: ULID_REGEX,\n    _parse(input) {\n      return !this.requirement.test(input) ? getPipeIssues(this.type, this.message, input, this.requirement) : getOutput(input);\n    }\n  };\n}\n\n// src/validations/url/url.ts\nfunction url(message = \"Invalid URL\") {\n  return {\n    type: \"url\",\n    async: false,\n    message,\n    requirement(input) {\n      try {\n        new URL(input);\n        return true;\n      } catch {\n        return false;\n      }\n    },\n    _parse(input) {\n      return !this.requirement(input) ? getPipeIssues(this.type, this.message, input, this.requirement) : getOutput(input);\n    }\n  };\n}\n\n// src/validations/uuid/uuid.ts\nfunction uuid(message = \"Invalid UUID\") {\n  return {\n    type: \"uuid\",\n    async: false,\n    message,\n    requirement: UUID_REGEX,\n    _parse(input) {\n      return !this.requirement.test(input) ? getPipeIssues(this.type, this.message, input, this.requirement) : getOutput(input);\n    }\n  };\n}\n\n// src/validations/value/value.ts\nfunction value(requirement, message = \"Invalid value\") {\n  return {\n    type: \"value\",\n    async: false,\n    message,\n    requirement,\n    _parse(input) {\n      return input !== this.requirement ? getPipeIssues(this.type, this.message, input, this.requirement) : getOutput(input);\n    }\n  };\n}\nexport {\n  BrandSymbol,\n  CUID2_REGEX,\n  EMAIL_REGEX,\n  EMOJI_REGEX,\n  IMEI_REGEX,\n  IPV4_REGEX,\n  IPV6_REGEX,\n  ISO_DATE_REGEX,\n  ISO_DATE_TIME_REGEX,\n  ISO_TIMESTAMP_REGEX,\n  ISO_TIME_REGEX,\n  ISO_TIME_SECOND_REGEX,\n  ISO_WEEK_REGEX,\n  ULID_REGEX,\n  UUID_REGEX,\n  ValiError,\n  any,\n  anyAsync,\n  array,\n  arrayAsync,\n  bigint,\n  bigintAsync,\n  blob,\n  blobAsync,\n  boolean,\n  booleanAsync,\n  brand,\n  bytes,\n  coerce,\n  coerceAsync,\n  cuid2,\n  custom,\n  customAsync,\n  date,\n  dateAsync,\n  discriminatedUnion,\n  discriminatedUnionAsync,\n  email,\n  emoji,\n  endsWith,\n  enumAsync,\n  enumType,\n  enumTypeAsync,\n  enum_,\n  equal,\n  excludes,\n  executePipe,\n  executePipeAsync,\n  fallback,\n  fallbackAsync,\n  finite,\n  flatten,\n  getDefault,\n  getDefaultArgs,\n  getDefaultAsync,\n  getDefaults,\n  getDefaultsAsync,\n  getFallback,\n  getFallbackAsync,\n  getFallbacks,\n  getFallbacksAsync,\n  getIssues,\n  getOutput,\n  getPipeIssues,\n  getRestAndDefaultArgs,\n  getSchemaIssues,\n  imei,\n  includes,\n  instance,\n  instanceAsync,\n  integer,\n  intersect,\n  intersection,\n  ip,\n  ipv4,\n  ipv6,\n  is,\n  isLuhnAlgo,\n  isoDate,\n  isoDateTime,\n  isoTime,\n  isoTimeSecond,\n  isoTimestamp,\n  isoWeek,\n  keyof,\n  length,\n  literal,\n  literalAsync,\n  map,\n  mapAsync,\n  maxBytes,\n  maxLength,\n  maxRange,\n  maxSize,\n  maxValue,\n  merge,\n  mergeAsync,\n  mimeType,\n  minBytes,\n  minLength,\n  minRange,\n  minSize,\n  minValue,\n  multipleOf,\n  nan,\n  nanAsync,\n  nativeEnum,\n  nativeEnumAsync,\n  never,\n  neverAsync,\n  nonNullable,\n  nonNullableAsync,\n  nonNullish,\n  nonNullishAsync,\n  nonOptional,\n  nonOptionalAsync,\n  notBytes,\n  notLength,\n  notSize,\n  notValue,\n  nullAsync,\n  nullType,\n  nullTypeAsync,\n  null_,\n  nullable,\n  nullableAsync,\n  nullish,\n  nullishAsync,\n  number,\n  numberAsync,\n  object,\n  objectAsync,\n  omit,\n  omitAsync,\n  optional,\n  optionalAsync,\n  parse,\n  parseAsync,\n  partial,\n  partialAsync,\n  passthrough,\n  passthroughAsync,\n  pick,\n  pickAsync,\n  picklist,\n  picklistAsync,\n  record,\n  recordAsync,\n  recursive,\n  recursiveAsync,\n  regex,\n  required,\n  requiredAsync,\n  safeInteger,\n  safeParse,\n  safeParseAsync,\n  set,\n  setAsync,\n  size,\n  special,\n  specialAsync,\n  startsWith,\n  strict,\n  strictAsync,\n  string,\n  stringAsync,\n  strip,\n  stripAsync,\n  symbol,\n  symbolAsync,\n  toCustom,\n  toCustomAsync,\n  toLowerCase,\n  toMaxValue,\n  toMinValue,\n  toTrimmed,\n  toTrimmedEnd,\n  toTrimmedStart,\n  toUpperCase,\n  transform,\n  transformAsync,\n  tuple,\n  tupleAsync,\n  ulid,\n  undefinedAsync,\n  undefinedType,\n  undefinedTypeAsync,\n  undefined_,\n  union,\n  unionAsync,\n  unknown,\n  unknownAsync,\n  unwrap,\n  url,\n  useDefault,\n  uuid,\n  value,\n  variant,\n  variantAsync,\n  voidAsync,\n  voidType,\n  voidTypeAsync,\n  void_,\n  withDefault\n};\n","function isRecord(value) {\n  return typeof value === \"object\" && value !== null && !Array.isArray(value);\n}\nfunction isArray(value) {\n  return value !== null && Array.isArray(value);\n}\nfunction pathToUrlString(path) {\n  let str = \"\";\n  for (const segment of path) {\n    if (typeof segment === \"string\") {\n      if (str) str += \".\";\n      str += segment;\n      continue;\n    }\n    if (typeof segment === \"number\") {\n      if (str) str += \":\";\n      str += `${segment}`;\n      continue;\n    }\n    if (isArray(segment)) {\n      if (str) str += \":\";\n      str += `${segment.join(\",\")}}`;\n      continue;\n    }\n    if (segment._key) {\n      if (str) str += \":\";\n      str += `${segment._key}`;\n      continue;\n    }\n  }\n  return str;\n}\nconst RE_SEGMENT_WITH_INDEX = /^([A-Za-z]+):([0-9]+)$/;\nconst RE_SEGMENT_WITH_TUPLE = /^([A-Za-z]+):([0-9]+),([0-9]+)$/;\nconst RE_SEGMENT_WITH_KEY = /^([A-Za-z]+):([a-z0-9]+)$/;\nfunction urlStringToPath(str) {\n  const path = [];\n  for (const segment of str.split(\".\")) {\n    const withIndex = RE_SEGMENT_WITH_INDEX.exec(segment);\n    if (withIndex) {\n      path.push(withIndex[1], Number(withIndex[2]));\n      continue;\n    }\n    const withTuple = RE_SEGMENT_WITH_TUPLE.exec(segment);\n    if (withTuple) {\n      path.push(withTuple[1], [Number(withTuple[2]), Number(withTuple[3])]);\n      continue;\n    }\n    const withKey = RE_SEGMENT_WITH_KEY.exec(segment);\n    if (withKey) {\n      path.push(withKey[1], {\n        _key: withKey[2]\n      });\n      continue;\n    }\n    path.push(segment);\n  }\n  return path;\n}\nexport { isArray, isRecord, pathToUrlString, urlStringToPath };\n//# sourceMappingURL=urlStringToPath-ntyJ_1w6.js.map\n","import { resolveMapping, getPublishedId, studioPath, jsonPathToStudioPath, resolvedKeyedSourcePath } from '@sanity/client/csm';\nimport { string, minLength, optional, object, is, safeParse, parse } from 'valibot';\nimport { pathToUrlString, urlStringToPath, isRecord, isArray } from './_chunks/urlStringToPath-ntyJ_1w6.js';\nfunction resolveSanityNode(context, csm, resultPath, keyedResultPath) {\n  const {\n    mapping,\n    pathSuffix\n  } = resolveMapping(resultPath, csm) || {};\n  if (!mapping) {\n    return void 0;\n  }\n  if (mapping.source.type === \"literal\") {\n    return void 0;\n  }\n  if (mapping.source.type === \"unknown\") {\n    return void 0;\n  }\n  const sourceDoc = csm.documents[mapping.source.document];\n  const sourceBasePath = csm.paths[mapping.source.path];\n  if (sourceDoc && sourceBasePath) {\n    return {\n      baseUrl: context.baseUrl,\n      workspace: context.workspace,\n      tool: context.tool,\n      type: sourceDoc._type,\n      id: getPublishedId(sourceDoc._id),\n      path: studioPath.toString(jsonPathToStudioPath(resolvedKeyedSourcePath({\n        keyedResultPath,\n        pathSuffix,\n        sourceBasePath\n      })))\n    };\n  }\n  return void 0;\n}\nconst lengthyStr = string([minLength(1)]);\nconst optionalLengthyStr = optional(lengthyStr);\nconst sanityNodeSchema = object({\n  id: lengthyStr,\n  path: lengthyStr,\n  type: optionalLengthyStr,\n  baseUrl: lengthyStr,\n  workspace: optionalLengthyStr,\n  tool: optionalLengthyStr\n});\nconst sanityLegacyNodeSchema = object({\n  origin: lengthyStr,\n  href: lengthyStr,\n  data: optionalLengthyStr\n});\nfunction isValidSanityNode(node) {\n  return is(sanityNodeSchema, node);\n}\nfunction isValidSanityLegacyNode(node) {\n  return is(sanityLegacyNodeSchema, node);\n}\nfunction encodeSanityNodeData(node) {\n  const {\n    id: _id,\n    path,\n    baseUrl,\n    tool,\n    workspace,\n    type\n  } = node;\n  if (!isValidSanityNode(node)) {\n    return void 0;\n  }\n  const parts = [[\"id\", getPublishedId(_id)], [\"type\", type], [\"path\", pathToUrlString(studioPath.fromString(path))], [\"base\", encodeURIComponent(baseUrl)], [\"workspace\", workspace], [\"tool\", tool]];\n  return parts.filter(([, value]) => !!value).map(part => part.join(\"=\")).join(\";\");\n}\nfunction decodeSanityString(str) {\n  const segments = str.split(\";\");\n  const data = segments.reduce((acc, segment) => {\n    const [key, value] = segment.split(\"=\");\n    if (!key || !value) return acc;\n    switch (key) {\n      case \"id\":\n        acc.id = value;\n        break;\n      case \"type\":\n        acc.type = value;\n        break;\n      case \"path\":\n        acc.path = studioPath.toString(urlStringToPath(value));\n        break;\n      case \"base\":\n        acc.baseUrl = decodeURIComponent(value);\n        break;\n      case \"tool\":\n        acc.tool = value;\n        break;\n      case \"workspace\":\n        acc.workspace = value;\n        break;\n    }\n    return acc;\n  }, {});\n  if (!isValidSanityNode(data)) return void 0;\n  return data;\n}\nfunction decodeSanityJson(data) {\n  const sanityNode = safeParse(sanityNodeSchema, data);\n  if (sanityNode.success) {\n    return sanityNode.output;\n  }\n  const sanityLegacyNode = safeParse(sanityLegacyNodeSchema, data);\n  if (sanityLegacyNode.success) {\n    try {\n      const url = new URL(sanityLegacyNode.output.href, typeof document === \"undefined\" ? \"https://example.com\" : location.origin);\n      if (url.searchParams.size > 0) {\n        return parse(sanityNodeSchema, Object.fromEntries(url.searchParams.entries()));\n      }\n      return sanityLegacyNode.output;\n    } catch (err) {\n      console.error(\"Failed to parse sanity node\", err);\n      return sanityLegacyNode.output;\n    }\n  }\n  return void 0;\n}\nfunction decodeSanityNodeData(str) {\n  try {\n    const json = JSON.parse(str);\n    return decodeSanityJson(json);\n  } catch {\n    return decodeSanityString(str);\n  }\n}\nconst SANITY_KEYS = [\"_createdAt\", \"_dataset\", \"_id\", \"_key\", \"_originalId\", \"_projectId\", \"_ref\", \"_rev\", \"_strengthenOnPublish\", \"_type\", \"_updatedAt\", \"_weak\"];\nfunction isSourceNode(t) {\n  return isRecord(t) && t.$$type$$ === \"sanity\";\n}\nfunction unwrapData(wrapper) {\n  if (wrapper === void 0) {\n    return void 0;\n  }\n  if (wrapper === null) {\n    return null;\n  }\n  if (isSourceNode(wrapper)) {\n    return wrapper.value;\n  }\n  if (isArray(wrapper)) {\n    return wrapper.map(item => unwrapData(item));\n  }\n  if (isRecord(wrapper)) {\n    return Object.fromEntries(Object.entries(wrapper).map(([k, v]) => SANITY_KEYS.includes(k) ? [k, v] : [k, unwrapData(v)]));\n  }\n  throw new Error(\"invalid wrapped value\");\n}\nfunction wrapData(context, value, sourceMap, resultPath = [], keyedResultPath = []) {\n  if (value === void 0) {\n    return void 0;\n  }\n  if (value === null) {\n    return null;\n  }\n  if (isArray(value)) {\n    return value.map((t, idx) => wrapData(context, t, sourceMap, resultPath.concat(idx), keyedResultPath.concat(isRecord(t) && \"_key\" in t && typeof t._key === \"string\" ? {\n      _key: t._key,\n      _index: idx\n    } : idx)));\n  }\n  if (isRecord(value)) {\n    return Object.fromEntries(Object.entries(value).map(([k, v]) => SANITY_KEYS.includes(k) ? [k, v] : [k, wrapData(context, v, sourceMap, resultPath.concat(k), keyedResultPath.concat(k))]));\n  }\n  return {\n    $$type$$: \"sanity\",\n    path: studioPath.toString(jsonPathToStudioPath(resultPath)) || void 0,\n    source: sourceMap ? resolveSanityNode(context, sourceMap, resultPath, keyedResultPath) : void 0,\n    value\n  };\n}\nexport { decodeSanityNodeData, decodeSanityString, encodeSanityNodeData, isValidSanityLegacyNode, isValidSanityNode, resolveSanityNode, unwrapData, wrapData };\n//# sourceMappingURL=csm.js.map\n","import type { HTMLProps, Ref } from 'react'\nimport { createElement, forwardRef } from 'react'\nimport {\n  encodeSanityNodeData,\n  type SourceNode,\n} from 'visual-editing-helpers/csm'\n\nexport interface SanityElementProps {\n  children?: SourceNode | null\n}\n\nexport const SanityElement = forwardRef(function SanityElement(\n  props: { as: string } & SanityElementProps &\n    Omit<HTMLProps<HTMLElement>, 'children'>,\n  ref: Ref<HTMLElement | SVGElement>,\n) {\n  const { as, children: node, ...restProps } = props\n\n  if (node?.source) {\n    return createElement(\n      as,\n      {\n        ...restProps,\n        'data-sanity': encodeSanityNodeData(node.source),\n        ref,\n      },\n      node.value,\n    )\n  }\n\n  return createElement(as, restProps, node?.value)\n})\n","export const svgElements = [\n  'animate',\n  'circle',\n  'defs',\n  'desc',\n  'ellipse',\n  'g',\n  'image',\n  'line',\n  'filter',\n  'marker',\n  'mask',\n  'metadata',\n  'path',\n  'pattern',\n  'polygon',\n  'polyline',\n  'rect',\n  'stop',\n  'svg',\n  'switch',\n  'symbol',\n  'text',\n  'tspan',\n  'use',\n  'view',\n  'clipPath',\n  'feBlend',\n  'feColorMatrix',\n  'feComponentTransfer',\n  'feComposite',\n  'feConvolveMatrix',\n  'feDiffuseLighting',\n  'feDisplacementMap',\n  'feDistantLight',\n  'feDropShadow',\n  'feFlood',\n  'feFuncA',\n  'feFuncB',\n  'feFuncG',\n  'feFuncR',\n  'feGaussianBlur',\n  'feImage',\n  'feMerge',\n  'feMergeNode',\n  'feMorphology',\n  'feOffset',\n  'fePointLight',\n  'feSpecularLighting',\n  'feSpotLight',\n  'feTile',\n  'feTurbulence',\n  'foreignObject',\n  'linearGradient',\n  'radialGradient',\n  'textPath',\n] as const\n","import type {\n  ForwardRefExoticComponent,\n  HTMLProps,\n  ReactElement,\n  Ref,\n  SVGProps,\n} from 'react'\nimport { createElement, forwardRef } from 'react'\n\nimport { htmlElements } from './html'\nimport type { SanityElementProps } from './SanityElement'\nimport { SanityElement } from './SanityElement'\nimport { svgElements } from './svg'\n\nexport type SanityHTMLElements = Record<\n  (typeof htmlElements)[number],\n  ForwardRefExoticComponent<\n    SanityElementProps & Omit<HTMLProps<HTMLElement>, 'children' | 'ref'>\n  >\n>\n\nexport type SanitySVGElements = Record<\n  (typeof svgElements)[number],\n  ForwardRefExoticComponent<\n    SanityElementProps & Omit<SVGProps<SVGElement>, 'children' | 'ref'>\n  >\n>\n\nexport type SanityElements = SanityHTMLElements & SanitySVGElements\n\nfunction isHTMLElement(name: string): name is keyof SanityHTMLElements {\n  return htmlElements.includes(name as any)\n}\n\nfunction isSVGElement(name: string): name is keyof SanitySVGElements {\n  return svgElements.includes(name as any)\n}\n\nconst sanity = new Proxy({} as SanityElements, {\n  get(target: SanityElements, prop: string) {\n    if (isHTMLElement(prop)) {\n      if (target[prop]) return target[prop]\n\n      const SanityComponent = forwardRef(function SanityComponent(\n        props: SanityElementProps &\n          Omit<HTMLProps<HTMLElement>, 'children' | 'ref'>,\n        ref: Ref<HTMLElement>,\n      ): ReactElement {\n        return createElement(SanityElement, { as: prop, ref, ...props })\n      })\n\n      SanityComponent.displayName = `sanity.${prop}`\n\n      target[prop] = SanityComponent\n\n      return SanityComponent\n    }\n\n    if (isSVGElement(prop)) {\n      if (target[prop]) return target[prop]\n\n      const SanityComponent = forwardRef(function SanityComponent(\n        props: SanityElementProps &\n          Omit<SVGProps<SVGElement>, 'children' | 'ref'>,\n        ref: Ref<SVGElement>,\n      ): ReactElement {\n        return createElement(SanityElement, { as: prop, ref, ...props } as any)\n      })\n\n      SanityComponent.displayName = `sanity.${prop}`\n\n      target[prop] = SanityComponent as any\n\n      return SanityComponent\n    }\n\n    throw new Error(`No such element: ${prop}`)\n  },\n})\n\nexport { sanity }\n"],"names":["htmlElements","getIssues","issues","getOutput","output","getIssue","info","issue","reason","validation","origin","message","input","path","abortEarly","abortPipeEarly","skipPipe","getPipeInfo","executePipe","pipe","parseInfo","length","pipeInfo","action","result","_parse","issueInfo","push","getDefaultArgs","arg1","arg2","Array","isArray","getErrorMessage","getPipeIssues","requirement","getRestAndDefaultArgs","arg3","error2","pipe2","error","getSchemaIssues","getDefault","schema","default","is","object","entries","arg4","rest","cachedEntries","type","async","Object","key","value2","pathItem","value","unshift","optional","wrapped","default_","override","string","minLength","isRecord","pathToUrlString","str","segment","join","_key","resolveSanityNode","context","csm","resultPath","keyedResultPath","mapping","pathSuffix","resolveMapping","source","sourceDoc","documents","document","sourceBasePath","paths","baseUrl","workspace","tool","_type","id","getPublishedId","_id","studioPath","toString","jsonPathToStudioPath","resolvedKeyedSourcePath","lengthyStr","optionalLengthyStr","sanityNodeSchema","isValidSanityNode","node","encodeSanityNodeData","parts","fromString","encodeURIComponent","filter","map","part","SANITY_KEYS","isSourceNode","t","$$type$$","unwrapData","wrapper","item","fromEntries","k","v","includes","Error","wrapData","sourceMap","idx","concat","_index","SanityElement","forwardRef","props","ref","as","children","restProps","createElement","svgElements","isHTMLElement","name","isSVGElement","sanity","Proxy","get","target","prop","SanityComponent","displayName"],"mappings":";;;;;;;AAAO,MAAMA,YAAe,GAAA,CAC1B,GAAA,EACA,MAAA,EACA,SAAA,EACA,MAAA,EACA,SAAA,EACA,OAAA,EACA,OAAA,EACA,GAAA,EACA,MAAA,EACA,KAAA,EACA,KAAA,EACA,KAAA,EACA,YAAA,EACA,MAAA,EACA,IAAA,EACA,QAAA,EACA,QAAA,EACA,SAAA,EACA,MAAA,EACA,MAAA,EACA,KAAA,EACA,UAAA,EACA,MAAA,EACA,UAAA,EACA,IAAA,EACA,KAAA,EACA,SAAA,EACA,KAAA,EACA,QAAA,EACA,KAAA,EACA,IAAA,EACA,IAAA,EACA,IAAA,EACA,OAAA,EACA,UAAA,EACA,YAAA,EACA,QAAA,EACA,QAAA,EACA,MAAA,EACA,IAAA,EACA,IAAA,EACA,IAAA,EACA,IAAA,EACA,IAAA,EACA,IAAA,EACA,MAAA,EACA,QAAA,EACA,QAAA,EACA,IAAA,EACA,MAAA,EACA,GAAA,EACA,QAAA,EACA,KAAA,EACA,OAAA,EACA,KAAA,EACA,KAAA,EACA,QAAA,EACA,OAAA,EACA,QAAA,EACA,IAAA,EACA,MAAA,EACA,MAAA,EACA,KAAA,EACA,MAAA,EACA,MAAA,EACA,UAAA,EACA,MAAA,EACA,OAAA,EACA,KAAA,EACA,UAAA,EACA,QAAA,EACA,IAAA,EACA,UAAA,EACA,QAAA,EACA,QAAA,EACA,GAAA,EACA,OAAA,EACA,SAAA,EACA,KAAA,EACA,UAAA,EACA,GAAA,EACA,IAAA,EACA,IAAA,EACA,MAAA,EACA,GAAA,EACA,MAAA,EACA,QAAA,EACA,SAAA,EACA,QAAA,EACA,OAAA,EACA,QAAA,EACA,MAAA,EACA,QAAA,EACA,OAAA,EACA,KAAA,EACA,SAAA,EACA,KAAA,EACA,OAAA,EACA,OAAA,EACA,IAAA,EACA,UAAA,EACA,OAAA,EACA,IAAA,EACA,OAAA,EACA,MAAA,EACA,OAAA,EACA,IAAA,EACA,OAAA,EACA,GAAA,EACA,IAAA,EACA,KAAA,EACA,OAAA,EACA,KAAA,EACA,SAAA,CACF;;ACnHA;;AAqEA;AACA,SAASC,S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","x_google_ignoreList":[1]}
\ No newline at end of file
diff --git a/dist/jsx.js b/dist/jsx.js
index 7db6331f64f9345e315ff0728c7afb5bfff042be..0c8a24a26c2bf8d8a022abb6edfa9c4bab6c8e23 100644
--- a/dist/jsx.js
+++ b/dist/jsx.js
@@ -1 +1,455 @@
-import{forwardRef as e,createElement as t}from"react";import{getPublishedId as r,studioPath as n,jsonPathToStudioPath as i,resolveMapping as o,resolvedKeyedSourcePath as a}from"@sanity/client/csm";const s=["a","abbr","address","area","article","aside","audio","b","base","bdi","bdo","big","blockquote","body","br","button","canvas","caption","cite","code","col","colgroup","data","datalist","dd","del","details","dfn","dialog","div","dl","dt","em","embed","fieldset","figcaption","figure","footer","form","h1","h2","h3","h4","h5","h6","head","header","hgroup","hr","html","i","iframe","img","input","ins","kbd","keygen","label","legend","li","link","main","map","mark","menu","menuitem","meta","meter","nav","noscript","object","ol","optgroup","option","output","p","param","picture","pre","progress","q","rp","rt","ruby","s","samp","script","section","select","small","source","span","strong","style","sub","summary","sup","table","tbody","td","textarea","tfoot","th","thead","time","title","tr","track","u","ul","var","video","wbr","webview"];function u(e){return{issues:e}}function p(e){return{output:e}}function c(e,t){return{reason:e?.reason,validation:t.validation,origin:e?.origin||"value",message:t.message,input:t.input,path:t.path,abortEarly:e?.abortEarly,abortPipeEarly:e?.abortPipeEarly,skipPipe:e?.skipPipe}}function f(e,t){return{reason:t,origin:e?.origin,abortEarly:e?.abortEarly,abortPipeEarly:e?.abortPipeEarly,skipPipe:e?.skipPipe}}function l(e,t,r,n){if(!t||!t.length||r?.skipPipe)return p(e);let i,o,a=e;for(const e of t){const t=e(a);if(t.issues){i=i||f(r,n);for(const e of t.issues){const t=c(i,e);o?o.push(t):o=[t]}if(i.abortEarly||i.abortPipeEarly)break}else a=t.output}return o?u(o):p(a)}function y(e,t){return Array.isArray(e)?[void 0,e]:[e,t]}function d(e){return"function"==typeof e?e():e}function b(e,t,r,n,i,o){return{issues:[{reason:t,validation:r,origin:e?.origin||"value",message:d(n),input:i,issues:o,abortEarly:e?.abortEarly,abortPipeEarly:e?.abortPipeEarly,skipPipe:e?.skipPipe}]}}function h(e){return"object"==typeof e&&null!==e&&!Array.isArray(e)}function g(e){return null!==e&&Array.isArray(e)}function m(e){let t="";for(const r of e)"string"!=typeof r?"number"!=typeof r?g(r)?(t&&(t+=":"),t+=`${r.join(",")}}`):r._key&&(t&&(t+=":"),t+=`${r._key}`):(t&&(t+=":"),t+=`${r}`):(t&&(t+="."),t+=r);return t}function v(e,t,s,u){const{mapping:p,pathSuffix:c}=o(s,t)||{};if(!p)return;if("literal"===p.source.type)return;if("unknown"===p.source.type)return;const f=t.documents[p.source.document],l=t.paths[p.source.path];return f&&l?{baseUrl:e.baseUrl,workspace:e.workspace,tool:e.tool,type:f._type,id:r(f._id),path:n.toString(i(a({keyedResultPath:u,pathSuffix:c,sourceBasePath:l})))}:void 0}const k=function(e,t){const[r,n]=y(e,t);return{type:"string",async:!1,_parse:(e,t)=>"string"!=typeof e?b(t,"type","string",r||"Invalid type",e):l(e,n,t,"string")}}([(j=1,e=>e.length<j?function(e,t,r){return u([{validation:e,message:d(t),input:r}])}("min_length",$||"Invalid length",e):p(e))]),_={type:"optional",wrapped:E=k,getDefault:()=>"function"==typeof P?P():P,async:!1,_parse(e,t){if(void 0===e){const t=this.getDefault();if(void 0===t)return p(e);e=t}return E._parse(e,t)}},w=function(e,t,r,n){const[i,o,a]=function(e,t,r){if(!e||"object"==typeof e&&!Array.isArray(e)){const[n,i]=y(t,r);return[e,n,i]}const[n,i]=y(e,t);return[void 0,n,i]}(t,r,n);let s;return{type:"object",entries:e,rest:i,async:!1,_parse(t,r){if(!t||"object"!=typeof t)return b(r,"type","object",o||"Invalid type",t);let n;s=s||Object.entries(e);const p={};for(const[e,i]of s){const o=t[e],a=i._parse(o,r);if(a.issues){const i={type:"object",input:t,key:e,value:o};for(const e of a.issues)e.path?e.path.unshift(i):e.path=[i],n?.push(e);if(n||(n=a.issues),r?.abortEarly)break}else(void 0!==a.output||e in t)&&(p[e]=a.output)}if(i&&(!r?.abortEarly||!n))for(const o in t)if(!(o in e)){const e=t[o],a=i._parse(e,r);if(a.issues){const i={type:"object",input:t,key:o,value:e};for(const e of a.issues)e.path?e.path.unshift(i):e.path=[i],n?.push(e);if(n||(n=a.issues),r?.abortEarly)break}else p[o]=a.output}return n?u(n):l(p,a,r,"object")}}}({id:k,path:k,type:_,baseUrl:k,workspace:_,tool:_});var E,P,j,$;function A(e){const{id:t,path:i,baseUrl:o,tool:a,workspace:s,type:u}=e;if(function(e){return t=e,!w._parse(t,{abortEarly:!0}).issues;var t}(e))return[["id",r(t)],["type",u],["path",m(n.fromString(i))],["base",encodeURIComponent(o)],["workspace",s],["tool",a]].filter((([,e])=>!!e)).map((e=>e.join("="))).join(";")}const x=["_createdAt","_dataset","_id","_key","_originalId","_projectId","_ref","_rev","_strengthenOnPublish","_type","_updatedAt","_weak"];function D(e){if(void 0!==e){if(null===e)return null;if(h(t=e)&&"sanity"===t.$$type$$)return e.value;var t;if(g(e))return e.map((e=>D(e)));if(h(e))return Object.fromEntries(Object.entries(e).map((([e,t])=>x.includes(e)?[e,t]:[e,D(t)])));throw new Error("invalid wrapped value")}}function S(e,t,r,o=[],a=[]){if(void 0!==t)return null===t?null:g(t)?t.map(((t,n)=>S(e,t,r,o.concat(n),a.concat(h(t)&&"_key"in t&&"string"==typeof t._key?{_key:t._key,_index:n}:n)))):h(t)?Object.fromEntries(Object.entries(t).map((([t,n])=>x.includes(t)?[t,n]:[t,S(e,n,r,o.concat(t),a.concat(t))]))):{$$type$$:"sanity",path:n.toString(i(o))||void 0,source:r?v(e,r,o,a):void 0,value:t}}const O=e((function(e,r){const{as:n,children:i,...o}=e;return i?.source?t(n,{...o,"data-sanity":A(i.source),ref:r},i.value):t(n,o,i?.value)})),I=["animate","circle","defs","desc","ellipse","g","image","line","filter","marker","mask","metadata","path","pattern","polygon","polyline","rect","stop","svg","switch","symbol","text","tspan","use","view","clipPath","feBlend","feColorMatrix","feComponentTransfer","feComposite","feConvolveMatrix","feDiffuseLighting","feDisplacementMap","feDistantLight","feDropShadow","feFlood","feFuncA","feFuncB","feFuncG","feFuncR","feGaussianBlur","feImage","feMerge","feMergeNode","feMorphology","feOffset","fePointLight","feSpecularLighting","feSpotLight","feTile","feTurbulence","foreignObject","linearGradient","radialGradient","textPath"];const M=new Proxy({},{get(r,n){if(i=n,s.includes(i)){if(r[n])return r[n];const i=e((function(e,r){return t(O,{as:n,ref:r,...e})}));return i.displayName=`sanity.${n}`,r[n]=i,i}var i;if(function(e){return I.includes(e)}(n)){if(r[n])return r[n];const i=e((function(e,r){return t(O,{as:n,ref:r,...e})}));return i.displayName=`sanity.${n}`,r[n]=i,i}throw new Error(`No such element: ${n}`)}});export{A as encodeSanityNodeData,M as sanity,D as unwrapData,S as wrapData};//# sourceMappingURL=jsx.js.map
+import { forwardRef, createElement } from 'react';
+import { getPublishedId, studioPath, jsonPathToStudioPath, resolveMapping, resolvedKeyedSourcePath } from '@sanity/client/csm';
+const htmlElements = ["a", "abbr", "address", "area", "article", "aside", "audio", "b", "base", "bdi", "bdo", "big", "blockquote", "body", "br", "button", "canvas", "caption", "cite", "code", "col", "colgroup", "data", "datalist", "dd", "del", "details", "dfn", "dialog", "div", "dl", "dt", "em", "embed", "fieldset", "figcaption", "figure", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "iframe", "img", "input", "ins", "kbd", "keygen", "label", "legend", "li", "link", "main", "map", "mark", "menu", "menuitem", "meta", "meter", "nav", "noscript", "object", "ol", "optgroup", "option", "output", "p", "param", "picture", "pre", "progress", "q", "rp", "rt", "ruby", "s", "samp", "script", "section", "select", "small", "source", "span", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "textarea", "tfoot", "th", "thead", "time", "title", "tr", "track", "u", "ul", "var", "video", "wbr", "webview"];
+
+// src/error/flatten/flatten.ts
+
+// src/utils/getIssues/getIssues.ts
+function getIssues(issues) {
+  return {
+    issues
+  };
+}
+
+// src/utils/getOutput/getOutput.ts
+function getOutput(output) {
+  return {
+    output
+  };
+}
+
+// src/utils/executePipe/utils/getIssue/getIssue.ts
+function getIssue(info, issue) {
+  return {
+    reason: info?.reason,
+    validation: issue.validation,
+    origin: info?.origin || "value",
+    message: issue.message,
+    input: issue.input,
+    path: issue.path,
+    abortEarly: info?.abortEarly,
+    abortPipeEarly: info?.abortPipeEarly,
+    skipPipe: info?.skipPipe
+  };
+}
+
+// src/utils/executePipe/utils/getPipeInfo/getPipeInfo.ts
+function getPipeInfo(info, reason) {
+  return {
+    reason,
+    origin: info?.origin,
+    abortEarly: info?.abortEarly,
+    abortPipeEarly: info?.abortPipeEarly,
+    skipPipe: info?.skipPipe
+  };
+}
+
+// src/utils/executePipe/executePipe.ts
+function executePipe(input, pipe, parseInfo, reason) {
+  if (!pipe || !pipe.length || parseInfo?.skipPipe) {
+    return getOutput(input);
+  }
+  let pipeInfo;
+  let issues;
+  let output = input;
+  for (const action of pipe) {
+    const result = action._parse(output);
+    if (result.issues) {
+      pipeInfo = pipeInfo || getPipeInfo(parseInfo, reason);
+      for (const issueInfo of result.issues) {
+        const issue = getIssue(pipeInfo, issueInfo);
+        issues ? issues.push(issue) : issues = [issue];
+      }
+      if (pipeInfo.abortEarly || pipeInfo.abortPipeEarly) {
+        break;
+      }
+    } else {
+      output = result.output;
+    }
+  }
+  return issues ? getIssues(issues) : getOutput(output);
+}
+
+// src/utils/getDefaultArgs/getDefaultArgs.ts
+function getDefaultArgs(arg1, arg2) {
+  return Array.isArray(arg1) ? [void 0, arg1] : [arg1, arg2];
+}
+
+// src/utils/getErrorMessage/getErrorMessage.ts
+function getErrorMessage(message) {
+  return typeof message === "function" ? message() : message;
+}
+
+// src/utils/getPipeIssues/getPipeIssues.ts
+function getPipeIssues(validation, message, input, requirement) {
+  return getIssues([{
+    validation,
+    message: getErrorMessage(message),
+    input,
+    requirement
+  }]);
+}
+
+// src/utils/getRestAndDefaultArgs/getRestAndDefaultArgs.ts
+function getRestAndDefaultArgs(arg1, arg2, arg3) {
+  if (!arg1 || typeof arg1 === "object" && !Array.isArray(arg1)) {
+    const [error2, pipe2] = getDefaultArgs(arg2, arg3);
+    return [arg1, error2, pipe2];
+  }
+  const [error, pipe] = getDefaultArgs(arg1, arg2);
+  return [void 0, error, pipe];
+}
+
+// src/utils/getSchemaIssues/getSchemaIssues.ts
+function getSchemaIssues(info, reason, validation, message, input, issues) {
+  return {
+    issues: [{
+      reason,
+      validation,
+      origin: info?.origin || "value",
+      message: getErrorMessage(message),
+      input,
+      issues,
+      abortEarly: info?.abortEarly,
+      abortPipeEarly: info?.abortPipeEarly,
+      skipPipe: info?.skipPipe
+    }]
+  };
+}
+
+// src/methods/getDefault/getDefault.ts
+function getDefault(schema) {
+  return typeof schema.default === "function" ? schema.default() : schema.default;
+}
+
+// src/methods/is/is.ts
+function is(schema, input) {
+  return !schema._parse(input, {
+    abortEarly: true
+  }).issues;
+}
+
+// src/schemas/object/object.ts
+function object(entries, arg2, arg3, arg4) {
+  const [rest, message = "Invalid type", pipe] = getRestAndDefaultArgs(arg2, arg3, arg4);
+  let cachedEntries;
+  return {
+    type: "object",
+    async: false,
+    entries,
+    rest,
+    message,
+    pipe,
+    _parse(input, info) {
+      if (!input || typeof input !== "object") {
+        return getSchemaIssues(info, "type", "object", this.message, input);
+      }
+      cachedEntries = cachedEntries || Object.entries(this.entries);
+      let issues;
+      const output = {};
+      for (const [key, schema] of cachedEntries) {
+        const value2 = input[key];
+        const result = schema._parse(value2, info);
+        if (result.issues) {
+          const pathItem = {
+            type: "object",
+            input,
+            key,
+            value: value2
+          };
+          for (const issue of result.issues) {
+            if (issue.path) {
+              issue.path.unshift(pathItem);
+            } else {
+              issue.path = [pathItem];
+            }
+            issues?.push(issue);
+          }
+          if (!issues) {
+            issues = result.issues;
+          }
+          if (info?.abortEarly) {
+            break;
+          }
+        } else if (result.output !== void 0 || key in input) {
+          output[key] = result.output;
+        }
+      }
+      if (this.rest && !(info?.abortEarly && issues)) {
+        for (const key in input) {
+          if (!(key in this.entries)) {
+            const value2 = input[key];
+            const result = this.rest._parse(value2, info);
+            if (result.issues) {
+              const pathItem = {
+                type: "object",
+                input,
+                key,
+                value: value2
+              };
+              for (const issue of result.issues) {
+                if (issue.path) {
+                  issue.path.unshift(pathItem);
+                } else {
+                  issue.path = [pathItem];
+                }
+                issues?.push(issue);
+              }
+              if (!issues) {
+                issues = result.issues;
+              }
+              if (info?.abortEarly) {
+                break;
+              }
+            } else {
+              output[key] = result.output;
+            }
+          }
+        }
+      }
+      return issues ? getIssues(issues) : executePipe(output, this.pipe, info, "object");
+    }
+  };
+}
+
+// src/schemas/optional/optional.ts
+function optional(wrapped, default_) {
+  return {
+    type: "optional",
+    async: false,
+    wrapped,
+    default: default_,
+    _parse(input, info) {
+      if (input === void 0) {
+        const override = getDefault(this);
+        if (override === void 0) {
+          return getOutput(input);
+        }
+        input = override;
+      }
+      return this.wrapped._parse(input, info);
+    }
+  };
+}
+
+// src/schemas/string/string.ts
+function string(arg1, arg2) {
+  const [message = "Invalid type", pipe] = getDefaultArgs(arg1, arg2);
+  return {
+    type: "string",
+    async: false,
+    message,
+    pipe,
+    _parse(input, info) {
+      if (typeof input !== "string") {
+        return getSchemaIssues(info, "type", "string", this.message, input);
+      }
+      return executePipe(input, this.pipe, info, "string");
+    }
+  };
+}
+
+// src/validations/minLength/minLength.ts
+function minLength(requirement, message = "Invalid length") {
+  return {
+    type: "min_length",
+    async: false,
+    message,
+    requirement,
+    _parse(input) {
+      return input.length < this.requirement ? getPipeIssues(this.type, this.message, input, this.requirement) : getOutput(input);
+    }
+  };
+}
+function isRecord(value) {
+  return typeof value === "object" && value !== null && !Array.isArray(value);
+}
+function isArray(value) {
+  return value !== null && Array.isArray(value);
+}
+function pathToUrlString(path) {
+  let str = "";
+  for (const segment of path) {
+    if (typeof segment === "string") {
+      if (str) str += ".";
+      str += segment;
+      continue;
+    }
+    if (typeof segment === "number") {
+      if (str) str += ":";
+      str += `${segment}`;
+      continue;
+    }
+    if (isArray(segment)) {
+      if (str) str += ":";
+      str += `${segment.join(",")}}`;
+      continue;
+    }
+    if (segment._key) {
+      if (str) str += ":";
+      str += `${segment._key}`;
+      continue;
+    }
+  }
+  return str;
+}
+function resolveSanityNode(context, csm, resultPath, keyedResultPath) {
+  const {
+    mapping,
+    pathSuffix
+  } = resolveMapping(resultPath, csm) || {};
+  if (!mapping) {
+    return void 0;
+  }
+  if (mapping.source.type === "literal") {
+    return void 0;
+  }
+  if (mapping.source.type === "unknown") {
+    return void 0;
+  }
+  const sourceDoc = csm.documents[mapping.source.document];
+  const sourceBasePath = csm.paths[mapping.source.path];
+  if (sourceDoc && sourceBasePath) {
+    return {
+      baseUrl: context.baseUrl,
+      workspace: context.workspace,
+      tool: context.tool,
+      type: sourceDoc._type,
+      id: getPublishedId(sourceDoc._id),
+      path: studioPath.toString(jsonPathToStudioPath(resolvedKeyedSourcePath({
+        keyedResultPath,
+        pathSuffix,
+        sourceBasePath
+      })))
+    };
+  }
+  return void 0;
+}
+const lengthyStr = string([minLength(1)]);
+const optionalLengthyStr = optional(lengthyStr);
+const sanityNodeSchema = object({
+  id: lengthyStr,
+  path: lengthyStr,
+  type: optionalLengthyStr,
+  baseUrl: lengthyStr,
+  workspace: optionalLengthyStr,
+  tool: optionalLengthyStr
+});
+function isValidSanityNode(node) {
+  return is(sanityNodeSchema, node);
+}
+function encodeSanityNodeData(node) {
+  const {
+    id: _id,
+    path,
+    baseUrl,
+    tool,
+    workspace,
+    type
+  } = node;
+  if (!isValidSanityNode(node)) {
+    return void 0;
+  }
+  const parts = [["id", getPublishedId(_id)], ["type", type], ["path", pathToUrlString(studioPath.fromString(path))], ["base", encodeURIComponent(baseUrl)], ["workspace", workspace], ["tool", tool]];
+  return parts.filter(([, value]) => !!value).map(part => part.join("=")).join(";");
+}
+const SANITY_KEYS = ["_createdAt", "_dataset", "_id", "_key", "_originalId", "_projectId", "_ref", "_rev", "_strengthenOnPublish", "_type", "_updatedAt", "_weak"];
+function isSourceNode(t) {
+  return isRecord(t) && t.$$type$$ === "sanity";
+}
+function unwrapData(wrapper) {
+  if (wrapper === void 0) {
+    return void 0;
+  }
+  if (wrapper === null) {
+    return null;
+  }
+  if (isSourceNode(wrapper)) {
+    return wrapper.value;
+  }
+  if (isArray(wrapper)) {
+    return wrapper.map(item => unwrapData(item));
+  }
+  if (isRecord(wrapper)) {
+    return Object.fromEntries(Object.entries(wrapper).map(([k, v]) => SANITY_KEYS.includes(k) ? [k, v] : [k, unwrapData(v)]));
+  }
+  throw new Error("invalid wrapped value");
+}
+function wrapData(context, value, sourceMap, resultPath = [], keyedResultPath = []) {
+  if (value === void 0) {
+    return void 0;
+  }
+  if (value === null) {
+    return null;
+  }
+  if (isArray(value)) {
+    return value.map((t, idx) => wrapData(context, t, sourceMap, resultPath.concat(idx), keyedResultPath.concat(isRecord(t) && "_key" in t && typeof t._key === "string" ? {
+      _key: t._key,
+      _index: idx
+    } : idx)));
+  }
+  if (isRecord(value)) {
+    return Object.fromEntries(Object.entries(value).map(([k, v]) => SANITY_KEYS.includes(k) ? [k, v] : [k, wrapData(context, v, sourceMap, resultPath.concat(k), keyedResultPath.concat(k))]));
+  }
+  return {
+    $$type$$: "sanity",
+    path: studioPath.toString(jsonPathToStudioPath(resultPath)) || void 0,
+    source: sourceMap ? resolveSanityNode(context, sourceMap, resultPath, keyedResultPath) : void 0,
+    value
+  };
+}
+const SanityElement = forwardRef(function SanityElement2(props, ref) {
+  const {
+    as,
+    children: node,
+    ...restProps
+  } = props;
+  if (node?.source) {
+    return createElement(as, {
+      ...restProps,
+      "data-sanity": encodeSanityNodeData(node.source),
+      ref
+    }, node.value);
+  }
+  return createElement(as, restProps, node?.value);
+});
+const svgElements = ["animate", "circle", "defs", "desc", "ellipse", "g", "image", "line", "filter", "marker", "mask", "metadata", "path", "pattern", "polygon", "polyline", "rect", "stop", "svg", "switch", "symbol", "text", "tspan", "use", "view", "clipPath", "feBlend", "feColorMatrix", "feComponentTransfer", "feComposite", "feConvolveMatrix", "feDiffuseLighting", "feDisplacementMap", "feDistantLight", "feDropShadow", "feFlood", "feFuncA", "feFuncB", "feFuncG", "feFuncR", "feGaussianBlur", "feImage", "feMerge", "feMergeNode", "feMorphology", "feOffset", "fePointLight", "feSpecularLighting", "feSpotLight", "feTile", "feTurbulence", "foreignObject", "linearGradient", "radialGradient", "textPath"];
+function isHTMLElement(name) {
+  return htmlElements.includes(name);
+}
+function isSVGElement(name) {
+  return svgElements.includes(name);
+}
+const sanity = new Proxy({}, {
+  get(target, prop) {
+    if (isHTMLElement(prop)) {
+      if (target[prop]) return target[prop];
+      const SanityComponent = forwardRef(function SanityComponent2(props, ref) {
+        return createElement(SanityElement, {
+          as: prop,
+          ref,
+          ...props
+        });
+      });
+      SanityComponent.displayName = `sanity.${prop}`;
+      target[prop] = SanityComponent;
+      return SanityComponent;
+    }
+    if (isSVGElement(prop)) {
+      if (target[prop]) return target[prop];
+      const SanityComponent = forwardRef(function SanityComponent2(props, ref) {
+        return createElement(SanityElement, {
+          as: prop,
+          ref,
+          ...props
+        });
+      });
+      SanityComponent.displayName = `sanity.${prop}`;
+      target[prop] = SanityComponent;
+      return SanityComponent;
+    }
+    throw new Error(`No such element: ${prop}`);
+  }
+});
+export { encodeSanityNodeData, sanity, unwrapData, wrapData };
+//# sourceMappingURL=jsx.js.map
diff --git a/dist/jsx.js.map b/dist/jsx.js.map
index cc6f2e08b9123edda71d28831e9947e1be3d1959..b3c4319b77ea98abac3da3ee4985e80b4686dfe0 100644
--- a/dist/jsx.js.map
+++ b/dist/jsx.js.map
@@ -1 +1 @@
-{"version":3,"file":"jsx.js","sources":["../src/jsx/html.ts","../../../node_modules/.pnpm/valibot@0.20.1/node_modules/valibot/dist/index.js","../../visual-editing-helpers/dist/_chunks/urlStringToPath-FefM00gz.js","../../visual-editing-helpers/dist/csm.js","../src/jsx/SanityElement.tsx","../src/jsx/svg.ts","../src/jsx/jsx.ts"],"sourcesContent":["export const htmlElements = [\n  'a',\n  'abbr',\n  'address',\n  'area',\n  'article',\n  'aside',\n  'audio',\n  'b',\n  'base',\n  'bdi',\n  'bdo',\n  'big',\n  'blockquote',\n  'body',\n  'br',\n  'button',\n  'canvas',\n  'caption',\n  'cite',\n  'code',\n  'col',\n  'colgroup',\n  'data',\n  'datalist',\n  'dd',\n  'del',\n  'details',\n  'dfn',\n  'dialog',\n  'div',\n  'dl',\n  'dt',\n  'em',\n  'embed',\n  'fieldset',\n  'figcaption',\n  'figure',\n  'footer',\n  'form',\n  'h1',\n  'h2',\n  'h3',\n  'h4',\n  'h5',\n  'h6',\n  'head',\n  'header',\n  'hgroup',\n  'hr',\n  'html',\n  'i',\n  'iframe',\n  'img',\n  'input',\n  'ins',\n  'kbd',\n  'keygen',\n  'label',\n  'legend',\n  'li',\n  'link',\n  'main',\n  'map',\n  'mark',\n  'menu',\n  'menuitem',\n  'meta',\n  'meter',\n  'nav',\n  'noscript',\n  'object',\n  'ol',\n  'optgroup',\n  'option',\n  'output',\n  'p',\n  'param',\n  'picture',\n  'pre',\n  'progress',\n  'q',\n  'rp',\n  'rt',\n  'ruby',\n  's',\n  'samp',\n  'script',\n  'section',\n  'select',\n  'small',\n  'source',\n  'span',\n  'strong',\n  'style',\n  'sub',\n  'summary',\n  'sup',\n  'table',\n  'tbody',\n  'td',\n  'textarea',\n  'tfoot',\n  'th',\n  'thead',\n  'time',\n  'title',\n  'tr',\n  'track',\n  'u',\n  'ul',\n  'var',\n  'video',\n  'wbr',\n  'webview',\n] as const\n","// src/error/flatten/flatten.ts\nfunction flatten(arg1) {\n  return (Array.isArray(arg1) ? arg1 : arg1.issues).reduce(\n    (flatErrors, issue) => {\n      if (issue.path) {\n        if (issue.path.every(\n          ({ key }) => typeof key === \"string\" || typeof key === \"number\"\n        )) {\n          const path = issue.path.map(({ key }) => key).join(\".\");\n          if (flatErrors.nested[path]) {\n            flatErrors.nested[path].push(issue.message);\n          } else {\n            flatErrors.nested[path] = [issue.message];\n          }\n        }\n      } else {\n        if (flatErrors.root) {\n          flatErrors.root.push(issue.message);\n        } else {\n          flatErrors.root = [issue.message];\n        }\n      }\n      return flatErrors;\n    },\n    { nested: {} }\n  );\n}\n\n// src/error/ValiError/ValiError.ts\nvar ValiError = class extends Error {\n  issues;\n  /**\n   * Creates a Valibot error with useful information.\n   *\n   * @param issues The error issues.\n   */\n  constructor(issues) {\n    super(issues[0].message);\n    this.name = \"ValiError\";\n    this.issues = issues;\n  }\n};\n\n// src/methods/brand/brand.ts\nvar BrandSymbol = Symbol(\"brand\");\nfunction brand(schema, name) {\n  return schema;\n}\n\n// src/methods/coerce/coerce.ts\nfunction coerce(schema, action) {\n  return {\n    ...schema,\n    /**\n     * Parses unknown input based on its schema.\n     *\n     * @param input The input to be parsed.\n     * @param info The parse info.\n     *\n     * @returns The parsed output.\n     */\n    _parse(input, info) {\n      return schema._parse(action(input), info);\n    }\n  };\n}\n\n// src/methods/coerce/coerceAsync.ts\nfunction coerceAsync(schema, action) {\n  return {\n    ...schema,\n    /**\n     * Parses unknown input based on its schema.\n     *\n     * @param input The input to be parsed.\n     * @param info The parse info.\n     *\n     * @returns The parsed output.\n     */\n    async _parse(input, info) {\n      return schema._parse(await action(input), info);\n    }\n  };\n}\n\n// src/utils/getIssues/getIssues.ts\nfunction getIssues(issues) {\n  return { issues };\n}\n\n// src/utils/getOutput/getOutput.ts\nfunction getOutput(output) {\n  return { output };\n}\n\n// src/utils/executePipe/utils/getIssue/getIssue.ts\nfunction getIssue(info, issue) {\n  return {\n    reason: info?.reason,\n    validation: issue.validation,\n    origin: info?.origin || \"value\",\n    message: issue.message,\n    input: issue.input,\n    path: issue.path,\n    abortEarly: info?.abortEarly,\n    abortPipeEarly: info?.abortPipeEarly,\n    skipPipe: info?.skipPipe\n  };\n}\n\n// src/utils/executePipe/utils/getPipeInfo/getPipeInfo.ts\nfunction getPipeInfo(info, reason) {\n  return {\n    reason,\n    origin: info?.origin,\n    abortEarly: info?.abortEarly,\n    abortPipeEarly: info?.abortPipeEarly,\n    skipPipe: info?.skipPipe\n  };\n}\n\n// src/utils/executePipe/executePipe.ts\nfunction executePipe(input, pipe, parseInfo, reason) {\n  if (!pipe || !pipe.length || parseInfo?.skipPipe) {\n    return getOutput(input);\n  }\n  let pipeInfo;\n  let issues;\n  let output = input;\n  for (const action of pipe) {\n    const result = action(output);\n    if (result.issues) {\n      pipeInfo = pipeInfo || getPipeInfo(parseInfo, reason);\n      for (const issueInfo of result.issues) {\n        const issue = getIssue(pipeInfo, issueInfo);\n        issues ? issues.push(issue) : issues = [issue];\n      }\n      if (pipeInfo.abortEarly || pipeInfo.abortPipeEarly) {\n        break;\n      }\n    } else {\n      output = result.output;\n    }\n  }\n  return issues ? getIssues(issues) : getOutput(output);\n}\n\n// src/utils/executePipe/executePipeAsync.ts\nasync function executePipeAsync(input, pipe, parseInfo, reason) {\n  if (!pipe || !pipe.length || parseInfo?.skipPipe) {\n    return getOutput(input);\n  }\n  let pipeInfo;\n  let issues;\n  let output = input;\n  for (const action of pipe) {\n    const result = await action(output);\n    if (result.issues) {\n      pipeInfo = pipeInfo || getPipeInfo(parseInfo, reason);\n      for (const issueInfo of result.issues) {\n        const issue = getIssue(pipeInfo, issueInfo);\n        issues ? issues.push(issue) : issues = [issue];\n      }\n      if (pipeInfo.abortEarly || pipeInfo.abortPipeEarly) {\n        break;\n      }\n    } else {\n      output = result.output;\n    }\n  }\n  return issues ? getIssues(issues) : getOutput(output);\n}\n\n// src/utils/getDefaultArgs/getDefaultArgs.ts\nfunction getDefaultArgs(arg1, arg2) {\n  return Array.isArray(arg1) ? [void 0, arg1] : [arg1, arg2];\n}\n\n// src/utils/getErrorMessage/getErrorMessage.ts\nfunction getErrorMessage(error) {\n  return typeof error === \"function\" ? error() : error;\n}\n\n// src/utils/getPipeIssues/getPipeIssues.ts\nfunction getPipeIssues(validation, error, input) {\n  return getIssues([\n    {\n      validation,\n      message: getErrorMessage(error),\n      input\n    }\n  ]);\n}\n\n// src/utils/getRestAndDefaultArgs/getRestAndDefaultArgs.ts\nfunction getRestAndDefaultArgs(arg1, arg2, arg3) {\n  if (!arg1 || typeof arg1 === \"object\" && !Array.isArray(arg1)) {\n    const [error2, pipe2] = getDefaultArgs(arg2, arg3);\n    return [arg1, error2, pipe2];\n  }\n  const [error, pipe] = getDefaultArgs(\n    arg1,\n    arg2\n  );\n  return [void 0, error, pipe];\n}\n\n// src/utils/getSchemaIssues/getSchemaIssues.ts\nfunction getSchemaIssues(info, reason, validation, error, input, issues) {\n  return {\n    issues: [\n      {\n        reason,\n        validation,\n        origin: info?.origin || \"value\",\n        message: getErrorMessage(error),\n        input,\n        issues,\n        abortEarly: info?.abortEarly,\n        abortPipeEarly: info?.abortPipeEarly,\n        skipPipe: info?.skipPipe\n      }\n    ]\n  };\n}\n\n// src/utils/isLuhnAlgo/isLuhnAlgo.ts\nvar NON_DIGIT_REGEX = /\\D/gu;\nfunction isLuhnAlgo(input) {\n  const number2 = input.replaceAll(NON_DIGIT_REGEX, \"\");\n  let length2 = number2.length;\n  let bit = 1;\n  let sum = 0;\n  while (length2) {\n    const value2 = +number2[--length2];\n    bit ^= 1;\n    sum += bit ? [0, 2, 4, 6, 8, 1, 3, 5, 7, 9][value2] : value2;\n  }\n  return sum % 10 === 0;\n}\n\n// src/methods/fallback/fallback.ts\nfunction fallback(schema, fallback2) {\n  return {\n    ...schema,\n    /**\n     * Returns the fallback value.\n     */\n    getFallback(info) {\n      return typeof fallback2 === \"function\" ? fallback2(info) : fallback2;\n    },\n    /**\n     * Parses unknown input based on its schema.\n     *\n     * @param input The input to be parsed.\n     * @param info The parse info.\n     *\n     * @returns The parsed output.\n     */\n    _parse(input, info) {\n      const result = schema._parse(input, info);\n      return getOutput(\n        result.issues ? this.getFallback({ input, issues: result.issues }) : result.output\n      );\n    }\n  };\n}\n\n// src/methods/fallback/fallbackAsync.ts\nfunction fallbackAsync(schema, fallback2) {\n  return {\n    ...schema,\n    /**\n     * Returns the default value.\n     */\n    async getFallback(info) {\n      return typeof fallback2 === \"function\" ? await fallback2(info) : fallback2;\n    },\n    /**\n     * Parses unknown input based on its schema.\n     *\n     * @param input The input to be parsed.\n     * @param info The parse info.\n     *\n     * @returns The parsed output.\n     */\n    async _parse(input, info) {\n      const result = await schema._parse(input, info);\n      return getOutput(\n        result.issues ? await this.getFallback({ input, issues: result.issues }) : result.output\n      );\n    }\n  };\n}\n\n// src/methods/getDefault/getDefault.ts\nfunction getDefault(schema) {\n  return schema.getDefault?.();\n}\n\n// src/methods/getDefault/getDefaultAsync.ts\nasync function getDefaultAsync(schema) {\n  return schema.getDefault?.();\n}\n\n// src/methods/getDefaults/getDefaults.ts\nfunction getDefaults(schema) {\n  let defaults;\n  if (schema.getDefault) {\n    defaults = schema.getDefault();\n  } else if (\"type\" in schema) {\n    if (schema.type === \"object\") {\n      defaults = {};\n      for (const key in schema.entries) {\n        defaults[key] = getDefaults(schema.entries[key]);\n      }\n    } else if (schema.type === \"tuple\") {\n      defaults = [];\n      for (let key = 0; key < schema.items.length; key++) {\n        defaults.push(getDefaults(schema.items[key]));\n      }\n    }\n  }\n  return defaults;\n}\n\n// src/methods/getDefaults/getDefaultsAsync.ts\nasync function getDefaultsAsync(schema) {\n  let defaults;\n  if (schema.getDefault) {\n    defaults = await schema.getDefault();\n  } else if (\"type\" in schema) {\n    if (schema.type === \"object\") {\n      defaults = {};\n      for (const key in schema.entries) {\n        defaults[key] = await getDefaultsAsync(schema.entries[key]);\n      }\n    } else if (schema.type === \"tuple\") {\n      defaults = [];\n      for (let key = 0; key < schema.items.length; key++) {\n        defaults.push(await getDefaultsAsync(schema.items[key]));\n      }\n    }\n  }\n  return defaults;\n}\n\n// src/methods/getFallback/getFallback.ts\nfunction getFallback(schema, info) {\n  return schema.getFallback?.(info);\n}\n\n// src/methods/getFallback/getFallbackAsync.ts\nasync function getFallbackAsync(schema, info) {\n  return schema.getFallback?.(info);\n}\n\n// src/methods/getFallbacks/getFallbacks.ts\nfunction getFallbacks(schema) {\n  let fallbacks;\n  if (schema.getFallback) {\n    fallbacks = schema.getFallback();\n  } else if (\"type\" in schema) {\n    if (schema.type === \"object\") {\n      fallbacks = {};\n      for (const key in schema.entries) {\n        fallbacks[key] = getFallbacks(schema.entries[key]);\n      }\n    } else if (schema.type === \"tuple\") {\n      fallbacks = [];\n      for (let key = 0; key < schema.items.length; key++) {\n        fallbacks.push(getFallbacks(schema.items[key]));\n      }\n    }\n  }\n  return fallbacks;\n}\n\n// src/methods/getFallbacks/getFallbacksAsync.ts\nasync function getFallbacksAsync(schema) {\n  let fallbacks;\n  if (schema.getFallback) {\n    fallbacks = await schema.getFallback();\n  } else if (\"type\" in schema) {\n    if (schema.type === \"object\") {\n      fallbacks = {};\n      await Promise.all(\n        Object.entries(schema.entries).map(async ([key, schema2]) => {\n          fallbacks[key] = await getFallbacksAsync(schema2);\n        })\n      );\n    } else if (schema.type === \"tuple\") {\n      fallbacks = await Promise.all(\n        schema.items.map((schema2) => getFallbacksAsync(schema2))\n      );\n    }\n  }\n  return fallbacks;\n}\n\n// src/methods/is/is.ts\nfunction is(schema, input) {\n  return !schema._parse(input, { abortEarly: true }).issues;\n}\n\n// src/schemas/any/any.ts\nfunction any(pipe = []) {\n  return {\n    /**\n     * The schema type.\n     */\n    type: \"any\",\n    /**\n     * Whether it's async.\n     */\n    async: false,\n    /**\n     * Parses unknown input based on its schema.\n     *\n     * @param input The input to be parsed.\n     * @param info The parse info.\n     *\n     * @returns The parsed output.\n     */\n    _parse(input, info) {\n      return executePipe(input, pipe, info, \"any\");\n    }\n  };\n}\n\n// src/schemas/any/anyAsync.ts\nfunction anyAsync(pipe = []) {\n  return {\n    /**\n     * The schema type.\n     */\n    type: \"any\",\n    /**\n     * Whether it's async.\n     */\n    async: true,\n    /**\n     * Parses unknown input based on its schema.\n     *\n     * @param input The input to be parsed.\n     * @param info The parse info.\n     *\n     * @returns The parsed output.\n     */\n    async _parse(input, info) {\n      return executePipeAsync(input, pipe, info, \"any\");\n    }\n  };\n}\n\n// src/schemas/array/array.ts\nfunction array(item, arg2, arg3) {\n  const [error, pipe] = getDefaultArgs(arg2, arg3);\n  return {\n    /**\n     * The schema type.\n     */\n    type: \"array\",\n    /**\n     * The item schema.\n     */\n    item,\n    /**\n     * Whether it's async.\n     */\n    async: false,\n    /**\n     * Parses unknown input based on its schema.\n     *\n     * @param input The input to be parsed.\n     * @param info The parse info.\n     *\n     * @returns The parsed output.\n     */\n    _parse(input, info) {\n      if (!Array.isArray(input)) {\n        return getSchemaIssues(\n          info,\n          \"type\",\n          \"array\",\n          error || \"Invalid type\",\n          input\n        );\n      }\n      let issues;\n      const output = [];\n      for (let key = 0; key < input.length; key++) {\n        const value2 = input[key];\n        const result = item._parse(value2, info);\n        if (result.issues) {\n          const pathItem = {\n            type: \"array\",\n            input,\n            key,\n            value: value2\n          };\n          for (const issue of result.issues) {\n            if (issue.path) {\n              issue.path.unshift(pathItem);\n            } else {\n              issue.path = [pathItem];\n            }\n            issues?.push(issue);\n          }\n          if (!issues) {\n            issues = result.issues;\n          }\n          if (info?.abortEarly) {\n            break;\n          }\n        } else {\n          output.push(result.output);\n        }\n      }\n      return issues ? getIssues(issues) : executePipe(output, pipe, info, \"array\");\n    }\n  };\n}\n\n// src/schemas/array/arrayAsync.ts\nfunction arrayAsync(item, arg2, arg3) {\n  const [error, pipe] = getDefaultArgs(arg2, arg3);\n  return {\n    /**\n     * The schema type.\n     */\n    type: \"array\",\n    /**\n     * The item schema.\n     */\n    item,\n    /**\n     * Whether it's async.\n     */\n    async: true,\n    /**\n     * Parses unknown input based on its schema.\n     *\n     * @param input The input to be parsed.\n     * @param info The parse info.\n     *\n     * @returns The parsed output.\n     */\n    async _parse(input, info) {\n      if (!Array.isArray(input)) {\n        return getSchemaIssues(\n          info,\n          \"type\",\n          \"array\",\n          error || \"Invalid type\",\n          input\n        );\n      }\n      let issues;\n      const output = [];\n      await Promise.all(\n        input.map(async (value2, key) => {\n          if (!(info?.abortEarly && issues)) {\n            const result = await item._parse(value2, info);\n            if (!(info?.abortEarly && issues)) {\n              if (result.issues) {\n                const pathItem = {\n                  type: \"array\",\n                  input,\n                  key,\n                  value: value2\n                };\n                for (const issue of result.issues) {\n                  if (issue.path) {\n                    issue.path.unshift(pathItem);\n                  } else {\n                    issue.path = [pathItem];\n                  }\n                  issues?.push(issue);\n                }\n                if (!issues) {\n                  issues = result.issues;\n                }\n                if (info?.abortEarly) {\n                  throw null;\n                }\n              } else {\n                output[key] = result.output;\n              }\n            }\n          }\n        })\n      ).catch(() => null);\n      return issues ? getIssues(issues) : executePipeAsync(output, pipe, info, \"array\");\n    }\n  };\n}\n\n// src/schemas/bigint/bigint.ts\nfunction bigint(arg1, arg2) {\n  const [error, pipe] = getDefaultArgs(arg1, arg2);\n  return {\n    /**\n     * The schema type.\n     */\n    type: \"bigint\",\n    /**\n     * Whether it's async.\n     */\n    async: false,\n    /**\n     * Parses unknown input based on its schema.\n     *\n     * @param input The input to be parsed.\n     * @param info The parse info.\n     *\n     * @returns The parsed output.\n     */\n    _parse(input, info) {\n      if (typeof input !== \"bigint\") {\n        return getSchemaIssues(\n          info,\n          \"type\",\n          \"bigint\",\n          error || \"Invalid type\",\n          input\n        );\n      }\n      return executePipe(input, pipe, info, \"bigint\");\n    }\n  };\n}\n\n// src/schemas/bigint/bigintAsync.ts\nfunction bigintAsync(arg1, arg2) {\n  const [error, pipe] = getDefaultArgs(arg1, arg2);\n  return {\n    /**\n     * The schema type.\n     */\n    type: \"bigint\",\n    /**\n     * Whether it's async.\n     */\n    async: true,\n    /**\n     * Parses unknown input based on its schema.\n     *\n     * @param input The input to be parsed.\n     * @param info The parse info.\n     *\n     * @returns The parsed output.\n     */\n    async _parse(input, info) {\n      if (typeof input !== \"bigint\") {\n        return getSchemaIssues(\n          info,\n          \"type\",\n          \"bigint\",\n          error || \"Invalid type\",\n          input\n        );\n      }\n      return executePipeAsync(input, pipe, info, \"bigint\");\n    }\n  };\n}\n\n// src/schemas/blob/blob.ts\nfunction blob(arg1, arg2) {\n  const [error, pipe] = getDefaultArgs(arg1, arg2);\n  return {\n    /**\n     * The schema type.\n     */\n    type: \"blob\",\n    /**\n     * Whether it's async.\n     */\n    async: false,\n    /**\n     * Parses unknown input based on its schema.\n     *\n     * @param input The input to be parsed.\n     * @param info The parse info.\n     *\n     * @returns The parsed output.\n     */\n    _parse(input, info) {\n      if (!(input instanceof Blob)) {\n        return getSchemaIssues(\n          info,\n          \"type\",\n          \"blob\",\n          error || \"Invalid type\",\n          input\n        );\n      }\n      return executePipe(input, pipe, info, \"blob\");\n    }\n  };\n}\n\n// src/schemas/blob/blobAsync.ts\nfunction blobAsync(arg1, arg2) {\n  const [error, pipe] = getDefaultArgs(arg1, arg2);\n  return {\n    /**\n     * The schema type.\n     */\n    type: \"blob\",\n    /**\n     * Whether it's async.\n     */\n    async: true,\n    /**\n     * Parses unknown input based on its schema.\n     *\n     * @param input The input to be parsed.\n     * @param info The parse info.\n     *\n     * @returns The parsed output.\n     */\n    async _parse(input, info) {\n      if (!(input instanceof Blob)) {\n        return getSchemaIssues(\n          info,\n          \"type\",\n          \"blob\",\n          error || \"Invalid type\",\n          input\n        );\n      }\n      return executePipeAsync(input, pipe, info, \"blob\");\n    }\n  };\n}\n\n// src/schemas/boolean/boolean.ts\nfunction boolean(arg1, arg2) {\n  const [error, pipe] = getDefaultArgs(arg1, arg2);\n  return {\n    /**\n     * The schema type.\n     */\n    type: \"boolean\",\n    /**\n     * Whether it's async.\n     */\n    async: false,\n    /**\n     * Parses unknown input based on its schema.\n     *\n     * @param input The input to be parsed.\n     * @param info The parse info.\n     *\n     * @returns The parsed output.\n     */\n    _parse(input, info) {\n      if (typeof input !== \"boolean\") {\n        return getSchemaIssues(\n          info,\n          \"type\",\n          \"boolean\",\n          error || \"Invalid type\",\n          input\n        );\n      }\n      return executePipe(input, pipe, info, \"boolean\");\n    }\n  };\n}\n\n// src/schemas/boolean/booleanAsync.ts\nfunction booleanAsync(arg1, arg2) {\n  const [error, pipe] = getDefaultArgs(arg1, arg2);\n  return {\n    /**\n     * The schema type.\n     */\n    type: \"boolean\",\n    /**\n     * Whether it's async.\n     */\n    async: true,\n    /**\n     * Parses unknown input based on its schema.\n     *\n     * @param input The input to be parsed.\n     * @param info The parse info.\n     *\n     * @returns The parsed output.\n     */\n    async _parse(input, info) {\n      if (typeof input !== \"boolean\") {\n        return getSchemaIssues(\n          info,\n          \"type\",\n          \"boolean\",\n          error || \"Invalid type\",\n          input\n        );\n      }\n      return executePipeAsync(input, pipe, info, \"boolean\");\n    }\n  };\n}\n\n// src/schemas/date/date.ts\nfunction date(arg1, arg2) {\n  const [error, pipe] = getDefaultArgs(arg1, arg2);\n  return {\n    /**\n     * The schema type.\n     */\n    type: \"date\",\n    /**\n     * Whether it's async.\n     */\n    async: false,\n    /**\n     * Parses unknown input based on its schema.\n     *\n     * @param input The input to be parsed.\n     * @param info The parse info.\n     *\n     * @returns The parsed output.\n     */\n    _parse(input, info) {\n      if (!(input instanceof Date) || isNaN(input.getTime())) {\n        return getSchemaIssues(\n          info,\n          \"type\",\n          \"date\",\n          error || \"Invalid type\",\n          input\n        );\n      }\n      return executePipe(input, pipe, info, \"date\");\n    }\n  };\n}\n\n// src/schemas/date/dateAsync.ts\nfunction dateAsync(arg1, arg2) {\n  const [error, pipe] = getDefaultArgs(arg1, arg2);\n  return {\n    /**\n     * The schema type.\n     */\n    type: \"date\",\n    /**\n     * Whether it's async.\n     */\n    async: true,\n    /**\n     * Parses unknown input based on its schema.\n     *\n     * @param input The input to be parsed.\n     * @param info The parse info.\n     *\n     * @returns The parsed output.\n     */\n    async _parse(input, info) {\n      if (!(input instanceof Date) || isNaN(input.getTime())) {\n        return getSchemaIssues(\n          info,\n          \"type\",\n          \"date\",\n          error || \"Invalid type\",\n          input\n        );\n      }\n      return executePipeAsync(input, pipe, info, \"date\");\n    }\n  };\n}\n\n// src/schemas/enum/enum.ts\nfunction enum_(enum_2, error) {\n  return {\n    /**\n     * The schema type.\n     */\n    type: \"enum\",\n    /**\n     * The enum value.\n     */\n    enum: enum_2,\n    /**\n     * Whether it's async.\n     */\n    async: false,\n    /**\n     * Parses unknown input based on its schema.\n     *\n     * @param input The input to be parsed.\n     * @param info The parse info.\n     *\n     * @returns The parsed output.\n     */\n    _parse(input, info) {\n      if (!Object.values(enum_2).includes(input)) {\n        return getSchemaIssues(\n          info,\n          \"type\",\n          \"enum\",\n          error || \"Invalid type\",\n          input\n        );\n      }\n      return getOutput(input);\n    }\n  };\n}\nvar nativeEnum = enum_;\n\n// src/schemas/enum/enumAsync.ts\nfunction enumAsync(enum_2, error) {\n  return {\n    /**\n     * The schema type.\n     */\n    type: \"enum\",\n    /**\n     * The enum value.\n     */\n    enum: enum_2,\n    /**\n     * Whether it's async.\n     */\n    async: true,\n    /**\n     * Parses unknown input based on its schema.\n     *\n     * @param input The input to be parsed.\n     * @param info The parse info.\n     *\n     * @returns The parsed output.\n     */\n    async _parse(input, info) {\n      if (!Object.values(enum_2).includes(input)) {\n        return getSchemaIssues(\n          info,\n          \"type\",\n          \"enum\",\n          error || \"Invalid type\",\n          input\n        );\n      }\n      return getOutput(input);\n    }\n  };\n}\nvar nativeEnumAsync = enumAsync;\n\n// src/schemas/instance/instance.ts\nfunction instance(of, arg2, arg3) {\n  const [error, pipe] = getDefaultArgs(arg2, arg3);\n  return {\n    /**\n     * The schema type.\n     */\n    type: \"instance\",\n    /**\n     * The class of the instance.\n     */\n    class: of,\n    /**\n     * Whether it's async.\n     */\n    async: false,\n    /**\n     * Parses unknown input based on its schema.\n     *\n     * @param input The input to be parsed.\n     * @param info The parse info.\n     *\n     * @returns The parsed output.\n     */\n    _parse(input, info) {\n      if (!(input instanceof of)) {\n        return getSchemaIssues(\n          info,\n          \"type\",\n          \"instance\",\n          error || \"Invalid type\",\n          input\n        );\n      }\n      return executePipe(input, pipe, info, \"instance\");\n    }\n  };\n}\n\n// src/schemas/instance/instanceAsync.ts\nfunction instanceAsync(of, arg2, arg3) {\n  const [error, pipe] = getDefaultArgs(arg2, arg3);\n  return {\n    /**\n     * The schema type.\n     */\n    type: \"instance\",\n    /**\n     * The class of the instance.\n     */\n    class: of,\n    /**\n     * Whether it's async.\n     */\n    async: true,\n    /**\n     * Parses unknown input based on its schema.\n     *\n     * @param input The input to be parsed.\n     * @param info The parse info.\n     *\n     * @returns The parsed output.\n     */\n    async _parse(input, info) {\n      if (!(input instanceof of)) {\n        return getSchemaIssues(\n          info,\n          \"type\",\n          \"instance\",\n          error || \"Invalid type\",\n          input\n        );\n      }\n      return executePipeAsync(input, pipe, info, \"instance\");\n    }\n  };\n}\n\n// src/schemas/intersect/utils/mergeOutputs/mergeOutputs.ts\nfunction mergeOutputs(output1, output2) {\n  if (typeof output1 === typeof output2) {\n    if (output1 === output2 || output1 instanceof Date && output2 instanceof Date && +output1 === +output2) {\n      return getOutput(output1);\n    }\n    if (Array.isArray(output1) && Array.isArray(output2)) {\n      if (output1.length === output2.length) {\n        const array2 = [];\n        for (let index = 0; index < output1.length; index++) {\n          const result = mergeOutputs(output1[index], output2[index]);\n          if (result.invalid) {\n            return result;\n          }\n          array2.push(result.output);\n        }\n        return getOutput(array2);\n      }\n      return { invalid: true };\n    }\n    if (output1 && output2 && output1.constructor === Object && output2.constructor === Object) {\n      const object2 = { ...output1, ...output2 };\n      for (const key in output1) {\n        if (key in output2) {\n          const result = mergeOutputs(output1[key], output2[key]);\n          if (result.invalid) {\n            return result;\n          }\n          object2[key] = result.output;\n        }\n      }\n      return getOutput(object2);\n    }\n  }\n  return { invalid: true };\n}\n\n// src/schemas/intersect/intersect.ts\nfunction intersect(options, error) {\n  return {\n    /**\n     * The schema type.\n     */\n    type: \"intersect\",\n    /**\n     * The intersect options.\n     */\n    options,\n    /**\n     * Whether it's async.\n     */\n    async: false,\n    /**\n     * Parses unknown input based on its schema.\n     *\n     * @param input The input to be parsed.\n     * @param info The parse info.\n     *\n     * @returns The parsed output.\n     */\n    _parse(input, info) {\n      let issues;\n      let outputs;\n      for (const schema of options) {\n        const result = schema._parse(input, info);\n        if (result.issues) {\n          if (issues) {\n            for (const issue of result.issues) {\n              issues.push(issue);\n            }\n          } else {\n            issues = result.issues;\n          }\n          if (info?.abortEarly) {\n            break;\n          }\n        } else {\n          if (outputs) {\n            outputs.push(result.output);\n          } else {\n            outputs = [result.output];\n          }\n        }\n      }\n      if (issues) {\n        return getIssues(issues);\n      }\n      let output = outputs[0];\n      for (let index = 1; index < outputs.length; index++) {\n        const result = mergeOutputs(output, outputs[index]);\n        if (result.invalid) {\n          return getSchemaIssues(\n            info,\n            \"type\",\n            \"intersect\",\n            error || \"Invalid type\",\n            input\n          );\n        }\n        output = result.output;\n      }\n      return getOutput(output);\n    }\n  };\n}\nvar intersection = intersect;\n\n// src/schemas/literal/literal.ts\nfunction literal(literal2, error) {\n  return {\n    /**\n     * The schema type.\n     */\n    type: \"literal\",\n    /**\n     * The literal value.\n     */\n    literal: literal2,\n    /**\n     * Whether it's async.\n     */\n    async: false,\n    /**\n     * Parses unknown input based on its schema.\n     *\n     * @param input The input to be parsed.\n     * @param info The parse info.\n     *\n     * @returns The parsed output.\n     */\n    _parse(input, info) {\n      if (input !== literal2) {\n        return getSchemaIssues(\n          info,\n          \"type\",\n          \"literal\",\n          error || \"Invalid type\",\n          input\n        );\n      }\n      return getOutput(input);\n    }\n  };\n}\n\n// src/schemas/literal/literalAsync.ts\nfunction literalAsync(literal2, error) {\n  return {\n    /**\n     * The schema type.\n     */\n    type: \"literal\",\n    /**\n     * The literal value.\n     */\n    literal: literal2,\n    /**\n     * Whether it's async.\n     */\n    async: true,\n    /**\n     * Parses unknown input based on its schema.\n     *\n     * @param input The input to be parsed.\n     * @param info The parse info.\n     *\n     * @returns The parsed output.\n     */\n    async _parse(input, info) {\n      if (input !== literal2) {\n        return getSchemaIssues(\n          info,\n          \"type\",\n          \"literal\",\n          error || \"Invalid type\",\n          input\n        );\n      }\n      return getOutput(input);\n    }\n  };\n}\n\n// src/schemas/map/map.ts\nfunction map(key, value2, arg3, arg4) {\n  const [error, pipe] = getDefaultArgs(arg3, arg4);\n  return {\n    /**\n     * The schema type.\n     */\n    type: \"map\",\n    /**\n     * The key schema.\n     */\n    key,\n    /**\n     * The value schema.\n     */\n    value: value2,\n    /**\n     * Whether it's async.\n     */\n    async: false,\n    /**\n     * Parses unknown input based on its schema.\n     *\n     * @param input The input to be parsed.\n     * @param info The parse info.\n     *\n     * @returns The parsed output.\n     */\n    _parse(input, info) {\n      if (!(input instanceof Map)) {\n        return getSchemaIssues(\n          info,\n          \"type\",\n          \"map\",\n          error || \"Invalid type\",\n          input\n        );\n      }\n      let issues;\n      const output = /* @__PURE__ */ new Map();\n      for (const [inputKey, inputValue] of input.entries()) {\n        let pathItem;\n        const keyResult = key._parse(inputKey, {\n          origin: \"key\",\n          abortEarly: info?.abortEarly,\n          abortPipeEarly: info?.abortPipeEarly,\n          skipPipe: info?.skipPipe\n        });\n        if (keyResult.issues) {\n          pathItem = {\n            type: \"map\",\n            input,\n            key: inputKey,\n            value: inputValue\n          };\n          for (const issue of keyResult.issues) {\n            if (issue.path) {\n              issue.path.unshift(pathItem);\n            } else {\n              issue.path = [pathItem];\n            }\n            issues?.push(issue);\n          }\n          if (!issues) {\n            issues = keyResult.issues;\n          }\n          if (info?.abortEarly) {\n            break;\n          }\n        }\n        const valueResult = value2._parse(inputValue, info);\n        if (valueResult.issues) {\n          pathItem = pathItem || {\n            type: \"map\",\n            input,\n            key: inputKey,\n            value: inputValue\n          };\n          for (const issue of valueResult.issues) {\n            if (issue.path) {\n              issue.path.unshift(pathItem);\n            } else {\n              issue.path = [pathItem];\n            }\n            issues?.push(issue);\n          }\n          if (!issues) {\n            issues = valueResult.issues;\n          }\n          if (info?.abortEarly) {\n            break;\n          }\n        }\n        if (!keyResult.issues && !valueResult.issues) {\n          output.set(keyResult.output, valueResult.output);\n        }\n      }\n      return issues ? getIssues(issues) : executePipe(output, pipe, info, \"map\");\n    }\n  };\n}\n\n// src/schemas/map/mapAsync.ts\nfunction mapAsync(key, value2, arg3, arg4) {\n  const [error, pipe] = getDefaultArgs(arg3, arg4);\n  return {\n    /**\n     * The schema type.\n     */\n    type: \"map\",\n    /**\n     * The key schema.\n     */\n    key,\n    /**\n     * The  value schema.\n     */\n    value: value2,\n    /**\n     * Whether it's async.\n     */\n    async: true,\n    /**\n     * Parses unknown input based on its schema.\n     *\n     * @param input The input to be parsed.\n     * @param info The parse info.\n     *\n     * @returns The parsed output.\n     */\n    async _parse(input, info) {\n      if (!(input instanceof Map)) {\n        return getSchemaIssues(\n          info,\n          \"type\",\n          \"map\",\n          error || \"Invalid type\",\n          input\n        );\n      }\n      const output = /* @__PURE__ */ new Map();\n      let issues;\n      await Promise.all(\n        Array.from(input.entries()).map(async ([inputKey, inputValue]) => {\n          let pathItem;\n          const [keyResult, valueResult] = await Promise.all(\n            [\n              { schema: key, value: inputKey, origin: \"key\" },\n              { schema: value2, value: inputValue, origin: \"value\" }\n            ].map(async ({ schema, value: value3, origin }) => {\n              if (!(info?.abortEarly && issues)) {\n                const result = await schema._parse(value3, {\n                  origin,\n                  abortEarly: info?.abortEarly,\n                  abortPipeEarly: info?.abortPipeEarly,\n                  skipPipe: info?.skipPipe\n                });\n                if (!(info?.abortEarly && issues)) {\n                  if (result.issues) {\n                    pathItem = pathItem || {\n                      type: \"map\",\n                      input,\n                      key: inputKey,\n                      value: inputValue\n                    };\n                    for (const issue of result.issues) {\n                      if (issue.path) {\n                        issue.path.unshift(pathItem);\n                      } else {\n                        issue.path = [pathItem];\n                      }\n                      issues?.push(issue);\n                    }\n                    if (!issues) {\n                      issues = result.issues;\n                    }\n                    if (info?.abortEarly) {\n                      throw null;\n                    }\n                  } else {\n                    return result;\n                  }\n                }\n              }\n            })\n          ).catch(() => []);\n          if (keyResult && valueResult) {\n            output.set(keyResult.output, valueResult.output);\n          }\n        })\n      );\n      return issues ? getIssues(issues) : executePipeAsync(input, pipe, info, \"map\");\n    }\n  };\n}\n\n// src/schemas/nan/nan.ts\nfunction nan(error) {\n  return {\n    /**\n     * The schema type.\n     */\n    type: \"nan\",\n    /**\n     * Whether it's async.\n     */\n    async: false,\n    /**\n     * Parses unknown input based on its schema.\n     *\n     * @param input The input to be parsed.\n     * @param info The parse info.\n     *\n     * @returns The parsed output.\n     */\n    _parse(input, info) {\n      if (!Number.isNaN(input)) {\n        return getSchemaIssues(\n          info,\n          \"type\",\n          \"nan\",\n          error || \"Invalid type\",\n          input\n        );\n      }\n      return getOutput(input);\n    }\n  };\n}\n\n// src/schemas/nan/nanAsync.ts\nfunction nanAsync(error) {\n  return {\n    /**\n     * The schema type.\n     */\n    type: \"nan\",\n    /**\n     * Whether it's async.\n     */\n    async: true,\n    /**\n     * Parses unknown input based on its schema.\n     *\n     * @param input The input to be parsed.\n     * @param info The parse info.\n     *\n     * @returns The parsed output.\n     */\n    async _parse(input, info) {\n      if (!Number.isNaN(input)) {\n        return getSchemaIssues(\n          info,\n          \"type\",\n          \"nan\",\n          error || \"Invalid type\",\n          input\n        );\n      }\n      return getOutput(input);\n    }\n  };\n}\n\n// src/schemas/never/never.ts\nfunction never(error) {\n  return {\n    /**\n     * The schema type.\n     */\n    type: \"never\",\n    /**\n     * Whether it's async.\n     */\n    async: false,\n    /**\n     * Parses unknown input based on its schema.\n     *\n     * @param input The input to be parsed.\n     * @param info The parse info.\n     *\n     * @returns The parsed output.\n     */\n    _parse(input, info) {\n      return getSchemaIssues(\n        info,\n        \"type\",\n        \"never\",\n        error || \"Invalid type\",\n        input\n      );\n    }\n  };\n}\n\n// src/schemas/never/neverAsync.ts\nfunction neverAsync(error) {\n  return {\n    /**\n     * The schema type.\n     */\n    type: \"never\",\n    /**\n     * Whether it's async.\n     */\n    async: true,\n    /**\n     * Parses unknown input based on its schema.\n     *\n     * @param input The input to be parsed.\n     * @param info The parse info.\n     *\n     * @returns The parsed output.\n     */\n    async _parse(input, info) {\n      return getSchemaIssues(\n        info,\n        \"type\",\n        \"never\",\n        error || \"Invalid type\",\n        input\n      );\n    }\n  };\n}\n\n// src/schemas/nonNullable/nonNullable.ts\nfunction nonNullable(wrapped, error) {\n  return {\n    /**\n     * The schema type.\n     */\n    type: \"non_nullable\",\n    /**\n     * The wrapped schema.\n     */\n    wrapped,\n    /**\n     * Whether it's async.\n     */\n    async: false,\n    /**\n     * Parses unknown input based on its schema.\n     *\n     * @param input The input to be parsed.\n     * @param info The parse info.\n     *\n     * @returns The parsed output.\n     */\n    _parse(input, info) {\n      if (input === null) {\n        return getSchemaIssues(\n          info,\n          \"type\",\n          \"non_nullable\",\n          error || \"Invalid type\",\n          input\n        );\n      }\n      return wrapped._parse(input, info);\n    }\n  };\n}\n\n// src/schemas/nonNullable/nonNullableAsync.ts\nfunction nonNullableAsync(wrapped, error) {\n  return {\n    /**\n     * The schema type.\n     */\n    type: \"non_nullable\",\n    /**\n     * The wrapped schema.\n     */\n    wrapped,\n    /**\n     * Whether it's async.\n     */\n    async: true,\n    /**\n     * Parses unknown input based on its schema.\n     *\n     * @param input The input to be parsed.\n     * @param info The parse info.\n     *\n     * @returns The parsed output.\n     */\n    async _parse(input, info) {\n      if (input === null) {\n        return getSchemaIssues(\n          info,\n          \"type\",\n          \"non_nullable\",\n          error || \"Invalid type\",\n          input\n        );\n      }\n      return wrapped._parse(input, info);\n    }\n  };\n}\n\n// src/schemas/nonNullish/nonNullish.ts\nfunction nonNullish(wrapped, error) {\n  return {\n    /**\n     * The schema type.\n     */\n    type: \"non_nullish\",\n    /**\n     * The wrapped schema.\n     */\n    wrapped,\n    /**\n     * Whether it's async.\n     */\n    async: false,\n    /**\n     * Parses unknown input based on its schema.\n     *\n     * @param input The input to be parsed.\n     * @param info The parse info.\n     *\n     * @returns The parsed output.\n     */\n    _parse(input, info) {\n      if (input === null || input === void 0) {\n        return getSchemaIssues(\n          info,\n          \"type\",\n          \"non_nullish\",\n          error || \"Invalid type\",\n          input\n        );\n      }\n      return wrapped._parse(input, info);\n    }\n  };\n}\n\n// src/schemas/nonNullish/nonNullishAsync.ts\nfunction nonNullishAsync(wrapped, error) {\n  return {\n    /**\n     * The schema type.\n     */\n    type: \"non_nullish\",\n    /**\n     * The wrapped schema.\n     */\n    wrapped,\n    /**\n     * Whether it's async.\n     */\n    async: true,\n    /**\n     * Parses unknown input based on its schema.\n     *\n     * @param input The input to be parsed.\n     * @param info The parse info.\n     *\n     * @returns The parsed output.\n     */\n    async _parse(input, info) {\n      if (input === null || input === void 0) {\n        return getSchemaIssues(\n          info,\n          \"type\",\n          \"non_nullish\",\n          error || \"Invalid type\",\n          input\n        );\n      }\n      return wrapped._parse(input, info);\n    }\n  };\n}\n\n// src/schemas/nonOptional/nonOptional.ts\nfunction nonOptional(wrapped, error) {\n  return {\n    /**\n     * The schema type.\n     */\n    type: \"non_optional\",\n    /**\n     * The wrapped schema.\n     */\n    wrapped,\n    /**\n     * Whether it's async.\n     */\n    async: false,\n    /**\n     * Parses unknown input based on its schema.\n     *\n     * @param input The input to be parsed.\n     * @param info The parse info.\n     *\n     * @returns The parsed output.\n     */\n    _parse(input, info) {\n      if (input === void 0) {\n        return getSchemaIssues(\n          info,\n          \"type\",\n          \"non_optional\",\n          error || \"Invalid type\",\n          input\n        );\n      }\n      return wrapped._parse(input, info);\n    }\n  };\n}\n\n// src/schemas/nonOptional/nonOptionalAsync.ts\nfunction nonOptionalAsync(wrapped, error) {\n  return {\n    /**\n     * The schema type.\n     */\n    type: \"non_optional\",\n    /**\n     * The wrapped schema.\n     */\n    wrapped,\n    /**\n     * Whether it's async.\n     */\n    async: true,\n    /**\n     * Parses unknown input based on its schema.\n     *\n     * @param input The input to be parsed.\n     * @param info The parse info.\n     *\n     * @returns The parsed output.\n     */\n    async _parse(input, info) {\n      if (input === void 0) {\n        return getSchemaIssues(\n          info,\n          \"type\",\n          \"non_optional\",\n          error || \"Invalid type\",\n          input\n        );\n      }\n      return wrapped._parse(input, info);\n    }\n  };\n}\n\n// src/schemas/nullable/nullable.ts\nfunction nullable(wrapped, default_) {\n  return {\n    /**\n     * The schema type.\n     */\n    type: \"nullable\",\n    /**\n     * The wrapped schema.\n     */\n    wrapped,\n    /**\n     * Returns the default value.\n     */\n    getDefault() {\n      return typeof default_ === \"function\" ? default_() : default_;\n    },\n    /**\n     * Whether it's async.\n     */\n    async: false,\n    /**\n     * Parses unknown input based on its schema.\n     *\n     * @param input The input to be parsed.\n     * @param info The parse info.\n     *\n     * @returns The parsed output.\n     */\n    _parse(input, info) {\n      if (input === null) {\n        const override = this.getDefault();\n        if (override === void 0) {\n          return getOutput(input);\n        }\n        input = override;\n      }\n      return wrapped._parse(input, info);\n    }\n  };\n}\n\n// src/schemas/nullable/nullableAsync.ts\nfunction nullableAsync(wrapped, default_) {\n  return {\n    /**\n     * The schema type.\n     */\n    type: \"nullable\",\n    /**\n     * The wrapped schema.\n     */\n    wrapped,\n    /**\n     * Returns the default value.\n     */\n    async getDefault() {\n      return typeof default_ === \"function\" ? default_() : default_;\n    },\n    /**\n     * Whether it's async.\n     */\n    async: true,\n    /**\n     * Parses unknown input based on its schema.\n     *\n     * @param input The input to be parsed.\n     * @param info The parse info.\n     *\n     * @returns The parsed output.\n     */\n    async _parse(input, info) {\n      if (input === null) {\n        const override = await this.getDefault();\n        if (override === void 0) {\n          return getOutput(input);\n        }\n        input = override;\n      }\n      return wrapped._parse(input, info);\n    }\n  };\n}\n\n// src/schemas/nullish/nullish.ts\nfunction nullish(wrapped, default_) {\n  return {\n    /**\n     * The schema type.\n     */\n    type: \"nullish\",\n    /**\n     * The wrapped schema.\n     */\n    wrapped,\n    /**\n     * Returns the default value.\n     */\n    getDefault() {\n      return typeof default_ === \"function\" ? default_() : default_;\n    },\n    /**\n     * Whether it's async.\n     */\n    async: false,\n    /**\n     * Parses unknown input based on its schema.\n     *\n     * @param input The input to be parsed.\n     * @param info The parse info.\n     *\n     * @returns The parsed output.\n     */\n    _parse(input, info) {\n      if (input === null || input === void 0) {\n        const override = this.getDefault();\n        if (override === void 0) {\n          return getOutput(input);\n        }\n        input = override;\n      }\n      return wrapped._parse(input, info);\n    }\n  };\n}\n\n// src/schemas/nullish/nullishAsync.ts\nfunction nullishAsync(wrapped, default_) {\n  return {\n    /**\n     * The schema type.\n     */\n    type: \"nullish\",\n    /**\n     * The wrapped schema.\n     */\n    wrapped,\n    /**\n     * Retutns the default value.\n     */\n    async getDefault() {\n      return typeof default_ === \"function\" ? default_() : default_;\n    },\n    /**\n     * Whether it's async.\n     */\n    async: true,\n    /**\n     * Parses unknown input based on its schema.\n     *\n     * @param input The input to be parsed.\n     * @param info The parse info.\n     *\n     * @returns The parsed output.\n     */\n    async _parse(input, info) {\n      if (input === null || input === void 0) {\n        const override = await this.getDefault();\n        if (override === void 0) {\n          return getOutput(input);\n        }\n        input = override;\n      }\n      return wrapped._parse(input, info);\n    }\n  };\n}\n\n// src/schemas/null/null.ts\nfunction null_(error) {\n  return {\n    /**\n     * The schema type.\n     */\n    type: \"null\",\n    /**\n     * Whether it's async.\n     */\n    async: false,\n    /**\n     * Parses unknown input based on its schema.\n     *\n     * @param input The input to be parsed.\n     * @param info The parse info.\n     *\n     * @returns The parsed output.\n     */\n    _parse(input, info) {\n      if (input !== null) {\n        return getSchemaIssues(\n          info,\n          \"type\",\n          \"null\",\n          error || \"Invalid type\",\n          input\n        );\n      }\n      return getOutput(input);\n    }\n  };\n}\nvar nullType = null_;\n\n// src/schemas/null/nullAsync.ts\nfunction nullAsync(error) {\n  return {\n    /**\n     * The schema type.\n     */\n    type: \"null\",\n    /**\n     * Whether it's async.\n     */\n    async: true,\n    /**\n     * Parses unknown input based on its schema.\n     *\n     * @param input The input to be parsed.\n     * @param info The parse info.\n     *\n     * @returns The parsed output.\n     */\n    async _parse(input, info) {\n      if (input !== null) {\n        return getSchemaIssues(\n          info,\n          \"type\",\n          \"null\",\n          error || \"Invalid type\",\n          input\n        );\n      }\n      return getOutput(input);\n    }\n  };\n}\nvar nullTypeAsync = nullAsync;\n\n// src/schemas/number/number.ts\nfunction number(arg1, arg2) {\n  const [error, pipe] = getDefaultArgs(arg1, arg2);\n  return {\n    /**\n     * The schema type.\n     */\n    type: \"number\",\n    /**\n     * Whether it's async.\n     */\n    async: false,\n    /**\n     * Parses unknown input based on its schema.\n     *\n     * @param input The input to be parsed.\n     * @param info The parse info.\n     *\n     * @returns The parsed output.\n     */\n    _parse(input, info) {\n      if (typeof input !== \"number\" || isNaN(input)) {\n        return getSchemaIssues(\n          info,\n          \"type\",\n          \"number\",\n          error || \"Invalid type\",\n          input\n        );\n      }\n      return executePipe(input, pipe, info, \"number\");\n    }\n  };\n}\n\n// src/schemas/number/numberAsync.ts\nfunction numberAsync(arg1, arg2) {\n  const [error, pipe] = getDefaultArgs(arg1, arg2);\n  return {\n    /**\n     * The schema type.\n     */\n    type: \"number\",\n    /**\n     * Whether it's async.\n     */\n    async: true,\n    /**\n     * Parses unknown input based on its schema.\n     *\n     * @param input The input to be parsed.\n     * @param info The parse info.\n     *\n     * @returns The parsed output.\n     */\n    async _parse(input, info) {\n      if (typeof input !== \"number\" || isNaN(input)) {\n        return getSchemaIssues(\n          info,\n          \"type\",\n          \"number\",\n          error || \"Invalid type\",\n          input\n        );\n      }\n      return executePipeAsync(input, pipe, info, \"number\");\n    }\n  };\n}\n\n// src/schemas/object/object.ts\nfunction object(entries, arg2, arg3, arg4) {\n  const [rest, error, pipe] = getRestAndDefaultArgs(arg2, arg3, arg4);\n  let cachedEntries;\n  return {\n    /**\n     * The schema type.\n     */\n    type: \"object\",\n    /**\n     * The entries schema.\n     */\n    entries,\n    /**\n     * The rest schema.\n     */\n    rest,\n    /**\n     * Whether it's async.\n     */\n    async: false,\n    /**\n     * Parses unknown input based on its schema.\n     *\n     * @param input The input to be parsed.\n     * @param info The parse info.\n     *\n     * @returns The parsed output.\n     */\n    _parse(input, info) {\n      if (!input || typeof input !== \"object\") {\n        return getSchemaIssues(\n          info,\n          \"type\",\n          \"object\",\n          error || \"Invalid type\",\n          input\n        );\n      }\n      cachedEntries = cachedEntries || Object.entries(entries);\n      let issues;\n      const output = {};\n      for (const [key, schema] of cachedEntries) {\n        const value2 = input[key];\n        const result = schema._parse(value2, info);\n        if (result.issues) {\n          const pathItem = {\n            type: \"object\",\n            input,\n            key,\n            value: value2\n          };\n          for (const issue of result.issues) {\n            if (issue.path) {\n              issue.path.unshift(pathItem);\n            } else {\n              issue.path = [pathItem];\n            }\n            issues?.push(issue);\n          }\n          if (!issues) {\n            issues = result.issues;\n          }\n          if (info?.abortEarly) {\n            break;\n          }\n        } else if (result.output !== void 0 || key in input) {\n          output[key] = result.output;\n        }\n      }\n      if (rest && !(info?.abortEarly && issues)) {\n        for (const key in input) {\n          if (!(key in entries)) {\n            const value2 = input[key];\n            const result = rest._parse(value2, info);\n            if (result.issues) {\n              const pathItem = {\n                type: \"object\",\n                input,\n                key,\n                value: value2\n              };\n              for (const issue of result.issues) {\n                if (issue.path) {\n                  issue.path.unshift(pathItem);\n                } else {\n                  issue.path = [pathItem];\n                }\n                issues?.push(issue);\n              }\n              if (!issues) {\n                issues = result.issues;\n              }\n              if (info?.abortEarly) {\n                break;\n              }\n            } else {\n              output[key] = result.output;\n            }\n          }\n        }\n      }\n      return issues ? getIssues(issues) : executePipe(\n        output,\n        pipe,\n        info,\n        \"object\"\n      );\n    }\n  };\n}\n\n// src/schemas/object/objectAsync.ts\nfunction objectAsync(entries, arg2, arg3, arg4) {\n  const [rest, error, pipe] = getRestAndDefaultArgs(arg2, arg3, arg4);\n  let cachedEntries;\n  return {\n    /**\n     * The schema type.\n     */\n    type: \"object\",\n    /**\n     * The entries schema.\n     */\n    entries,\n    /**\n     * The rest schema.\n     */\n    rest,\n    /**\n     * Whether it's async.\n     */\n    async: true,\n    /**\n     * Parses unknown input based on its schema.\n     *\n     * @param input The input to be parsed.\n     * @param info The parse info.\n     *\n     * @returns The parsed output.\n     */\n    async _parse(input, info) {\n      if (!input || typeof input !== \"object\") {\n        return getSchemaIssues(\n          info,\n          \"type\",\n          \"object\",\n          error || \"Invalid type\",\n          input\n        );\n      }\n      cachedEntries = cachedEntries || Object.entries(entries);\n      let issues;\n      const output = {};\n      await Promise.all([\n        Promise.all(\n          cachedEntries.map(async ([key, schema]) => {\n            if (!(info?.abortEarly && issues)) {\n              const value2 = input[key];\n              const result = await schema._parse(value2, info);\n              if (!(info?.abortEarly && issues)) {\n                if (result.issues) {\n                  const pathItem = {\n                    type: \"object\",\n                    input,\n                    key,\n                    value: value2\n                  };\n                  for (const issue of result.issues) {\n                    if (issue.path) {\n                      issue.path.unshift(pathItem);\n                    } else {\n                      issue.path = [pathItem];\n                    }\n                    issues?.push(issue);\n                  }\n                  if (!issues) {\n                    issues = result.issues;\n                  }\n                  if (info?.abortEarly) {\n                    throw null;\n                  }\n                } else if (result.output !== void 0 || key in input) {\n                  output[key] = result.output;\n                }\n              }\n            }\n          })\n        ),\n        rest && Promise.all(\n          Object.entries(input).map(async ([key, value2]) => {\n            if (!(info?.abortEarly && issues)) {\n              if (!(key in entries)) {\n                const result = await rest._parse(value2, info);\n                if (!(info?.abortEarly && issues)) {\n                  if (result.issues) {\n                    const pathItem = {\n                      type: \"object\",\n                      input,\n                      key,\n                      value: value2\n                    };\n                    for (const issue of result.issues) {\n                      if (issue.path) {\n                        issue.path.unshift(pathItem);\n                      } else {\n                        issue.path = [pathItem];\n                      }\n                      issues?.push(issue);\n                    }\n                    if (!issues) {\n                      issues = result.issues;\n                    }\n                    if (info?.abortEarly) {\n                      throw null;\n                    }\n                  } else {\n                    output[key] = result.output;\n                  }\n                }\n              }\n            }\n          })\n        )\n      ]).catch(() => null);\n      return issues ? getIssues(issues) : executePipeAsync(\n        output,\n        pipe,\n        info,\n        \"object\"\n      );\n    }\n  };\n}\n\n// src/schemas/optional/optional.ts\nfunction optional(wrapped, default_) {\n  return {\n    /**\n     * The schema type.\n     */\n    type: \"optional\",\n    /**\n     * The wrapped schema.\n     */\n    wrapped,\n    /**\n     * Returns the default value.\n     */\n    getDefault() {\n      return typeof default_ === \"function\" ? default_() : default_;\n    },\n    /**\n     * Whether it's async.\n     */\n    async: false,\n    /**\n     * Parses unknown input based on its schema.\n     *\n     * @param input The input to be parsed.\n     * @param info The parse info.\n     *\n     * @returns The parsed output.\n     */\n    _parse(input, info) {\n      if (input === void 0) {\n        const override = this.getDefault();\n        if (override === void 0) {\n          return getOutput(input);\n        }\n        input = override;\n      }\n      return wrapped._parse(input, info);\n    }\n  };\n}\n\n// src/schemas/optional/optionalAsync.ts\nfunction optionalAsync(wrapped, default_) {\n  return {\n    /**\n     * The schema type.\n     */\n    type: \"optional\",\n    /**\n     * The wrapped schema.\n     */\n    wrapped,\n    /**\n     * Returns the default value.\n     */\n    async getDefault() {\n      return typeof default_ === \"function\" ? default_() : default_;\n    },\n    /**\n     * Whether it's async.\n     */\n    async: true,\n    /**\n     * Parses unknown input based on its schema.\n     *\n     * @param input The input to be parsed.\n     * @param info The parse info.\n     *\n     * @returns The parsed output.\n     */\n    async _parse(input, info) {\n      if (input === void 0) {\n        const override = await this.getDefault();\n        if (override === void 0) {\n          return getOutput(input);\n        }\n        input = override;\n      }\n      return wrapped._parse(input, info);\n    }\n  };\n}\n\n// src/schemas/picklist/picklist.ts\nfunction picklist(options, error) {\n  return {\n    /**\n     * The schema type.\n     */\n    type: \"picklist\",\n    /**\n     * The picklist options.\n     */\n    options,\n    /**\n     * Whether it's async.\n     */\n    async: false,\n    /**\n     * Parses unknown input based on its schema.\n     *\n     * @param input The input to be parsed.\n     * @param info The parse info.\n     *\n     * @returns The parsed output.\n     */\n    _parse(input, info) {\n      if (!options.includes(input)) {\n        return getSchemaIssues(\n          info,\n          \"type\",\n          \"picklist\",\n          error || \"Invalid type\",\n          input\n        );\n      }\n      return getOutput(input);\n    }\n  };\n}\nvar enumType = picklist;\n\n// src/schemas/picklist/picklistAsync.ts\nfunction picklistAsync(options, error) {\n  return {\n    /**\n     * The schema type.\n     */\n    type: \"picklist\",\n    /**\n     * The picklist value.\n     */\n    options,\n    /**\n     * Whether it's async.\n     */\n    async: true,\n    /**\n     * Parses unknown input based on its schema.\n     *\n     * @param input The input to be parsed.\n     * @param info The parse info.\n     *\n     * @returns The parsed output.\n     */\n    async _parse(input, info) {\n      if (!options.includes(input)) {\n        return getSchemaIssues(\n          info,\n          \"type\",\n          \"picklist\",\n          error || \"Invalid type\",\n          input\n        );\n      }\n      return getOutput(input);\n    }\n  };\n}\nvar enumTypeAsync = picklistAsync;\n\n// src/schemas/string/string.ts\nfunction string(arg1, arg2) {\n  const [error, pipe] = getDefaultArgs(arg1, arg2);\n  return {\n    /**\n     * The schema type.\n     */\n    type: \"string\",\n    /**\n     * Whether it's async.\n     */\n    async: false,\n    /**\n     * Parses unknown input based on its schema.\n     *\n     * @param input The input to be parsed.\n     * @param info The parse info.\n     *\n     * @returns The parsed output.\n     */\n    _parse(input, info) {\n      if (typeof input !== \"string\") {\n        return getSchemaIssues(\n          info,\n          \"type\",\n          \"string\",\n          error || \"Invalid type\",\n          input\n        );\n      }\n      return executePipe(input, pipe, info, \"string\");\n    }\n  };\n}\n\n// src/schemas/string/stringAsync.ts\nfunction stringAsync(arg1, arg2) {\n  const [error, pipe] = getDefaultArgs(arg1, arg2);\n  return {\n    /**\n     * The schema type.\n     */\n    type: \"string\",\n    /**\n     * Whether it's async.\n     */\n    async: true,\n    /**\n     * Parses unknown input based on its schema.\n     *\n     * @param input The input to be parsed.\n     * @param info The parse info.\n     *\n     * @returns The parsed output.\n     */\n    async _parse(input, info) {\n      if (typeof input !== \"string\") {\n        return getSchemaIssues(\n          info,\n          \"type\",\n          \"string\",\n          error || \"Invalid type\",\n          input\n        );\n      }\n      return executePipeAsync(input, pipe, info, \"string\");\n    }\n  };\n}\n\n// src/schemas/record/utils/getRecordArgs/getRecordArgs.ts\nfunction getRecordArgs(arg1, arg2, arg3, arg4) {\n  if (typeof arg2 === \"object\" && !Array.isArray(arg2)) {\n    const [error2, pipe2] = getDefaultArgs(arg3, arg4);\n    return [arg1, arg2, error2, pipe2];\n  }\n  const [error, pipe] = getDefaultArgs(\n    arg2,\n    arg3\n  );\n  return [string(), arg1, error, pipe];\n}\n\n// src/schemas/record/values.ts\nvar BLOCKED_KEYS = [\"__proto__\", \"prototype\", \"constructor\"];\n\n// src/schemas/record/record.ts\nfunction record(arg1, arg2, arg3, arg4) {\n  const [key, value2, error, pipe] = getRecordArgs(arg1, arg2, arg3, arg4);\n  return {\n    /**\n     * The schema type.\n     */\n    type: \"record\",\n    /**\n     * The key schema.\n     */\n    key,\n    /**\n     * The value schema.\n     */\n    value: value2,\n    /**\n     * Whether it's async.\n     */\n    async: false,\n    /**\n     * Parses unknown input based on its schema.\n     *\n     * @param input The input to be parsed.\n     * @param info The parse info.\n     *\n     * @returns The parsed output.\n     */\n    _parse(input, info) {\n      if (!input || typeof input !== \"object\") {\n        return getSchemaIssues(\n          info,\n          \"type\",\n          \"record\",\n          error || \"Invalid type\",\n          input\n        );\n      }\n      let issues;\n      const output = {};\n      for (const [inputKey, inputValue] of Object.entries(input)) {\n        if (!BLOCKED_KEYS.includes(inputKey)) {\n          let pathItem;\n          const keyResult = key._parse(inputKey, {\n            origin: \"key\",\n            abortEarly: info?.abortEarly,\n            abortPipeEarly: info?.abortPipeEarly,\n            skipPipe: info?.skipPipe\n          });\n          if (keyResult.issues) {\n            pathItem = {\n              type: \"record\",\n              input,\n              key: inputKey,\n              value: inputValue\n            };\n            for (const issue of keyResult.issues) {\n              issue.path = [pathItem];\n              issues?.push(issue);\n            }\n            if (!issues) {\n              issues = keyResult.issues;\n            }\n            if (info?.abortEarly) {\n              break;\n            }\n          }\n          const valueResult = value2._parse(inputValue, info);\n          if (valueResult.issues) {\n            pathItem = pathItem || {\n              type: \"record\",\n              input,\n              key: inputKey,\n              value: inputValue\n            };\n            for (const issue of valueResult.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              issues?.push(issue);\n            }\n            if (!issues) {\n              issues = valueResult.issues;\n            }\n            if (info?.abortEarly) {\n              break;\n            }\n          }\n          if (!keyResult.issues && !valueResult.issues) {\n            output[keyResult.output] = valueResult.output;\n          }\n        }\n      }\n      return issues ? getIssues(issues) : executePipe(\n        output,\n        pipe,\n        info,\n        \"record\"\n      );\n    }\n  };\n}\n\n// src/schemas/record/recordAsync.ts\nfunction recordAsync(arg1, arg2, arg3, arg4) {\n  const [key, value2, error, pipe] = getRecordArgs(arg1, arg2, arg3, arg4);\n  return {\n    /**\n     * The schema type.\n     */\n    type: \"record\",\n    /**\n     * The key schema.\n     */\n    key,\n    /**\n     * The value schema.\n     */\n    value: value2,\n    /**\n     * Whether it's async.\n     */\n    async: true,\n    /**\n     * Parses unknown input based on its schema.\n     *\n     * @param input The input to be parsed.\n     * @param info The parse info.\n     *\n     * @returns The parsed output.\n     */\n    async _parse(input, info) {\n      if (!input || typeof input !== \"object\") {\n        return getSchemaIssues(\n          info,\n          \"type\",\n          \"record\",\n          error || \"Invalid type\",\n          input\n        );\n      }\n      let issues;\n      const output = {};\n      await Promise.all(\n        // Note: `Object.entries(...)` converts each key to a string\n        Object.entries(input).map(async ([inputKey, inputValue]) => {\n          if (!BLOCKED_KEYS.includes(inputKey)) {\n            let pathItem;\n            const [keyResult, valueResult] = await Promise.all(\n              [\n                { schema: key, value: inputKey, origin: \"key\" },\n                { schema: value2, value: inputValue, origin: \"value\" }\n              ].map(async ({ schema, value: value3, origin }) => {\n                if (!(info?.abortEarly && issues)) {\n                  const result = await schema._parse(value3, {\n                    origin,\n                    abortEarly: info?.abortEarly,\n                    abortPipeEarly: info?.abortPipeEarly,\n                    skipPipe: info?.skipPipe\n                  });\n                  if (!(info?.abortEarly && issues)) {\n                    if (result.issues) {\n                      pathItem = pathItem || {\n                        type: \"record\",\n                        input,\n                        key: inputKey,\n                        value: inputValue\n                      };\n                      for (const issue of result.issues) {\n                        if (issue.path) {\n                          issue.path.unshift(pathItem);\n                        } else {\n                          issue.path = [pathItem];\n                        }\n                        issues?.push(issue);\n                      }\n                      if (!issues) {\n                        issues = result.issues;\n                      }\n                      if (info?.abortEarly) {\n                        throw null;\n                      }\n                    } else {\n                      return result;\n                    }\n                  }\n                }\n              })\n            ).catch(() => []);\n            if (keyResult && valueResult) {\n              output[keyResult.output] = valueResult.output;\n            }\n          }\n        })\n      );\n      return issues ? getIssues(issues) : executePipeAsync(\n        output,\n        pipe,\n        info,\n        \"record\"\n      );\n    }\n  };\n}\n\n// src/schemas/recursive/recursive.ts\nfunction recursive(getter) {\n  return {\n    /**\n     * The schema type.\n     */\n    type: \"recursive\",\n    /**\n     * The schema getter.\n     */\n    getter,\n    /**\n     * Whether it's async.\n     */\n    async: false,\n    /**\n     * Parses unknown input based on its schema.\n     *\n     * @param input The input to be parsed.\n     * @param info The parse info.\n     *\n     * @returns The parsed output.\n     */\n    _parse(input, info) {\n      return getter()._parse(input, info);\n    }\n  };\n}\n\n// src/schemas/recursive/recursiveAsync.ts\nfunction recursiveAsync(getter) {\n  return {\n    /**\n     * The schema type.\n     */\n    type: \"recursive\",\n    /**\n     * The schema getter.\n     */\n    getter,\n    /**\n     * Whether it's async.\n     */\n    async: true,\n    /**\n     * Parses unknown input based on its schema.\n     *\n     * @param input The input to be parsed.\n     * @param info The parse info.\n     *\n     * @returns The parsed output.\n     */\n    async _parse(input, info) {\n      return getter()._parse(input, info);\n    }\n  };\n}\n\n// src/schemas/set/set.ts\nfunction set(value2, arg2, arg3) {\n  const [error, pipe] = getDefaultArgs(arg2, arg3);\n  return {\n    /**\n     * The schema type.\n     */\n    type: \"set\",\n    /**\n     * The value schema.\n     */\n    value: value2,\n    /**\n     * Whether it's async.\n     */\n    async: false,\n    /**\n     * Parses unknown input based on its schema.\n     *\n     * @param input The input to be parsed.\n     * @param info The parse info.\n     *\n     * @returns The parsed output.\n     */\n    _parse(input, info) {\n      if (!(input instanceof Set)) {\n        return getSchemaIssues(\n          info,\n          \"type\",\n          \"set\",\n          error || \"Invalid type\",\n          input\n        );\n      }\n      let key = 0;\n      let issues;\n      const output = /* @__PURE__ */ new Set();\n      for (const inputValue of input) {\n        const result = value2._parse(inputValue, info);\n        if (result.issues) {\n          const pathItem = {\n            type: \"set\",\n            input,\n            key,\n            value: inputValue\n          };\n          for (const issue of result.issues) {\n            if (issue.path) {\n              issue.path.unshift(pathItem);\n            } else {\n              issue.path = [pathItem];\n            }\n            issues?.push(issue);\n          }\n          if (!issues) {\n            issues = result.issues;\n          }\n          if (info?.abortEarly) {\n            break;\n          }\n        } else {\n          output.add(result.output);\n        }\n        key++;\n      }\n      return issues ? getIssues(issues) : executePipe(output, pipe, info, \"set\");\n    }\n  };\n}\n\n// src/schemas/set/setAsync.ts\nfunction setAsync(value2, arg2, arg3) {\n  const [error, pipe] = getDefaultArgs(arg2, arg3);\n  return {\n    /**\n     * The schema type.\n     */\n    type: \"set\",\n    /**\n     * The value schema.\n     */\n    value: value2,\n    /**\n     * Whether it's async.\n     */\n    async: true,\n    /**\n     * Parses unknown input based on its schema.\n     *\n     * @param input The input to be parsed.\n     * @param info The parse info.\n     *\n     * @returns The parsed output.\n     */\n    async _parse(input, info) {\n      if (!(input instanceof Set)) {\n        return getSchemaIssues(\n          info,\n          \"type\",\n          \"set\",\n          error || \"Invalid type\",\n          input\n        );\n      }\n      let issues;\n      const output = /* @__PURE__ */ new Set();\n      await Promise.all(\n        Array.from(input.values()).map(async (inputValue, key) => {\n          if (!(info?.abortEarly && issues)) {\n            const result = await value2._parse(inputValue, info);\n            if (!(info?.abortEarly && issues)) {\n              if (result.issues) {\n                const pathItem = {\n                  type: \"set\",\n                  input,\n                  key,\n                  value: inputValue\n                };\n                for (const issue of result.issues) {\n                  if (issue.path) {\n                    issue.path.unshift(pathItem);\n                  } else {\n                    issue.path = [pathItem];\n                  }\n                  issues?.push(issue);\n                }\n                if (!issues) {\n                  issues = result.issues;\n                }\n                if (info?.abortEarly) {\n                  throw null;\n                }\n              } else {\n                output.add(result.output);\n              }\n            }\n          }\n        })\n      ).catch(() => null);\n      return issues ? getIssues(issues) : executePipeAsync(input, pipe, info, \"set\");\n    }\n  };\n}\n\n// src/schemas/special/special.ts\nfunction special(check, arg2, arg3) {\n  const [error, pipe] = getDefaultArgs(arg2, arg3);\n  return {\n    /**\n     * The schema type.\n     */\n    type: \"special\",\n    /**\n     * Whether it's async.\n     */\n    async: false,\n    /**\n     * Parses unknown input based on its schema.\n     *\n     * @param input The input to be parsed.\n     * @param info The parse info.\n     *\n     * @returns The parsed output.\n     */\n    _parse(input, info) {\n      if (!check(input)) {\n        return getSchemaIssues(\n          info,\n          \"type\",\n          \"special\",\n          error || \"Invalid type\",\n          input\n        );\n      }\n      return executePipe(input, pipe, info, \"special\");\n    }\n  };\n}\n\n// src/schemas/special/specialAsync.ts\nfunction specialAsync(check, arg2, arg3) {\n  const [error, pipe] = getDefaultArgs(arg2, arg3);\n  return {\n    /**\n     * The schema type.\n     */\n    type: \"special\",\n    /**\n     * Whether it's async.\n     */\n    async: true,\n    /**\n     * Parses unknown input based on its schema.\n     *\n     * @param input The input to be parsed.\n     * @param info The parse info.\n     *\n     * @returns The parsed output.\n     */\n    async _parse(input, info) {\n      if (!await check(input)) {\n        return getSchemaIssues(\n          info,\n          \"type\",\n          \"special\",\n          error || \"Invalid type\",\n          input\n        );\n      }\n      return executePipeAsync(input, pipe, info, \"special\");\n    }\n  };\n}\n\n// src/schemas/symbol/symbol.ts\nfunction symbol(error) {\n  return {\n    /**\n     * The schema type.\n     */\n    type: \"symbol\",\n    /**\n     * Whether it's async.\n     */\n    async: false,\n    /**\n     * Parses unknown input based on its schema.\n     *\n     * @param input The input to be parsed.\n     * @param info The parse info.\n     *\n     * @returns The parsed output.\n     */\n    _parse(input, info) {\n      if (typeof input !== \"symbol\") {\n        return getSchemaIssues(\n          info,\n          \"type\",\n          \"symbol\",\n          error || \"Invalid type\",\n          input\n        );\n      }\n      return getOutput(input);\n    }\n  };\n}\n\n// src/schemas/symbol/symbolAsync.ts\nfunction symbolAsync(error) {\n  return {\n    /**\n     * The schema type.\n     */\n    type: \"symbol\",\n    /**\n     * Whether it's async.\n     */\n    async: true,\n    /**\n     * Parses unknown input based on its schema.\n     *\n     * @param input The input to be parsed.\n     * @param info The parse info.\n     *\n     * @returns The parsed output.\n     */\n    async _parse(input, info) {\n      if (typeof input !== \"symbol\") {\n        return getSchemaIssues(\n          info,\n          \"type\",\n          \"symbol\",\n          error || \"Invalid type\",\n          input\n        );\n      }\n      return getOutput(input);\n    }\n  };\n}\n\n// src/schemas/tuple/tuple.ts\nfunction tuple(items, arg2, arg3, arg4) {\n  const [rest, error, pipe] = getRestAndDefaultArgs(arg2, arg3, arg4);\n  return {\n    /**\n     * The schema type.\n     */\n    type: \"tuple\",\n    /**\n     * The items schema.\n     */\n    items,\n    /**\n     * The rest schema.\n     */\n    rest,\n    /**\n     * Whether it's async.\n     */\n    async: false,\n    /**\n     * Parses unknown input based on its schema.\n     *\n     * @param input The input to be parsed.\n     * @param info The parse info.\n     *\n     * @returns The parsed output.\n     */\n    _parse(input, info) {\n      if (!Array.isArray(input) || items.length > input.length) {\n        return getSchemaIssues(\n          info,\n          \"type\",\n          \"tuple\",\n          error || \"Invalid type\",\n          input\n        );\n      }\n      let issues;\n      const output = [];\n      for (let key = 0; key < items.length; key++) {\n        const value2 = input[key];\n        const result = items[key]._parse(value2, info);\n        if (result.issues) {\n          const pathItem = {\n            type: \"tuple\",\n            input,\n            key,\n            value: value2\n          };\n          for (const issue of result.issues) {\n            if (issue.path) {\n              issue.path.unshift(pathItem);\n            } else {\n              issue.path = [pathItem];\n            }\n            issues?.push(issue);\n          }\n          if (!issues) {\n            issues = result.issues;\n          }\n          if (info?.abortEarly) {\n            break;\n          }\n        } else {\n          output[key] = result.output;\n        }\n      }\n      if (rest && !(info?.abortEarly && issues)) {\n        for (let key = items.length; key < input.length; key++) {\n          const value2 = input[key];\n          const result = rest._parse(value2, info);\n          if (result.issues) {\n            const pathItem = {\n              type: \"tuple\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of result.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              issues?.push(issue);\n            }\n            if (!issues) {\n              issues = result.issues;\n            }\n            if (info?.abortEarly) {\n              break;\n            }\n          } else {\n            output[key] = result.output;\n          }\n        }\n      }\n      return issues ? getIssues(issues) : executePipe(\n        output,\n        pipe,\n        info,\n        \"tuple\"\n      );\n    }\n  };\n}\n\n// src/schemas/tuple/tupleAsync.ts\nfunction tupleAsync(items, arg2, arg3, arg4) {\n  const [rest, error, pipe] = getRestAndDefaultArgs(arg2, arg3, arg4);\n  return {\n    /**\n     * The schema type.\n     */\n    type: \"tuple\",\n    /**\n     * The items schema.\n     */\n    items,\n    /**\n     * The rest schema.\n     */\n    rest,\n    /**\n     * Whether it's async.\n     */\n    async: true,\n    /**\n     * Parses unknown input based on its schema.\n     *\n     * @param input The input to be parsed.\n     * @param info The parse info.\n     *\n     * @returns The parsed output.\n     */\n    async _parse(input, info) {\n      if (!Array.isArray(input) || items.length > input.length) {\n        return getSchemaIssues(\n          info,\n          \"type\",\n          \"tuple\",\n          error || \"Invalid type\",\n          input\n        );\n      }\n      let issues;\n      const output = [];\n      await Promise.all([\n        // Parse schema of each tuple item\n        Promise.all(\n          items.map(async (schema, key) => {\n            if (!(info?.abortEarly && issues)) {\n              const value2 = input[key];\n              const result = await schema._parse(value2, info);\n              if (!(info?.abortEarly && issues)) {\n                if (result.issues) {\n                  const pathItem = {\n                    type: \"tuple\",\n                    input,\n                    key,\n                    value: value2\n                  };\n                  for (const issue of result.issues) {\n                    if (issue.path) {\n                      issue.path.unshift(pathItem);\n                    } else {\n                      issue.path = [pathItem];\n                    }\n                    issues?.push(issue);\n                  }\n                  if (!issues) {\n                    issues = result.issues;\n                  }\n                  if (info?.abortEarly) {\n                    throw null;\n                  }\n                } else {\n                  output[key] = result.output;\n                }\n              }\n            }\n          })\n        ),\n        // If necessary parse schema of each rest item\n        rest && Promise.all(\n          input.slice(items.length).map(async (value2, index) => {\n            if (!(info?.abortEarly && issues)) {\n              const key = items.length + index;\n              const result = await rest._parse(value2, info);\n              if (!(info?.abortEarly && issues)) {\n                if (result.issues) {\n                  const pathItem = {\n                    type: \"tuple\",\n                    input,\n                    key,\n                    value: value2\n                  };\n                  for (const issue of result.issues) {\n                    if (issue.path) {\n                      issue.path.unshift(pathItem);\n                    } else {\n                      issue.path = [pathItem];\n                    }\n                    issues?.push(issue);\n                  }\n                  if (!issues) {\n                    issues = result.issues;\n                  }\n                  if (info?.abortEarly) {\n                    throw null;\n                  }\n                } else {\n                  output[key] = result.output;\n                }\n              }\n            }\n          })\n        )\n      ]).catch(() => null);\n      return issues ? getIssues(issues) : executePipeAsync(\n        output,\n        pipe,\n        info,\n        \"tuple\"\n      );\n    }\n  };\n}\n\n// src/schemas/undefined/undefined.ts\nfunction undefined_(error) {\n  return {\n    /**\n     * The schema type.\n     */\n    type: \"undefined\",\n    /**\n     * Whether it's async.\n     */\n    async: false,\n    /**\n     * Parses unknown input based on its schema.\n     *\n     * @param input The input to be parsed.\n     * @param info The parse info.\n     *\n     * @returns The parsed output.\n     */\n    _parse(input, info) {\n      if (typeof input !== \"undefined\") {\n        return getSchemaIssues(\n          info,\n          \"type\",\n          \"undefined\",\n          error || \"Invalid type\",\n          input\n        );\n      }\n      return getOutput(input);\n    }\n  };\n}\nvar undefinedType = undefined_;\n\n// src/schemas/undefined/undefinedAsync.ts\nfunction undefinedAsync(error) {\n  return {\n    /**\n     * The schema type.\n     */\n    type: \"undefined\",\n    /**\n     * Whether it's async.\n     */\n    async: true,\n    /**\n     * Parses unknown input based on its schema.\n     *\n     * @param input The input to be parsed.\n     * @param info The parse info.\n     *\n     * @returns The parsed output.\n     */\n    async _parse(input, info) {\n      if (typeof input !== \"undefined\") {\n        return getSchemaIssues(\n          info,\n          \"type\",\n          \"undefined\",\n          error || \"Invalid type\",\n          input\n        );\n      }\n      return getOutput(input);\n    }\n  };\n}\nvar undefinedTypeAsync = undefinedAsync;\n\n// src/schemas/union/union.ts\nfunction union(options, error) {\n  return {\n    /**\n     * The schema type.\n     */\n    type: \"union\",\n    /**\n     * The union options.\n     */\n    options,\n    /**\n     * Whether it's async.\n     */\n    async: false,\n    /**\n     * Parses unknown input based on its schema.\n     *\n     * @param input The input to be parsed.\n     * @param info The parse info.\n     *\n     * @returns The parsed output.\n     */\n    _parse(input, info) {\n      let issues;\n      let output;\n      for (const schema of options) {\n        const result = schema._parse(input, info);\n        if (result.issues) {\n          if (issues) {\n            for (const issue of result.issues) {\n              issues.push(issue);\n            }\n          } else {\n            issues = result.issues;\n          }\n        } else {\n          output = [result.output];\n          break;\n        }\n      }\n      return output ? getOutput(output[0]) : getSchemaIssues(\n        info,\n        \"type\",\n        \"union\",\n        error || \"Invalid type\",\n        input,\n        issues\n      );\n    }\n  };\n}\n\n// src/schemas/union/unionAsync.ts\nfunction unionAsync(options, error) {\n  return {\n    /**\n     * The schema type.\n     */\n    type: \"union\",\n    /**\n     * The union options.\n     */\n    options,\n    /**\n     * Whether it's async.\n     */\n    async: true,\n    /**\n     * Parses unknown input based on its schema.\n     *\n     * @param input The input to be parsed.\n     * @param info The parse info.\n     *\n     * @returns The parsed output.\n     */\n    async _parse(input, info) {\n      let issues;\n      let output;\n      for (const schema of options) {\n        const result = await schema._parse(input, info);\n        if (result.issues) {\n          if (issues) {\n            for (const issue of result.issues) {\n              issues.push(issue);\n            }\n          } else {\n            issues = result.issues;\n          }\n        } else {\n          output = [result.output];\n          break;\n        }\n      }\n      return output ? getOutput(output[0]) : getSchemaIssues(\n        info,\n        \"type\",\n        \"union\",\n        error || \"Invalid type\",\n        input,\n        issues\n      );\n    }\n  };\n}\n\n// src/schemas/unknown/unknown.ts\nfunction unknown(pipe = []) {\n  return {\n    /**\n     * The schema type.\n     */\n    type: \"unknown\",\n    /**\n     * Whether it's async.\n     */\n    async: false,\n    /**\n     * Parses unknown input based on its schema.\n     *\n     * @param input The input to be parsed.\n     * @param info The parse info.\n     *\n     * @returns The parsed output.\n     */\n    _parse(input, info) {\n      return executePipe(input, pipe, info, \"unknown\");\n    }\n  };\n}\n\n// src/schemas/unknown/unknownAsync.ts\nfunction unknownAsync(pipe = []) {\n  return {\n    /**\n     * The schema type.\n     */\n    type: \"unknown\",\n    /**\n     * Whether it's async.\n     */\n    async: true,\n    /**\n     * Parses unknown input based on its schema.\n     *\n     * @param input The input to be parsed.\n     * @param info The parse info.\n     *\n     * @returns The parsed output.\n     */\n    async _parse(input, info) {\n      return executePipeAsync(input, pipe, info, \"unknown\");\n    }\n  };\n}\n\n// src/schemas/variant/variant.ts\nfunction variant(key, options, error) {\n  return {\n    /**\n     * The schema type.\n     */\n    type: \"variant\",\n    /**\n     * The variant options.\n     */\n    options,\n    /**\n     * Whether it's async.\n     */\n    async: false,\n    /**\n     * Parses unknown input based on its schema.\n     *\n     * @param input The input to be parsed.\n     * @param info The parse info.\n     *\n     * @returns The parsed output.\n     */\n    _parse(input, info) {\n      if (!input || typeof input !== \"object\" || !(key in input)) {\n        return getSchemaIssues(\n          info,\n          \"type\",\n          \"variant\",\n          error || \"Invalid type\",\n          input\n        );\n      }\n      let issues;\n      let output;\n      const parseOptions = (options2) => {\n        for (const schema of options2) {\n          if (schema.type === \"object\") {\n            const result = schema.entries[key]._parse(\n              input[key],\n              info\n            );\n            if (!result.issues) {\n              const result2 = schema._parse(input, info);\n              if (result2.issues) {\n                issues = result2.issues;\n              } else {\n                output = [result2.output];\n              }\n              break;\n            }\n          } else if (schema.type === \"variant\") {\n            parseOptions(schema.options);\n            if (issues || output) {\n              break;\n            }\n          }\n        }\n      };\n      parseOptions(options);\n      return output ? getOutput(output[0]) : issues ? getIssues(issues) : getSchemaIssues(\n        info,\n        \"type\",\n        \"variant\",\n        error || \"Invalid type\",\n        input\n      );\n    }\n  };\n}\nvar discriminatedUnion = variant;\n\n// src/schemas/variant/variantAsync.ts\nfunction variantAsync(key, options, error) {\n  return {\n    /**\n     * The schema type.\n     */\n    type: \"variant\",\n    /**\n     * The variant options.\n     */\n    options,\n    /**\n     * Whether it's async.\n     */\n    async: true,\n    /**\n     * Parses unknown input based on its schema.\n     *\n     * @param input The input to be parsed.\n     * @param info The parse info.\n     *\n     * @returns The parsed output.\n     */\n    async _parse(input, info) {\n      if (!input || typeof input !== \"object\" || !(key in input)) {\n        return getSchemaIssues(\n          info,\n          \"type\",\n          \"variant\",\n          error || \"Invalid type\",\n          input\n        );\n      }\n      let issues;\n      let output;\n      const parseOptions = async (options2) => {\n        for (const schema of options2) {\n          if (schema.type === \"object\") {\n            const result = await schema.entries[key]._parse(\n              input[key],\n              info\n            );\n            if (!result.issues) {\n              const result2 = await schema._parse(input, info);\n              if (result2.issues) {\n                issues = result2.issues;\n              } else {\n                output = [result2.output];\n              }\n              break;\n            }\n          } else if (schema.type === \"variant\") {\n            await parseOptions(schema.options);\n            if (issues || output) {\n              break;\n            }\n          }\n        }\n      };\n      await parseOptions(options);\n      return output ? getOutput(output[0]) : issues ? getIssues(issues) : getSchemaIssues(\n        info,\n        \"type\",\n        \"variant\",\n        error || \"Invalid type\",\n        input\n      );\n    }\n  };\n}\nvar discriminatedUnionAsync = variantAsync;\n\n// src/schemas/void/void.ts\nfunction void_(error) {\n  return {\n    /**\n     * The schema type.\n     */\n    type: \"void\",\n    /**\n     * Whether it's async.\n     */\n    async: false,\n    /**\n     * Parses unknown input based on its schema.\n     *\n     * @param input The input to be parsed.\n     * @param info The parse info.\n     *\n     * @returns The parsed output.\n     */\n    _parse(input, info) {\n      if (typeof input !== \"undefined\") {\n        return getSchemaIssues(\n          info,\n          \"type\",\n          \"void\",\n          error || \"Invalid type\",\n          input\n        );\n      }\n      return getOutput(input);\n    }\n  };\n}\nvar voidType = void_;\n\n// src/schemas/void/voidAsync.ts\nfunction voidAsync(error) {\n  return {\n    /**\n     * The schema type.\n     */\n    type: \"void\",\n    /**\n     * Whether it's async.\n     */\n    async: true,\n    /**\n     * Parses unknown input based on its schema.\n     *\n     * @param input The input to be parsed.\n     * @param info The parse info.\n     *\n     * @returns The parsed output.\n     */\n    async _parse(input, info) {\n      if (typeof input !== \"undefined\") {\n        return getSchemaIssues(\n          info,\n          \"type\",\n          \"void\",\n          error || \"Invalid type\",\n          input\n        );\n      }\n      return getOutput(input);\n    }\n  };\n}\nvar voidTypeAsync = voidAsync;\n\n// src/methods/keyof/keyof.ts\nfunction keyof(schema) {\n  return picklist(\n    Object.keys(schema.entries)\n  );\n}\n\n// src/methods/merge/merge.ts\nfunction merge(schemas, arg2, arg3, arg4) {\n  const [rest, error, pipe] = getRestAndDefaultArgs(arg2, arg3, arg4);\n  return object(\n    schemas.reduce(\n      (entries, schema) => ({ ...entries, ...schema.entries }),\n      {}\n    ),\n    rest,\n    error,\n    pipe\n  );\n}\n\n// src/methods/merge/mergeAsync.ts\nfunction mergeAsync(schemas, arg2, arg3, arg4) {\n  const [rest, error, pipe] = getRestAndDefaultArgs(arg2, arg3, arg4);\n  return objectAsync(\n    schemas.reduce(\n      (entries, schema) => ({ ...entries, ...schema.entries }),\n      {}\n    ),\n    rest,\n    error,\n    pipe\n  );\n}\n\n// src/methods/omit/omit.ts\nfunction omit(schema, keys, arg3, arg4, arg5) {\n  const [rest, error, pipe] = getRestAndDefaultArgs(arg3, arg4, arg5);\n  return object(\n    Object.entries(schema.entries).reduce(\n      (entries, [key, schema2]) => keys.includes(key) ? entries : { ...entries, [key]: schema2 },\n      {}\n    ),\n    rest,\n    error,\n    pipe\n  );\n}\n\n// src/methods/omit/omitAsync.ts\nfunction omitAsync(schema, keys, arg3, arg4, arg5) {\n  const [rest, error, pipe] = getRestAndDefaultArgs(arg3, arg4, arg5);\n  return objectAsync(\n    Object.entries(schema.entries).reduce(\n      (entries, [key, schema2]) => keys.includes(key) ? entries : { ...entries, [key]: schema2 },\n      {}\n    ),\n    rest,\n    error,\n    pipe\n  );\n}\n\n// src/methods/parse/parse.ts\nfunction parse(schema, input, info) {\n  const result = schema._parse(input, info);\n  if (result.issues) {\n    throw new ValiError(result.issues);\n  }\n  return result.output;\n}\n\n// src/methods/parse/parseAsync.ts\nasync function parseAsync(schema, input, info) {\n  const result = await schema._parse(input, info);\n  if (result.issues) {\n    throw new ValiError(result.issues);\n  }\n  return result.output;\n}\n\n// src/methods/partial/partial.ts\nfunction partial(schema, arg2, arg3, arg4) {\n  const [rest, error, pipe] = getRestAndDefaultArgs(arg2, arg3, arg4);\n  return object(\n    Object.entries(schema.entries).reduce(\n      (entries, [key, schema2]) => ({\n        ...entries,\n        [key]: optional(schema2)\n      }),\n      {}\n    ),\n    rest,\n    error,\n    pipe\n  );\n}\n\n// src/methods/partial/partialAsync.ts\nfunction partialAsync(schema, arg2, arg3, arg4) {\n  const [rest, error, pipe] = getRestAndDefaultArgs(arg2, arg3, arg4);\n  return objectAsync(\n    Object.entries(schema.entries).reduce(\n      (entries, [key, schema2]) => ({\n        ...entries,\n        [key]: optionalAsync(schema2)\n      }),\n      {}\n    ),\n    rest,\n    error,\n    pipe\n  );\n}\n\n// src/methods/passthrough/passthrough.ts\nfunction passthrough(schema) {\n  return {\n    ...schema,\n    /**\n     * Parses unknown input based on its schema.\n     *\n     * @param input The input to be parsed.\n     * @param info The parse info.\n     *\n     * @returns The parsed output.\n     */\n    _parse(input, info) {\n      const result = schema._parse(input, info);\n      return !result.issues ? getOutput({ ...input, ...result.output }) : result;\n    }\n  };\n}\n\n// src/methods/passthrough/passthroughAsync.ts\nfunction passthroughAsync(schema) {\n  return {\n    ...schema,\n    /**\n     * Parses unknown input based on its schema.\n     *\n     * @param input The input to be parsed.\n     * @param info The parse info.\n     *\n     * @returns The parsed output.\n     */\n    async _parse(input, info) {\n      const result = await schema._parse(input, info);\n      return !result.issues ? getOutput({ ...input, ...result.output }) : result;\n    }\n  };\n}\n\n// src/methods/pick/pick.ts\nfunction pick(schema, keys, arg3, arg4, arg5) {\n  const [rest, error, pipe] = getRestAndDefaultArgs(arg3, arg4, arg5);\n  return object(\n    Object.entries(schema.entries).reduce(\n      (entries, [key, schema2]) => keys.includes(key) ? { ...entries, [key]: schema2 } : entries,\n      {}\n    ),\n    rest,\n    error,\n    pipe\n  );\n}\n\n// src/methods/pick/pickAsync.ts\nfunction pickAsync(schema, keys, arg3, arg4, arg5) {\n  const [rest, error, pipe] = getRestAndDefaultArgs(arg3, arg4, arg5);\n  return objectAsync(\n    Object.entries(schema.entries).reduce(\n      (entries, [key, schema2]) => keys.includes(key) ? { ...entries, [key]: schema2 } : entries,\n      {}\n    ),\n    rest,\n    error,\n    pipe\n  );\n}\n\n// src/methods/required/required.ts\nfunction required(schema, arg2, arg3, arg4) {\n  const [rest, error, pipe] = getRestAndDefaultArgs(arg2, arg3, arg4);\n  return object(\n    Object.entries(schema.entries).reduce(\n      (entries, [key, schema2]) => ({\n        ...entries,\n        [key]: nonOptional(schema2)\n      }),\n      {}\n    ),\n    rest,\n    error,\n    pipe\n  );\n}\n\n// src/methods/required/requiredAsync.ts\nfunction requiredAsync(schema, arg2, arg3, arg4) {\n  const [rest, error, pipe] = getRestAndDefaultArgs(arg2, arg3, arg4);\n  return objectAsync(\n    Object.entries(schema.entries).reduce(\n      (entries, [key, schema2]) => ({\n        ...entries,\n        [key]: nonOptionalAsync(schema2)\n      }),\n      {}\n    ),\n    rest,\n    error,\n    pipe\n  );\n}\n\n// src/methods/safeParse/safeParse.ts\nfunction safeParse(schema, input, info) {\n  const result = schema._parse(input, info);\n  return result.issues ? {\n    success: false,\n    error: new ValiError(result.issues),\n    issues: result.issues\n  } : {\n    success: true,\n    data: result.output,\n    output: result.output\n  };\n}\n\n// src/methods/safeParse/safeParseAsync.ts\nasync function safeParseAsync(schema, input, info) {\n  const result = await schema._parse(input, info);\n  return result.issues ? {\n    success: false,\n    error: new ValiError(result.issues),\n    issues: result.issues\n  } : {\n    success: true,\n    data: result.output,\n    output: result.output\n  };\n}\n\n// src/methods/strict/strict.ts\nfunction strict(schema, error) {\n  return {\n    ...schema,\n    /**\n     * Parses unknown input based on its schema.\n     *\n     * @param input The input to be parsed.\n     * @param info The parse info.\n     *\n     * @returns The parsed output.\n     */\n    _parse(input, info) {\n      const result = schema._parse(input, info);\n      return !result.issues && Object.keys(input).some((key) => !(key in schema.entries)) ? getSchemaIssues(\n        info,\n        \"object\",\n        \"strict\",\n        error || \"Invalid keys\",\n        input\n      ) : result;\n    }\n  };\n}\n\n// src/methods/strict/strictAsync.ts\nfunction strictAsync(schema, error) {\n  return {\n    ...schema,\n    /**\n     * Parses unknown input based on its schema.\n     *\n     * @param input The input to be parsed.\n     * @param info The parse info.\n     *\n     * @returns The parsed output.\n     */\n    async _parse(input, info) {\n      const result = await schema._parse(input, info);\n      return !result.issues && Object.keys(input).some((key) => !(key in schema.entries)) ? getSchemaIssues(\n        info,\n        \"object\",\n        \"strict\",\n        error || \"Invalid keys\",\n        input\n      ) : result;\n    }\n  };\n}\n\n// src/methods/strip/strip.ts\nfunction strip(schema) {\n  let cachedKeys;\n  return {\n    ...schema,\n    /**\n     * Parses unknown input based on its schema.\n     *\n     * @param input The input to be parsed.\n     * @param info The parse info.\n     *\n     * @returns The parsed output.\n     */\n    _parse(input, info) {\n      const result = schema._parse(input, info);\n      if (result.issues) {\n        return result;\n      }\n      cachedKeys = cachedKeys || Object.keys(schema.entries);\n      const output = {};\n      for (const key of cachedKeys) {\n        output[key] = result.output[key];\n      }\n      return getOutput(output);\n    }\n  };\n}\n\n// src/methods/strip/stripAsync.ts\nfunction stripAsync(schema) {\n  let cachedKeys;\n  return {\n    ...schema,\n    /**\n     * Parses unknown input based on its schema.\n     *\n     * @param input The input to be parsed.\n     * @param info The parse info.\n     *\n     * @returns The parsed output.\n     */\n    async _parse(input, info) {\n      const result = await schema._parse(input, info);\n      if (result.issues) {\n        return result;\n      }\n      cachedKeys = cachedKeys || Object.keys(schema.entries);\n      const output = {};\n      for (const key of cachedKeys) {\n        output[key] = result.output[key];\n      }\n      return getOutput(output);\n    }\n  };\n}\n\n// src/methods/transform/transform.ts\nfunction transform(schema, action, arg1) {\n  return {\n    ...schema,\n    /**\n     * Parses unknown input based on its schema.\n     *\n     * @param input The input to be parsed.\n     * @param info The parse info.\n     *\n     * @returns The parsed output.\n     */\n    _parse(input, info) {\n      const result = schema._parse(input, info);\n      if (result.issues) {\n        return result;\n      }\n      const output = action(result.output);\n      if (arg1 && !Array.isArray(arg1)) {\n        return arg1._parse(output, info);\n      }\n      return executePipe(output, arg1, info, typeof output);\n    }\n  };\n}\n\n// src/methods/transform/transformAsync.ts\nfunction transformAsync(schema, action, arg1) {\n  return {\n    ...schema,\n    /**\n     * Whether it's async.\n     */\n    async: true,\n    /**\n     * Parses unknown input based on its schema.\n     *\n     * @param input The input to be parsed.\n     * @param info The parse info.\n     *\n     * @returns The parsed output.\n     */\n    async _parse(input, info) {\n      const result = await schema._parse(input, info);\n      if (result.issues) {\n        return result;\n      }\n      const output = await action(result.output);\n      if (arg1 && !Array.isArray(arg1)) {\n        return arg1._parse(output, info);\n      }\n      return executePipeAsync(output, arg1, info, typeof output);\n    }\n  };\n}\n\n// src/methods/unwrap/unwrap.ts\nfunction unwrap(schema) {\n  return schema.wrapped;\n}\n\n// src/methods/withDefault/withDefault.ts\nfunction withDefault(schema, value2) {\n  return {\n    ...schema,\n    /**\n     * Parses unknown input based on its schema.\n     *\n     * @param input The input to be parsed.\n     * @param info The parse info.\n     *\n     * @returns The parsed output.\n     */\n    _parse(input, info) {\n      return schema._parse(\n        input === void 0 ? typeof value2 === \"function\" ? value2() : value2 : input,\n        info\n      );\n    }\n  };\n}\nvar useDefault = withDefault;\n\n// src/regex.ts\nvar CUID2_REGEX = /^[a-z][\\da-z]*$/u;\nvar EMAIL_REGEX = /^[\\w+-]+(?:\\.[\\w+-]+)*@[\\da-z]+(?:[.-][\\da-z]+)*\\.[a-z]{2,}$/iu;\nvar EMOJI_REGEX = /^[\\p{Extended_Pictographic}\\p{Emoji_Component}]+$/u;\nvar IMEI_REGEX = /^\\d{2}(?:[ /|-]?\\d{6}){2}[ /|-]?\\d$/u;\nvar IPV4_REGEX = (\n  // eslint-disable-next-line redos-detector/no-unsafe-regex -- false positive\n  /^(?:(?:[1-9]|1\\d|2[0-4])?\\d|25[0-5])(?:\\.(?:(?:[1-9]|1\\d|2[0-4])?\\d|25[0-5])){3}$/u\n);\nvar IPV6_REGEX = /^(?:(?:[\\da-f]{1,4}:){7}[\\da-f]{1,4}|(?:[\\da-f]{1,4}:){1,7}:|(?:[\\da-f]{1,4}:){1,6}:[\\da-f]{1,4}|(?:[\\da-f]{1,4}:){1,5}(?::[\\da-f]{1,4}){1,2}|(?:[\\da-f]{1,4}:){1,4}(?::[\\da-f]{1,4}){1,3}|(?:[\\da-f]{1,4}:){1,3}(?::[\\da-f]{1,4}){1,4}|(?:[\\da-f]{1,4}:){1,2}(?::[\\da-f]{1,4}){1,5}|[\\da-f]{1,4}:(?::[\\da-f]{1,4}){1,6}|:(?:(?::[\\da-f]{1,4}){1,7}|:)|fe80:(?::[\\da-f]{0,4}){0,4}%[\\da-z]+|::(?:f{4}(?::0{1,4})?:)?(?:(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d)\\.){3}(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d)|(?:[\\da-f]{1,4}:){1,4}:(?:(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d)\\.){3}(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d))$/iu;\nvar ISO_DATE_REGEX = /^\\d{4}-(?:0[1-9]|1[0-2])-(?:[12]\\d|0[1-9]|3[01])$/u;\nvar ISO_DATE_TIME_REGEX = /^\\d{4}-(?:0[1-9]|1[0-2])-(?:[12]\\d|0[1-9]|3[01])T(?:0\\d|1\\d|2[0-3]):[0-5]\\d$/u;\nvar ISO_TIME_REGEX = /^(?:0\\d|1\\d|2[0-3]):[0-5]\\d$/u;\nvar ISO_TIME_SECOND_REGEX = /^(?:0\\d|1\\d|2[0-3])(?::[0-5]\\d){2}$/u;\nvar ISO_TIMESTAMP_REGEX = /^\\d{4}-(?:0[1-9]|1[0-2])-(?:[12]\\d|0[1-9]|3[01])T(?:0\\d|1\\d|2[0-3])(?::[0-5]\\d){2}\\.\\d{3}Z$/u;\nvar ISO_WEEK_REGEX = /^\\d{4}-W(?:0[1-9]|[1-4]\\d|5[0-3])$/u;\nvar ULID_REGEX = /^[\\da-hjkmnp-tv-z]{26}$/iu;\nvar UUID_REGEX = /^[\\da-f]{8}(?:-[\\da-f]{4}){3}-[\\da-f]{12}$/iu;\n\n// src/transformations/toCustom/toCustom.ts\nfunction toCustom(action) {\n  return (input) => getOutput(action(input));\n}\n\n// src/transformations/toCustom/toCustomAsync.ts\nfunction toCustomAsync(action) {\n  return async (input) => getOutput(await action(input));\n}\n\n// src/transformations/toLowerCase/toLowerCase.ts\nfunction toLowerCase() {\n  return (input) => getOutput(input.toLocaleLowerCase());\n}\n\n// src/transformations/toMaxValue/toMaxValue.ts\nfunction toMaxValue(requirement) {\n  return (input) => getOutput(input > requirement ? requirement : input);\n}\n\n// src/transformations/toMinValue/toMinValue.ts\nfunction toMinValue(requirement) {\n  return (input) => getOutput(input < requirement ? requirement : input);\n}\n\n// src/transformations/toTrimmed/toTrimmed.ts\nfunction toTrimmed() {\n  return (input) => getOutput(input.trim());\n}\n\n// src/transformations/toTrimmedEnd/toTrimmedEnd.ts\nfunction toTrimmedEnd() {\n  return (input) => getOutput(input.trimEnd());\n}\n\n// src/transformations/toTrimmedStart/toTrimmedStart.ts\nfunction toTrimmedStart() {\n  return (input) => getOutput(input.trimStart());\n}\n\n// src/transformations/toUpperCase/toUpperCase.ts\nfunction toUpperCase() {\n  return (input) => getOutput(input.toUpperCase());\n}\n\n// src/validations/bytes/bytes.ts\nfunction bytes(requirement, error) {\n  return (input) => new TextEncoder().encode(input).length !== requirement ? getPipeIssues(\"bytes\", error || \"Invalid byte length\", input) : getOutput(input);\n}\n\n// src/validations/cuid2/cuid2.ts\nfunction cuid2(error) {\n  return (input) => !CUID2_REGEX.test(input) ? getPipeIssues(\"cuid2\", error || \"Invalid cuid2\", input) : getOutput(input);\n}\n\n// src/validations/custom/custom.ts\nfunction custom(requirement, error) {\n  return (input) => !requirement(input) ? getPipeIssues(\"custom\", error || \"Invalid input\", input) : getOutput(input);\n}\n\n// src/validations/custom/customAsync.ts\nfunction customAsync(requirement, error) {\n  return async (input) => !await requirement(input) ? getPipeIssues(\"custom\", error || \"Invalid input\", input) : getOutput(input);\n}\n\n// src/validations/email/email.ts\nfunction email(error) {\n  return (input) => !EMAIL_REGEX.test(input) ? getPipeIssues(\"email\", error || \"Invalid email\", input) : getOutput(input);\n}\n\n// src/validations/emoji/emoji.ts\nfunction emoji(error) {\n  return (input) => !EMOJI_REGEX.test(input) ? getPipeIssues(\"emoji\", error || \"Invalid emoji\", input) : getOutput(input);\n}\n\n// src/validations/endsWith/endsWith.ts\nfunction endsWith(requirement, error) {\n  return (input) => !input.endsWith(requirement) ? getPipeIssues(\"ends_with\", error || \"Invalid end\", input) : getOutput(input);\n}\n\n// src/validations/equal/equal.ts\nfunction equal(requirement, error) {\n  return (input) => input !== requirement ? getPipeIssues(\"equal\", error || \"Invalid input\", input) : getOutput(input);\n}\n\n// src/validations/excludes/excludes.ts\nfunction excludes(requirement, error) {\n  return (input) => input.includes(requirement) ? getPipeIssues(\"excludes\", error || \"Invalid content\", input) : getOutput(input);\n}\n\n// src/validations/finite/finite.ts\nfunction finite(error) {\n  return (input) => !Number.isFinite(input) ? getPipeIssues(\"finite\", error || \"Invalid finite number\", input) : getOutput(input);\n}\n\n// src/validations/imei/imei.ts\nfunction imei(error) {\n  return (input) => !IMEI_REGEX.test(input) || !isLuhnAlgo(input) ? getPipeIssues(\"imei\", error || \"Invalid IMEI\", input) : getOutput(input);\n}\n\n// src/validations/includes/includes.ts\nfunction includes(requirement, error) {\n  return (input) => !input.includes(requirement) ? getPipeIssues(\"includes\", error || \"Invalid content\", input) : getOutput(input);\n}\n\n// src/validations/integer/integer.ts\nfunction integer(error) {\n  return (input) => !Number.isInteger(input) ? getPipeIssues(\"integer\", error || \"Invalid integer\", input) : getOutput(input);\n}\n\n// src/validations/ip/ip.ts\nfunction ip(error) {\n  return (input) => !IPV4_REGEX.test(input) && !IPV6_REGEX.test(input) ? getPipeIssues(\"ip\", error || \"Invalid IP\", input) : getOutput(input);\n}\n\n// src/validations/ipv4/ipv4.ts\nfunction ipv4(error) {\n  return (input) => !IPV4_REGEX.test(input) ? getPipeIssues(\"ipv4\", error || \"Invalid IP v4\", input) : getOutput(input);\n}\n\n// src/validations/ipv6/ipv6.ts\nfunction ipv6(error) {\n  return (input) => !IPV6_REGEX.test(input) ? getPipeIssues(\"ipv6\", error || \"Invalid IP v6\", input) : getOutput(input);\n}\n\n// src/validations/isoDate/isoDate.ts\nfunction isoDate(error) {\n  return (input) => !ISO_DATE_REGEX.test(input) ? getPipeIssues(\"iso_date\", error || \"Invalid date\", input) : getOutput(input);\n}\n\n// src/validations/isoDateTime/isoDateTime.ts\nfunction isoDateTime(error) {\n  return (input) => !ISO_DATE_TIME_REGEX.test(input) ? getPipeIssues(\"iso_date_time\", error || \"Invalid datetime\", input) : getOutput(input);\n}\n\n// src/validations/isoTime/isoTime.ts\nfunction isoTime(error) {\n  return (input) => !ISO_TIME_REGEX.test(input) ? getPipeIssues(\"iso_time\", error || \"Invalid time\", input) : getOutput(input);\n}\n\n// src/validations/isoTimeSecond/isoTimeSecond.ts\nfunction isoTimeSecond(error) {\n  return (input) => !ISO_TIME_SECOND_REGEX.test(input) ? getPipeIssues(\"iso_time_second\", error || \"Invalid time\", input) : getOutput(input);\n}\n\n// src/validations/isoTimestamp/isoTimestamp.ts\nfunction isoTimestamp(error) {\n  return (input) => !ISO_TIMESTAMP_REGEX.test(input) ? getPipeIssues(\"iso_timestamp\", error || \"Invalid timestamp\", input) : getOutput(input);\n}\n\n// src/validations/isoWeek/isoWeek.ts\nfunction isoWeek(error) {\n  return (input) => !ISO_WEEK_REGEX.test(input) ? getPipeIssues(\"iso_week\", error || \"Invalid week\", input) : getOutput(input);\n}\n\n// src/validations/length/length.ts\nfunction length(requirement, error) {\n  return (input) => input.length !== requirement ? getPipeIssues(\"length\", error || \"Invalid length\", input) : getOutput(input);\n}\n\n// src/validations/maxBytes/maxBytes.ts\nfunction maxBytes(requirement, error) {\n  return (input) => new TextEncoder().encode(input).length > requirement ? getPipeIssues(\"max_bytes\", error || \"Invalid byte length\", input) : getOutput(input);\n}\n\n// src/validations/maxLength/maxLength.ts\nfunction maxLength(requirement, error) {\n  return (input) => input.length > requirement ? getPipeIssues(\"max_length\", error || \"Invalid length\", input) : getOutput(input);\n}\n\n// src/validations/maxSize/maxSize.ts\nfunction maxSize(requirement, error) {\n  return (input) => input.size > requirement ? getPipeIssues(\"max_size\", error || \"Invalid size\", input) : getOutput(input);\n}\n\n// src/validations/maxValue/maxValue.ts\nfunction maxValue(requirement, error) {\n  return (input) => input > requirement ? getPipeIssues(\"max_value\", error || \"Invalid value\", input) : getOutput(input);\n}\nvar maxRange = maxValue;\n\n// src/validations/minBytes/minBytes.ts\nfunction minBytes(requirement, error) {\n  return (input) => new TextEncoder().encode(input).length < requirement ? getPipeIssues(\"min_bytes\", error || \"Invalid byte length\", input) : getOutput(input);\n}\n\n// src/validations/mimeType/mimeType.ts\nfunction mimeType(requirement, error) {\n  return (input) => !requirement.includes(input.type) ? getPipeIssues(\"mime_type\", error || \"Invalid MIME type\", input) : getOutput(input);\n}\n\n// src/validations/minLength/minLength.ts\nfunction minLength(requirement, error) {\n  return (input) => input.length < requirement ? getPipeIssues(\"min_length\", error || \"Invalid length\", input) : getOutput(input);\n}\n\n// src/validations/minSize/minSize.ts\nfunction minSize(requirement, error) {\n  return (input) => input.size < requirement ? getPipeIssues(\"min_size\", error || \"Invalid size\", input) : getOutput(input);\n}\n\n// src/validations/minValue/minValue.ts\nfunction minValue(requirement, error) {\n  return (input) => input < requirement ? getPipeIssues(\"min_value\", error || \"Invalid value\", input) : getOutput(input);\n}\nvar minRange = minValue;\n\n// src/validations/multipleOf/multipleOf.ts\nfunction multipleOf(requirement, error) {\n  return (input) => input % requirement !== 0 ? getPipeIssues(\"multiple_of\", error || \"Invalid multiple\", input) : getOutput(input);\n}\n\n// src/validations/notBytes/notBytes.ts\nfunction notBytes(requirement, error) {\n  return (input) => new TextEncoder().encode(input).length === requirement ? getPipeIssues(\"not_bytes\", error || \"Invalid byte length\", input) : getOutput(input);\n}\n\n// src/validations/notLength/notLength.ts\nfunction notLength(requirement, error) {\n  return (input) => input.length === requirement ? getPipeIssues(\"not_length\", error || \"Invalid length\", input) : getOutput(input);\n}\n\n// src/validations/notSize/notSize.ts\nfunction notSize(requirement, error) {\n  return (input) => input.size === requirement ? getPipeIssues(\"not_size\", error || \"Invalid size\", input) : getOutput(input);\n}\n\n// src/validations/notValue/notValue.ts\nfunction notValue(requirement, error) {\n  return (input) => input === requirement ? getPipeIssues(\"not_value\", error || \"Invalid value\", input) : getOutput(input);\n}\n\n// src/validations/regex/regex.ts\nfunction regex(requirement, error) {\n  return (input) => !requirement.test(input) ? getPipeIssues(\"regex\", error || \"Invalid regex\", input) : getOutput(input);\n}\n\n// src/validations/safeInteger/safeInteger.ts\nfunction safeInteger(error) {\n  return (input) => !Number.isSafeInteger(input) ? getPipeIssues(\"safe_integer\", error || \"Invalid safe integer\", input) : getOutput(input);\n}\n\n// src/validations/size/size.ts\nfunction size(requirement, error) {\n  return (input) => input.size !== requirement ? getPipeIssues(\"size\", error || \"Invalid size\", input) : getOutput(input);\n}\n\n// src/validations/startsWith/startsWith.ts\nfunction startsWith(requirement, error) {\n  return (input) => !input.startsWith(requirement) ? getPipeIssues(\"starts_with\", error || \"Invalid start\", input) : getOutput(input);\n}\n\n// src/validations/ulid/ulid.ts\nfunction ulid(error) {\n  return (input) => !ULID_REGEX.test(input) ? getPipeIssues(\"ulid\", error || \"Invalid ULID\", input) : getOutput(input);\n}\n\n// src/validations/url/url.ts\nfunction url(error) {\n  return (input) => {\n    try {\n      new URL(input);\n      return getOutput(input);\n    } catch (_) {\n      return getPipeIssues(\"url\", error || \"Invalid URL\", input);\n    }\n  };\n}\n\n// src/validations/uuid/uuid.ts\nfunction uuid(error) {\n  return (input) => !UUID_REGEX.test(input) ? getPipeIssues(\"uuid\", error || \"Invalid UUID\", input) : getOutput(input);\n}\n\n// src/validations/value/value.ts\nfunction value(requirement, error) {\n  return (input) => input !== requirement ? getPipeIssues(\"value\", error || \"Invalid value\", input) : getOutput(input);\n}\nexport {\n  BrandSymbol,\n  CUID2_REGEX,\n  EMAIL_REGEX,\n  EMOJI_REGEX,\n  IMEI_REGEX,\n  IPV4_REGEX,\n  IPV6_REGEX,\n  ISO_DATE_REGEX,\n  ISO_DATE_TIME_REGEX,\n  ISO_TIMESTAMP_REGEX,\n  ISO_TIME_REGEX,\n  ISO_TIME_SECOND_REGEX,\n  ISO_WEEK_REGEX,\n  ULID_REGEX,\n  UUID_REGEX,\n  ValiError,\n  any,\n  anyAsync,\n  array,\n  arrayAsync,\n  bigint,\n  bigintAsync,\n  blob,\n  blobAsync,\n  boolean,\n  booleanAsync,\n  brand,\n  bytes,\n  coerce,\n  coerceAsync,\n  cuid2,\n  custom,\n  customAsync,\n  date,\n  dateAsync,\n  discriminatedUnion,\n  discriminatedUnionAsync,\n  email,\n  emoji,\n  endsWith,\n  enumAsync,\n  enumType,\n  enumTypeAsync,\n  enum_,\n  equal,\n  excludes,\n  executePipe,\n  executePipeAsync,\n  fallback,\n  fallbackAsync,\n  finite,\n  flatten,\n  getDefault,\n  getDefaultArgs,\n  getDefaultAsync,\n  getDefaults,\n  getDefaultsAsync,\n  getFallback,\n  getFallbackAsync,\n  getFallbacks,\n  getFallbacksAsync,\n  getIssues,\n  getOutput,\n  getPipeIssues,\n  getRestAndDefaultArgs,\n  getSchemaIssues,\n  imei,\n  includes,\n  instance,\n  instanceAsync,\n  integer,\n  intersect,\n  intersection,\n  ip,\n  ipv4,\n  ipv6,\n  is,\n  isLuhnAlgo,\n  isoDate,\n  isoDateTime,\n  isoTime,\n  isoTimeSecond,\n  isoTimestamp,\n  isoWeek,\n  keyof,\n  length,\n  literal,\n  literalAsync,\n  map,\n  mapAsync,\n  maxBytes,\n  maxLength,\n  maxRange,\n  maxSize,\n  maxValue,\n  merge,\n  mergeAsync,\n  mimeType,\n  minBytes,\n  minLength,\n  minRange,\n  minSize,\n  minValue,\n  multipleOf,\n  nan,\n  nanAsync,\n  nativeEnum,\n  nativeEnumAsync,\n  never,\n  neverAsync,\n  nonNullable,\n  nonNullableAsync,\n  nonNullish,\n  nonNullishAsync,\n  nonOptional,\n  nonOptionalAsync,\n  notBytes,\n  notLength,\n  notSize,\n  notValue,\n  nullAsync,\n  nullType,\n  nullTypeAsync,\n  null_,\n  nullable,\n  nullableAsync,\n  nullish,\n  nullishAsync,\n  number,\n  numberAsync,\n  object,\n  objectAsync,\n  omit,\n  omitAsync,\n  optional,\n  optionalAsync,\n  parse,\n  parseAsync,\n  partial,\n  partialAsync,\n  passthrough,\n  passthroughAsync,\n  pick,\n  pickAsync,\n  picklist,\n  picklistAsync,\n  record,\n  recordAsync,\n  recursive,\n  recursiveAsync,\n  regex,\n  required,\n  requiredAsync,\n  safeInteger,\n  safeParse,\n  safeParseAsync,\n  set,\n  setAsync,\n  size,\n  special,\n  specialAsync,\n  startsWith,\n  strict,\n  strictAsync,\n  string,\n  stringAsync,\n  strip,\n  stripAsync,\n  symbol,\n  symbolAsync,\n  toCustom,\n  toCustomAsync,\n  toLowerCase,\n  toMaxValue,\n  toMinValue,\n  toTrimmed,\n  toTrimmedEnd,\n  toTrimmedStart,\n  toUpperCase,\n  transform,\n  transformAsync,\n  tuple,\n  tupleAsync,\n  ulid,\n  undefinedAsync,\n  undefinedType,\n  undefinedTypeAsync,\n  undefined_,\n  union,\n  unionAsync,\n  unknown,\n  unknownAsync,\n  unwrap,\n  url,\n  useDefault,\n  uuid,\n  value,\n  variant,\n  variantAsync,\n  voidAsync,\n  voidType,\n  voidTypeAsync,\n  void_,\n  withDefault\n};\n","function n(n){return\"object\"==typeof n&&null!==n&&!Array.isArray(n)}function e(n){return null!==n&&Array.isArray(n)}function t(n){let t=\"\";for(const r of n)\"string\"!=typeof r?\"number\"!=typeof r?e(r)?(t&&(t+=\":\"),t+=`${r.join(\",\")}}`):r._key&&(t&&(t+=\":\"),t+=`${r._key}`):(t&&(t+=\":\"),t+=`${r}`):(t&&(t+=\".\"),t+=r);return t}const r=/^([A-Za-z]+):([0-9]+)$/,o=/^([A-Za-z]+):([0-9]+),([0-9]+)$/,u=/^([A-Za-z]+):([a-z0-9]+)$/;function s(n){const e=[];for(const t of n.split(\".\")){const n=r.exec(t);if(n){e.push(n[1],Number(n[2]));continue}const s=o.exec(t);if(s){e.push(s[1],[Number(s[2]),Number(s[3])]);continue}const c=u.exec(t);c?e.push(c[1],{_key:c[2]}):e.push(t)}return e}export{e as a,n as i,t as p,s as u};//# sourceMappingURL=urlStringToPath-FefM00gz.js.map\n","import{resolveMapping as t,getPublishedId as e,studioPath as r,jsonPathToStudioPath as n,resolvedKeyedSourcePath as o}from\"@sanity/client/csm\";import{string as a,minLength as i,optional as s,object as c,is as u,safeParse as p,parse as f}from\"valibot\";import{p as l,u as d,i as h,a as m}from\"./_chunks/urlStringToPath-FefM00gz.js\";function y(a,i,s,c){const{mapping:u,pathSuffix:p}=t(s,i)||{};if(!u)return;if(\"literal\"===u.source.type)return;if(\"unknown\"===u.source.type)return;const f=i.documents[u.source.document],l=i.paths[u.source.path];return f&&l?{baseUrl:a.baseUrl,workspace:a.workspace,tool:a.tool,type:f._type,id:e(f._id),path:r.toString(n(o({keyedResultPath:c,pathSuffix:p,sourceBasePath:l})))}:void 0}const k=a([i(1)]),_=s(k),b=c({id:k,path:k,type:_,baseUrl:k,workspace:_,tool:_}),w=c({origin:k,href:k,data:_});function v(t){return u(b,t)}function g(t){return u(w,t)}function j(t){const{id:n,path:o,baseUrl:a,tool:i,workspace:s,type:c}=t;if(!v(t))return;return[[\"id\",e(n)],[\"type\",c],[\"path\",l(r.fromString(o))],[\"base\",encodeURIComponent(a)],[\"workspace\",s],[\"tool\",i]].filter((([,t])=>!!t)).map((t=>t.join(\"=\"))).join(\";\")}function S(t){const e=t.split(\";\").reduce(((t,e)=>{const[n,o]=e.split(\"=\");if(!n||!o)return t;switch(n){case\"id\":t.id=o;break;case\"type\":t.type=o;break;case\"path\":t.path=r.toString(d(o));break;case\"base\":t.baseUrl=decodeURIComponent(o);break;case\"tool\":t.tool=o;break;case\"workspace\":t.workspace=o}return t}),{});if(v(e))return e}function U(t){try{return function(t){const e=p(b,t);if(e.success)return e.output;const r=p(w,t);if(r.success)try{const t=new URL(r.output.href,\"undefined\"==typeof document?\"https://example.com\":location.origin);return t.searchParams.size>0?f(b,Object.fromEntries(t.searchParams.entries())):r.output}catch(t){return console.error(\"Failed to parse sanity node\",t),r.output}}(JSON.parse(t))}catch{return S(t)}}const $=[\"_createdAt\",\"_dataset\",\"_id\",\"_key\",\"_originalId\",\"_projectId\",\"_ref\",\"_rev\",\"_strengthenOnPublish\",\"_type\",\"_updatedAt\",\"_weak\"];function O(t){if(void 0!==t){if(null===t)return null;if(h(e=t)&&\"sanity\"===e.$$type$$)return t.value;var e;if(m(t))return t.map((t=>O(t)));if(h(t))return Object.fromEntries(Object.entries(t).map((([t,e])=>$.includes(t)?[t,e]:[t,O(e)])));throw new Error(\"invalid wrapped value\")}}function P(t,e,o,a=[],i=[]){if(void 0!==e)return null===e?null:m(e)?e.map(((e,r)=>P(t,e,o,a.concat(r),i.concat(h(e)&&\"_key\"in e&&\"string\"==typeof e._key?{_key:e._key,_index:r}:r)))):h(e)?Object.fromEntries(Object.entries(e).map((([e,r])=>$.includes(e)?[e,r]:[e,P(t,r,o,a.concat(e),i.concat(e))]))):{$$type$$:\"sanity\",path:r.toString(n(a))||void 0,source:o?y(t,o,a,i):void 0,value:e}}export{U as decodeSanityNodeData,S as decodeSanityString,j as encodeSanityNodeData,g as isValidSanityLegacyNode,v as isValidSanityNode,y as resolveSanityNode,O as unwrapData,P as wrapData};//# sourceMappingURL=csm.js.map\n","import type { HTMLProps, Ref } from 'react'\nimport { createElement, forwardRef } from 'react'\nimport {\n  encodeSanityNodeData,\n  type SourceNode,\n} from 'visual-editing-helpers/csm'\n\nexport interface SanityElementProps {\n  children?: SourceNode | null\n}\n\nexport const SanityElement = forwardRef(function SanityElement(\n  props: { as: string } & SanityElementProps &\n    Omit<HTMLProps<HTMLElement>, 'children'>,\n  ref: Ref<HTMLElement | SVGElement>,\n) {\n  const { as, children: node, ...restProps } = props\n\n  if (node?.source) {\n    return createElement(\n      as,\n      {\n        ...restProps,\n        'data-sanity': encodeSanityNodeData(node.source),\n        ref,\n      },\n      node.value,\n    )\n  }\n\n  return createElement(as, restProps, node?.value)\n})\n","export const svgElements = [\n  'animate',\n  'circle',\n  'defs',\n  'desc',\n  'ellipse',\n  'g',\n  'image',\n  'line',\n  'filter',\n  'marker',\n  'mask',\n  'metadata',\n  'path',\n  'pattern',\n  'polygon',\n  'polyline',\n  'rect',\n  'stop',\n  'svg',\n  'switch',\n  'symbol',\n  'text',\n  'tspan',\n  'use',\n  'view',\n  'clipPath',\n  'feBlend',\n  'feColorMatrix',\n  'feComponentTransfer',\n  'feComposite',\n  'feConvolveMatrix',\n  'feDiffuseLighting',\n  'feDisplacementMap',\n  'feDistantLight',\n  'feDropShadow',\n  'feFlood',\n  'feFuncA',\n  'feFuncB',\n  'feFuncG',\n  'feFuncR',\n  'feGaussianBlur',\n  'feImage',\n  'feMerge',\n  'feMergeNode',\n  'feMorphology',\n  'feOffset',\n  'fePointLight',\n  'feSpecularLighting',\n  'feSpotLight',\n  'feTile',\n  'feTurbulence',\n  'foreignObject',\n  'linearGradient',\n  'radialGradient',\n  'textPath',\n] as const\n","import type {\n  ForwardRefExoticComponent,\n  HTMLProps,\n  ReactElement,\n  Ref,\n  SVGProps,\n} from 'react'\nimport { createElement, forwardRef } from 'react'\n\nimport { htmlElements } from './html'\nimport type { SanityElementProps } from './SanityElement'\nimport { SanityElement } from './SanityElement'\nimport { svgElements } from './svg'\n\nexport type SanityHTMLElements = Record<\n  (typeof htmlElements)[number],\n  ForwardRefExoticComponent<\n    SanityElementProps & Omit<HTMLProps<HTMLElement>, 'children' | 'ref'>\n  >\n>\n\nexport type SanitySVGElements = Record<\n  (typeof svgElements)[number],\n  ForwardRefExoticComponent<\n    SanityElementProps & Omit<SVGProps<SVGElement>, 'children' | 'ref'>\n  >\n>\n\nexport type SanityElements = SanityHTMLElements & SanitySVGElements\n\nfunction isHTMLElement(name: string): name is keyof SanityHTMLElements {\n  return htmlElements.includes(name as any)\n}\n\nfunction isSVGElement(name: string): name is keyof SanitySVGElements {\n  return svgElements.includes(name as any)\n}\n\nconst sanity = new Proxy({} as SanityElements, {\n  get(target: SanityElements, prop: string) {\n    if (isHTMLElement(prop)) {\n      if (target[prop]) return target[prop]\n\n      const SanityComponent = forwardRef(function SanityComponent(\n        props: SanityElementProps &\n          Omit<HTMLProps<HTMLElement>, 'children' | 'ref'>,\n        ref: Ref<HTMLElement>,\n      ): ReactElement {\n        return createElement(SanityElement, { as: prop, ref, ...props })\n      })\n\n      SanityComponent.displayName = `sanity.${prop}`\n\n      target[prop] = SanityComponent\n\n      return SanityComponent\n    }\n\n    if (isSVGElement(prop)) {\n      if (target[prop]) return target[prop]\n\n      const SanityComponent = forwardRef(function SanityComponent(\n        props: SanityElementProps &\n          Omit<SVGProps<SVGElement>, 'children' | 'ref'>,\n        ref: Ref<SVGElement>,\n      ): ReactElement {\n        return createElement(SanityElement, { as: prop, ref, ...props } as any)\n      })\n\n      SanityComponent.displayName = `sanity.${prop}`\n\n      target[prop] = SanityComponent as any\n\n      return SanityComponent\n    }\n\n    throw new Error(`No such element: ${prop}`)\n  },\n})\n\nexport { sanity }\n"],"names":["forwardRef","createElement","getPublishedId","studioPath","jsonPathToStudioPath","resolveMapping","resolvedKeyedSourcePath","htmlElements","getIssues","issues","getOutput","output","getIssue","info","issue","reason","validation","origin","message","input","path","abortEarly","abortPipeEarly","skipPipe","getPipeInfo","executePipe","pipe","parseInfo","length","pipeInfo","action","result","issueInfo","push","getDefaultArgs","arg1","arg2","Array","isArray","getErrorMessage","error","getSchemaIssues","n","e","t","r","join","_key","y","a","i","s","c","mapping","u","pathSuffix","p","source","type","f","documents","document","l","paths","baseUrl","workspace","tool","_type","id","_id","toString","o","keyedResultPath","sourceBasePath","k","async","_parse","requirement","getPipeIssues","_","wrapped","getDefault","default_","override","this","b","entries","arg3","arg4","rest","error2","pipe2","getRestAndDefaultArgs","cachedEntries","Object","key","schema","value2","pathItem","value","unshift","j","v","fromString","encodeURIComponent","filter","map","$","O","h","$$type$$","m","fromEntries","includes","Error","P","concat","_index","SanityElement","props","ref","as","children","node","restProps","encodeSanityNodeData","svgElements","sanity","Proxy","get","target","prop","name","SanityComponent","displayName","isSVGElement"],"mappings":"qBAAOA,mBAAAC,MAAA,iCAAAC,gBAAAC,0BAAAC,oBAAAC,6BAAAC,MAAA,qBAAA,MAAMC,EAAe,CAC1B,IACA,OACA,UACA,OACA,UACA,QACA,QACA,IACA,OACA,MACA,MACA,MACA,aACA,OACA,KACA,SACA,SACA,UACA,OACA,OACA,MACA,WACA,OACA,WACA,KACA,MACA,UACA,MACA,SACA,MACA,KACA,KACA,KACA,QACA,WACA,aACA,SACA,SACA,OACA,KACA,KACA,KACA,KACA,KACA,KACA,OACA,SACA,SACA,KACA,OACA,IACA,SACA,MACA,QACA,MACA,MACA,SACA,QACA,SACA,KACA,OACA,OACA,MACA,OACA,OACA,WACA,OACA,QACA,MACA,WACA,SACA,KACA,WACA,SACA,SACA,IACA,QACA,UACA,MACA,WACA,IACA,KACA,KACA,OACA,IACA,OACA,SACA,UACA,SACA,QACA,SACA,OACA,SACA,QACA,MACA,UACA,MACA,QACA,QACA,KACA,WACA,QACA,KACA,QACA,OACA,QACA,KACA,QACA,IACA,KACA,MACA,QACA,MACA,WC5BF,SAASC,EAAUC,GACjB,MAAO,CAAEA,SACX,CAGA,SAASC,EAAUC,GACjB,MAAO,CAAEA,SACX,CAGA,SAASC,EAASC,EAAMC,GACtB,MAAO,CACLC,OAAQF,GAAME,OACdC,WAAYF,EAAME,WAClBC,OAAQJ,GAAMI,QAAU,QACxBC,QAASJ,EAAMI,QACfC,MAAOL,EAAMK,MACbC,KAAMN,EAAMM,KACZC,WAAYR,GAAMQ,WAClBC,eAAgBT,GAAMS,eACtBC,SAAUV,GAAMU,SAEpB,CAGA,SAASC,EAAYX,EAAME,GACzB,MAAO,CACLA,SACAE,OAAQJ,GAAMI,OACdI,WAAYR,GAAMQ,WAClBC,eAAgBT,GAAMS,eACtBC,SAAUV,GAAMU,SAEpB,CAGA,SAASE,EAAYN,EAAOO,EAAMC,EAAWZ,GAC3C,IAAKW,IAASA,EAAKE,QAAUD,GAAWJ,SACtC,OAAOb,EAAUS,GAEnB,IAAIU,EACApB,EACAE,EAASQ,EACb,IAAK,MAAMW,KAAUJ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","x_google_ignoreList":[1]}
\ No newline at end of file
+{"version":3,"file":"jsx.js","sources":["../src/jsx/html.ts","../../../node_modules/.pnpm/valibot@0.21.0/node_modules/valibot/dist/index.js","../../visual-editing-helpers/dist/_chunks/urlStringToPath-ntyJ_1w6.js","../../visual-editing-helpers/dist/csm.js","../src/jsx/SanityElement.tsx","../src/jsx/svg.ts","../src/jsx/jsx.ts"],"sourcesContent":["export const htmlElements = [\n  'a',\n  'abbr',\n  'address',\n  'area',\n  'article',\n  'aside',\n  'audio',\n  'b',\n  'base',\n  'bdi',\n  'bdo',\n  'big',\n  'blockquote',\n  'body',\n  'br',\n  'button',\n  'canvas',\n  'caption',\n  'cite',\n  'code',\n  'col',\n  'colgroup',\n  'data',\n  'datalist',\n  'dd',\n  'del',\n  'details',\n  'dfn',\n  'dialog',\n  'div',\n  'dl',\n  'dt',\n  'em',\n  'embed',\n  'fieldset',\n  'figcaption',\n  'figure',\n  'footer',\n  'form',\n  'h1',\n  'h2',\n  'h3',\n  'h4',\n  'h5',\n  'h6',\n  'head',\n  'header',\n  'hgroup',\n  'hr',\n  'html',\n  'i',\n  'iframe',\n  'img',\n  'input',\n  'ins',\n  'kbd',\n  'keygen',\n  'label',\n  'legend',\n  'li',\n  'link',\n  'main',\n  'map',\n  'mark',\n  'menu',\n  'menuitem',\n  'meta',\n  'meter',\n  'nav',\n  'noscript',\n  'object',\n  'ol',\n  'optgroup',\n  'option',\n  'output',\n  'p',\n  'param',\n  'picture',\n  'pre',\n  'progress',\n  'q',\n  'rp',\n  'rt',\n  'ruby',\n  's',\n  'samp',\n  'script',\n  'section',\n  'select',\n  'small',\n  'source',\n  'span',\n  'strong',\n  'style',\n  'sub',\n  'summary',\n  'sup',\n  'table',\n  'tbody',\n  'td',\n  'textarea',\n  'tfoot',\n  'th',\n  'thead',\n  'time',\n  'title',\n  'tr',\n  'track',\n  'u',\n  'ul',\n  'var',\n  'video',\n  'wbr',\n  'webview',\n] as const\n","// src/error/flatten/flatten.ts\nfunction flatten(arg1) {\n  return (Array.isArray(arg1) ? arg1 : arg1.issues).reduce(\n    (flatErrors, issue) => {\n      if (issue.path) {\n        if (issue.path.every(\n          ({ key }) => typeof key === \"string\" || typeof key === \"number\"\n        )) {\n          const path = issue.path.map(({ key }) => key).join(\".\");\n          if (flatErrors.nested[path]) {\n            flatErrors.nested[path].push(issue.message);\n          } else {\n            flatErrors.nested[path] = [issue.message];\n          }\n        }\n      } else {\n        if (flatErrors.root) {\n          flatErrors.root.push(issue.message);\n        } else {\n          flatErrors.root = [issue.message];\n        }\n      }\n      return flatErrors;\n    },\n    { nested: {} }\n  );\n}\n\n// src/error/ValiError/ValiError.ts\nvar ValiError = class extends Error {\n  issues;\n  /**\n   * Creates a Valibot error with useful information.\n   *\n   * @param issues The error issues.\n   */\n  constructor(issues) {\n    super(issues[0].message);\n    this.name = \"ValiError\";\n    this.issues = issues;\n  }\n};\n\n// src/methods/brand/brand.ts\nvar BrandSymbol = Symbol(\"brand\");\nfunction brand(schema, name) {\n  return schema;\n}\n\n// src/methods/coerce/coerce.ts\nfunction coerce(schema, action) {\n  return {\n    ...schema,\n    _parse(input, info) {\n      return schema._parse(action(input), info);\n    }\n  };\n}\n\n// src/methods/coerce/coerceAsync.ts\nfunction coerceAsync(schema, action) {\n  return {\n    ...schema,\n    async _parse(input, info) {\n      return schema._parse(await action(input), info);\n    }\n  };\n}\n\n// src/utils/getIssues/getIssues.ts\nfunction getIssues(issues) {\n  return { issues };\n}\n\n// src/utils/getOutput/getOutput.ts\nfunction getOutput(output) {\n  return { output };\n}\n\n// src/utils/executePipe/utils/getIssue/getIssue.ts\nfunction getIssue(info, issue) {\n  return {\n    reason: info?.reason,\n    validation: issue.validation,\n    origin: info?.origin || \"value\",\n    message: issue.message,\n    input: issue.input,\n    path: issue.path,\n    abortEarly: info?.abortEarly,\n    abortPipeEarly: info?.abortPipeEarly,\n    skipPipe: info?.skipPipe\n  };\n}\n\n// src/utils/executePipe/utils/getPipeInfo/getPipeInfo.ts\nfunction getPipeInfo(info, reason) {\n  return {\n    reason,\n    origin: info?.origin,\n    abortEarly: info?.abortEarly,\n    abortPipeEarly: info?.abortPipeEarly,\n    skipPipe: info?.skipPipe\n  };\n}\n\n// src/utils/executePipe/executePipe.ts\nfunction executePipe(input, pipe, parseInfo, reason) {\n  if (!pipe || !pipe.length || parseInfo?.skipPipe) {\n    return getOutput(input);\n  }\n  let pipeInfo;\n  let issues;\n  let output = input;\n  for (const action of pipe) {\n    const result = action._parse(output);\n    if (result.issues) {\n      pipeInfo = pipeInfo || getPipeInfo(parseInfo, reason);\n      for (const issueInfo of result.issues) {\n        const issue = getIssue(pipeInfo, issueInfo);\n        issues ? issues.push(issue) : issues = [issue];\n      }\n      if (pipeInfo.abortEarly || pipeInfo.abortPipeEarly) {\n        break;\n      }\n    } else {\n      output = result.output;\n    }\n  }\n  return issues ? getIssues(issues) : getOutput(output);\n}\n\n// src/utils/executePipe/executePipeAsync.ts\nasync function executePipeAsync(input, pipe, parseInfo, reason) {\n  if (!pipe || !pipe.length || parseInfo?.skipPipe) {\n    return getOutput(input);\n  }\n  let pipeInfo;\n  let issues;\n  let output = input;\n  for (const action of pipe) {\n    const result = await action._parse(output);\n    if (result.issues) {\n      pipeInfo = pipeInfo || getPipeInfo(parseInfo, reason);\n      for (const issueInfo of result.issues) {\n        const issue = getIssue(pipeInfo, issueInfo);\n        issues ? issues.push(issue) : issues = [issue];\n      }\n      if (pipeInfo.abortEarly || pipeInfo.abortPipeEarly) {\n        break;\n      }\n    } else {\n      output = result.output;\n    }\n  }\n  return issues ? getIssues(issues) : getOutput(output);\n}\n\n// src/utils/getDefaultArgs/getDefaultArgs.ts\nfunction getDefaultArgs(arg1, arg2) {\n  return Array.isArray(arg1) ? [void 0, arg1] : [arg1, arg2];\n}\n\n// src/utils/getErrorMessage/getErrorMessage.ts\nfunction getErrorMessage(message) {\n  return typeof message === \"function\" ? message() : message;\n}\n\n// src/utils/getPipeIssues/getPipeIssues.ts\nfunction getPipeIssues(validation, message, input, requirement) {\n  return getIssues([\n    {\n      validation,\n      message: getErrorMessage(message),\n      input,\n      requirement\n    }\n  ]);\n}\n\n// src/utils/getRestAndDefaultArgs/getRestAndDefaultArgs.ts\nfunction getRestAndDefaultArgs(arg1, arg2, arg3) {\n  if (!arg1 || typeof arg1 === \"object\" && !Array.isArray(arg1)) {\n    const [error2, pipe2] = getDefaultArgs(arg2, arg3);\n    return [arg1, error2, pipe2];\n  }\n  const [error, pipe] = getDefaultArgs(\n    arg1,\n    arg2\n  );\n  return [void 0, error, pipe];\n}\n\n// src/utils/getSchemaIssues/getSchemaIssues.ts\nfunction getSchemaIssues(info, reason, validation, message, input, issues) {\n  return {\n    issues: [\n      {\n        reason,\n        validation,\n        origin: info?.origin || \"value\",\n        message: getErrorMessage(message),\n        input,\n        issues,\n        abortEarly: info?.abortEarly,\n        abortPipeEarly: info?.abortPipeEarly,\n        skipPipe: info?.skipPipe\n      }\n    ]\n  };\n}\n\n// src/utils/isLuhnAlgo/isLuhnAlgo.ts\nvar NON_DIGIT_REGEX = /\\D/gu;\nfunction isLuhnAlgo(input) {\n  const number2 = input.replaceAll(NON_DIGIT_REGEX, \"\");\n  let length2 = number2.length;\n  let bit = 1;\n  let sum = 0;\n  while (length2) {\n    const value2 = +number2[--length2];\n    bit ^= 1;\n    sum += bit ? [0, 2, 4, 6, 8, 1, 3, 5, 7, 9][value2] : value2;\n  }\n  return sum % 10 === 0;\n}\n\n// src/methods/getFallback/getFallback.ts\nfunction getFallback(schema, info) {\n  return typeof schema.fallback === \"function\" ? schema.fallback(info) : schema.fallback;\n}\n\n// src/methods/getFallback/getFallbackAsync.ts\nasync function getFallbackAsync(schema, info) {\n  return typeof schema.fallback === \"function\" ? await schema.fallback(info) : schema.fallback;\n}\n\n// src/methods/fallback/fallback.ts\nfunction fallback(schema, fallback2) {\n  return {\n    ...schema,\n    fallback: fallback2,\n    _parse(input, info) {\n      const result = schema._parse(input, info);\n      return getOutput(\n        result.issues ? getFallback(this, { input, issues: result.issues }) : result.output\n      );\n    }\n  };\n}\n\n// src/methods/fallback/fallbackAsync.ts\nfunction fallbackAsync(schema, fallback2) {\n  return {\n    ...schema,\n    fallback: fallback2,\n    async _parse(input, info) {\n      const result = await schema._parse(input, info);\n      return getOutput(\n        result.issues ? await getFallbackAsync(this, { input, issues: result.issues }) : result.output\n      );\n    }\n  };\n}\n\n// src/methods/getDefault/getDefault.ts\nfunction getDefault(schema) {\n  return typeof schema.default === \"function\" ? schema.default() : schema.default;\n}\n\n// src/methods/getDefault/getDefaultAsync.ts\nasync function getDefaultAsync(schema) {\n  return typeof schema.default === \"function\" ? await schema.default() : schema.default;\n}\n\n// src/methods/getDefaults/getDefaults.ts\nfunction getDefaults(schema) {\n  let defaults;\n  if (schema.default) {\n    defaults = getDefault(schema);\n  } else if (\"type\" in schema) {\n    if (schema.type === \"object\") {\n      defaults = {};\n      for (const key in schema.entries) {\n        defaults[key] = getDefaults(schema.entries[key]);\n      }\n    } else if (schema.type === \"tuple\") {\n      defaults = [];\n      for (let key = 0; key < schema.items.length; key++) {\n        defaults.push(getDefaults(schema.items[key]));\n      }\n    }\n  }\n  return defaults;\n}\n\n// src/methods/getDefaults/getDefaultsAsync.ts\nasync function getDefaultsAsync(schema) {\n  let defaults;\n  if (schema.default) {\n    defaults = await getDefaultAsync(schema);\n  } else if (\"type\" in schema) {\n    if (schema.type === \"object\") {\n      defaults = {};\n      for (const key in schema.entries) {\n        defaults[key] = await getDefaultsAsync(schema.entries[key]);\n      }\n    } else if (schema.type === \"tuple\") {\n      defaults = [];\n      for (let key = 0; key < schema.items.length; key++) {\n        defaults.push(await getDefaultsAsync(schema.items[key]));\n      }\n    }\n  }\n  return defaults;\n}\n\n// src/methods/getFallbacks/getFallbacks.ts\nfunction getFallbacks(schema) {\n  let fallbacks;\n  if (schema.fallback) {\n    fallbacks = getFallback(schema);\n  } else if (\"type\" in schema) {\n    if (schema.type === \"object\") {\n      fallbacks = {};\n      for (const key in schema.entries) {\n        fallbacks[key] = getFallbacks(schema.entries[key]);\n      }\n    } else if (schema.type === \"tuple\") {\n      fallbacks = [];\n      for (let key = 0; key < schema.items.length; key++) {\n        fallbacks.push(getFallbacks(schema.items[key]));\n      }\n    }\n  }\n  return fallbacks;\n}\n\n// src/methods/getFallbacks/getFallbacksAsync.ts\nasync function getFallbacksAsync(schema) {\n  let fallbacks;\n  if (schema.fallback) {\n    fallbacks = await getFallbackAsync(schema);\n  } else if (\"type\" in schema) {\n    if (schema.type === \"object\") {\n      fallbacks = {};\n      await Promise.all(\n        Object.entries(schema.entries).map(async ([key, schema2]) => {\n          fallbacks[key] = await getFallbacksAsync(schema2);\n        })\n      );\n    } else if (schema.type === \"tuple\") {\n      fallbacks = await Promise.all(\n        schema.items.map((schema2) => getFallbacksAsync(schema2))\n      );\n    }\n  }\n  return fallbacks;\n}\n\n// src/methods/is/is.ts\nfunction is(schema, input) {\n  return !schema._parse(input, { abortEarly: true }).issues;\n}\n\n// src/schemas/any/any.ts\nfunction any(pipe) {\n  return {\n    type: \"any\",\n    async: false,\n    pipe,\n    _parse(input, info) {\n      return executePipe(input, this.pipe, info, \"any\");\n    }\n  };\n}\n\n// src/schemas/any/anyAsync.ts\nfunction anyAsync(pipe) {\n  return {\n    type: \"any\",\n    async: true,\n    pipe,\n    async _parse(input, info) {\n      return executePipeAsync(input, this.pipe, info, \"any\");\n    }\n  };\n}\n\n// src/schemas/array/array.ts\nfunction array(item, arg2, arg3) {\n  const [message = \"Invalid type\", pipe] = getDefaultArgs(arg2, arg3);\n  return {\n    type: \"array\",\n    async: false,\n    item,\n    message,\n    pipe,\n    _parse(input, info) {\n      if (!Array.isArray(input)) {\n        return getSchemaIssues(info, \"type\", \"array\", this.message, input);\n      }\n      let issues;\n      const output = [];\n      for (let key = 0; key < input.length; key++) {\n        const value2 = input[key];\n        const result = this.item._parse(value2, info);\n        if (result.issues) {\n          const pathItem = {\n            type: \"array\",\n            input,\n            key,\n            value: value2\n          };\n          for (const issue of result.issues) {\n            if (issue.path) {\n              issue.path.unshift(pathItem);\n            } else {\n              issue.path = [pathItem];\n            }\n            issues?.push(issue);\n          }\n          if (!issues) {\n            issues = result.issues;\n          }\n          if (info?.abortEarly) {\n            break;\n          }\n        } else {\n          output.push(result.output);\n        }\n      }\n      return issues ? getIssues(issues) : executePipe(output, this.pipe, info, \"array\");\n    }\n  };\n}\n\n// src/schemas/array/arrayAsync.ts\nfunction arrayAsync(item, arg2, arg3) {\n  const [message = \"Invalid type\", pipe] = getDefaultArgs(arg2, arg3);\n  return {\n    type: \"array\",\n    async: true,\n    item,\n    message,\n    pipe,\n    async _parse(input, info) {\n      if (!Array.isArray(input)) {\n        return getSchemaIssues(info, \"type\", \"array\", this.message, input);\n      }\n      let issues;\n      const output = [];\n      await Promise.all(\n        input.map(async (value2, key) => {\n          if (!(info?.abortEarly && issues)) {\n            const result = await this.item._parse(value2, info);\n            if (!(info?.abortEarly && issues)) {\n              if (result.issues) {\n                const pathItem = {\n                  type: \"array\",\n                  input,\n                  key,\n                  value: value2\n                };\n                for (const issue of result.issues) {\n                  if (issue.path) {\n                    issue.path.unshift(pathItem);\n                  } else {\n                    issue.path = [pathItem];\n                  }\n                  issues?.push(issue);\n                }\n                if (!issues) {\n                  issues = result.issues;\n                }\n                if (info?.abortEarly) {\n                  throw null;\n                }\n              } else {\n                output[key] = result.output;\n              }\n            }\n          }\n        })\n      ).catch(() => null);\n      return issues ? getIssues(issues) : executePipeAsync(output, this.pipe, info, \"array\");\n    }\n  };\n}\n\n// src/schemas/bigint/bigint.ts\nfunction bigint(arg1, arg2) {\n  const [message = \"Invalid type\", pipe] = getDefaultArgs(arg1, arg2);\n  return {\n    type: \"bigint\",\n    async: false,\n    message,\n    pipe,\n    _parse(input, info) {\n      if (typeof input !== \"bigint\") {\n        return getSchemaIssues(info, \"type\", \"bigint\", this.message, input);\n      }\n      return executePipe(input, this.pipe, info, \"bigint\");\n    }\n  };\n}\n\n// src/schemas/bigint/bigintAsync.ts\nfunction bigintAsync(arg1, arg2) {\n  const [message = \"Invalid type\", pipe] = getDefaultArgs(arg1, arg2);\n  return {\n    type: \"bigint\",\n    async: true,\n    message,\n    pipe,\n    async _parse(input, info) {\n      if (typeof input !== \"bigint\") {\n        return getSchemaIssues(info, \"type\", \"bigint\", this.message, input);\n      }\n      return executePipeAsync(input, this.pipe, info, \"bigint\");\n    }\n  };\n}\n\n// src/schemas/blob/blob.ts\nfunction blob(arg1, arg2) {\n  const [message = \"Invalid type\", pipe] = getDefaultArgs(arg1, arg2);\n  return {\n    type: \"blob\",\n    async: false,\n    message,\n    pipe,\n    _parse(input, info) {\n      if (!(input instanceof Blob)) {\n        return getSchemaIssues(info, \"type\", \"blob\", this.message, input);\n      }\n      return executePipe(input, this.pipe, info, \"blob\");\n    }\n  };\n}\n\n// src/schemas/blob/blobAsync.ts\nfunction blobAsync(arg1, arg2) {\n  const [message = \"Invalid type\", pipe] = getDefaultArgs(arg1, arg2);\n  return {\n    type: \"blob\",\n    async: true,\n    message,\n    pipe,\n    async _parse(input, info) {\n      if (!(input instanceof Blob)) {\n        return getSchemaIssues(info, \"type\", \"blob\", this.message, input);\n      }\n      return executePipeAsync(input, this.pipe, info, \"blob\");\n    }\n  };\n}\n\n// src/schemas/boolean/boolean.ts\nfunction boolean(arg1, arg2) {\n  const [message = \"Invalid type\", pipe] = getDefaultArgs(arg1, arg2);\n  return {\n    type: \"boolean\",\n    async: false,\n    message,\n    pipe,\n    _parse(input, info) {\n      if (typeof input !== \"boolean\") {\n        return getSchemaIssues(info, \"type\", \"boolean\", this.message, input);\n      }\n      return executePipe(input, this.pipe, info, \"boolean\");\n    }\n  };\n}\n\n// src/schemas/boolean/booleanAsync.ts\nfunction booleanAsync(arg1, arg2) {\n  const [message = \"Invalid type\", pipe] = getDefaultArgs(arg1, arg2);\n  return {\n    type: \"boolean\",\n    async: true,\n    message,\n    pipe,\n    async _parse(input, info) {\n      if (typeof input !== \"boolean\") {\n        return getSchemaIssues(info, \"type\", \"boolean\", this.message, input);\n      }\n      return executePipeAsync(input, this.pipe, info, \"boolean\");\n    }\n  };\n}\n\n// src/schemas/date/date.ts\nfunction date(arg1, arg2) {\n  const [message = \"Invalid type\", pipe] = getDefaultArgs(arg1, arg2);\n  return {\n    type: \"date\",\n    async: false,\n    message,\n    pipe,\n    _parse(input, info) {\n      if (!(input instanceof Date) || isNaN(input.getTime())) {\n        return getSchemaIssues(info, \"type\", \"date\", this.message, input);\n      }\n      return executePipe(input, this.pipe, info, \"date\");\n    }\n  };\n}\n\n// src/schemas/date/dateAsync.ts\nfunction dateAsync(arg1, arg2) {\n  const [message = \"Invalid type\", pipe] = getDefaultArgs(arg1, arg2);\n  return {\n    type: \"date\",\n    async: true,\n    message,\n    pipe,\n    async _parse(input, info) {\n      if (!(input instanceof Date) || isNaN(input.getTime())) {\n        return getSchemaIssues(info, \"type\", \"date\", this.message, input);\n      }\n      return executePipeAsync(input, this.pipe, info, \"date\");\n    }\n  };\n}\n\n// src/schemas/enum/enum.ts\nfunction enum_(enum_2, message = \"Invalid type\") {\n  return {\n    type: \"enum\",\n    async: false,\n    enum: enum_2,\n    message,\n    _parse(input, info) {\n      if (!Object.values(this.enum).includes(input)) {\n        return getSchemaIssues(info, \"type\", \"enum\", this.message, input);\n      }\n      return getOutput(input);\n    }\n  };\n}\nvar nativeEnum = enum_;\n\n// src/schemas/enum/enumAsync.ts\nfunction enumAsync(enum_2, message = \"Invalid type\") {\n  return {\n    type: \"enum\",\n    async: true,\n    enum: enum_2,\n    message,\n    async _parse(input, info) {\n      if (!Object.values(this.enum).includes(input)) {\n        return getSchemaIssues(info, \"type\", \"enum\", this.message, input);\n      }\n      return getOutput(input);\n    }\n  };\n}\nvar nativeEnumAsync = enumAsync;\n\n// src/schemas/instance/instance.ts\nfunction instance(class_, arg2, arg3) {\n  const [message = \"Invalid type\", pipe] = getDefaultArgs(arg2, arg3);\n  return {\n    type: \"instance\",\n    async: false,\n    class: class_,\n    message,\n    pipe,\n    _parse(input, info) {\n      if (!(input instanceof this.class)) {\n        return getSchemaIssues(info, \"type\", \"instance\", this.message, input);\n      }\n      return executePipe(input, this.pipe, info, \"instance\");\n    }\n  };\n}\n\n// src/schemas/instance/instanceAsync.ts\nfunction instanceAsync(class_, arg2, arg3) {\n  const [message = \"Invalid type\", pipe] = getDefaultArgs(arg2, arg3);\n  return {\n    type: \"instance\",\n    async: true,\n    class: class_,\n    message,\n    pipe,\n    async _parse(input, info) {\n      if (!(input instanceof this.class)) {\n        return getSchemaIssues(info, \"type\", \"instance\", this.message, input);\n      }\n      return executePipeAsync(input, this.pipe, info, \"instance\");\n    }\n  };\n}\n\n// src/schemas/intersect/utils/mergeOutputs/mergeOutputs.ts\nfunction mergeOutputs(output1, output2) {\n  if (typeof output1 === typeof output2) {\n    if (output1 === output2 || output1 instanceof Date && output2 instanceof Date && +output1 === +output2) {\n      return getOutput(output1);\n    }\n    if (Array.isArray(output1) && Array.isArray(output2)) {\n      if (output1.length === output2.length) {\n        const array2 = [];\n        for (let index = 0; index < output1.length; index++) {\n          const result = mergeOutputs(output1[index], output2[index]);\n          if (result.invalid) {\n            return result;\n          }\n          array2.push(result.output);\n        }\n        return getOutput(array2);\n      }\n      return { invalid: true };\n    }\n    if (output1 && output2 && output1.constructor === Object && output2.constructor === Object) {\n      const object2 = { ...output1, ...output2 };\n      for (const key in output1) {\n        if (key in output2) {\n          const result = mergeOutputs(output1[key], output2[key]);\n          if (result.invalid) {\n            return result;\n          }\n          object2[key] = result.output;\n        }\n      }\n      return getOutput(object2);\n    }\n  }\n  return { invalid: true };\n}\n\n// src/schemas/intersect/intersect.ts\nfunction intersect(options, message = \"Invalid type\") {\n  return {\n    type: \"intersect\",\n    async: false,\n    options,\n    message,\n    _parse(input, info) {\n      let issues;\n      let outputs;\n      for (const schema of this.options) {\n        const result = schema._parse(input, info);\n        if (result.issues) {\n          if (issues) {\n            for (const issue of result.issues) {\n              issues.push(issue);\n            }\n          } else {\n            issues = result.issues;\n          }\n          if (info?.abortEarly) {\n            break;\n          }\n        } else {\n          if (outputs) {\n            outputs.push(result.output);\n          } else {\n            outputs = [result.output];\n          }\n        }\n      }\n      if (issues) {\n        return getIssues(issues);\n      }\n      let output = outputs[0];\n      for (let index = 1; index < outputs.length; index++) {\n        const result = mergeOutputs(output, outputs[index]);\n        if (result.invalid) {\n          return getSchemaIssues(\n            info,\n            \"type\",\n            \"intersect\",\n            this.message,\n            input\n          );\n        }\n        output = result.output;\n      }\n      return getOutput(output);\n    }\n  };\n}\nvar intersection = intersect;\n\n// src/schemas/literal/literal.ts\nfunction literal(literal2, message = \"Invalid type\") {\n  return {\n    type: \"literal\",\n    async: false,\n    literal: literal2,\n    message,\n    _parse(input, info) {\n      if (input !== this.literal) {\n        return getSchemaIssues(info, \"type\", \"literal\", this.message, input);\n      }\n      return getOutput(input);\n    }\n  };\n}\n\n// src/schemas/literal/literalAsync.ts\nfunction literalAsync(literal2, message = \"Invalid type\") {\n  return {\n    type: \"literal\",\n    async: true,\n    literal: literal2,\n    message,\n    async _parse(input, info) {\n      if (input !== this.literal) {\n        return getSchemaIssues(info, \"type\", \"literal\", this.message, input);\n      }\n      return getOutput(input);\n    }\n  };\n}\n\n// src/schemas/map/map.ts\nfunction map(key, value2, arg3, arg4) {\n  const [message = \"Invalid type\", pipe] = getDefaultArgs(arg3, arg4);\n  return {\n    type: \"map\",\n    async: false,\n    key,\n    value: value2,\n    message,\n    pipe,\n    _parse(input, info) {\n      if (!(input instanceof Map)) {\n        return getSchemaIssues(info, \"type\", \"map\", this.message, input);\n      }\n      let issues;\n      const output = /* @__PURE__ */ new Map();\n      for (const [inputKey, inputValue] of input.entries()) {\n        let pathItem;\n        const keyResult = this.key._parse(inputKey, {\n          origin: \"key\",\n          abortEarly: info?.abortEarly,\n          abortPipeEarly: info?.abortPipeEarly,\n          skipPipe: info?.skipPipe\n        });\n        if (keyResult.issues) {\n          pathItem = {\n            type: \"map\",\n            input,\n            key: inputKey,\n            value: inputValue\n          };\n          for (const issue of keyResult.issues) {\n            if (issue.path) {\n              issue.path.unshift(pathItem);\n            } else {\n              issue.path = [pathItem];\n            }\n            issues?.push(issue);\n          }\n          if (!issues) {\n            issues = keyResult.issues;\n          }\n          if (info?.abortEarly) {\n            break;\n          }\n        }\n        const valueResult = this.value._parse(inputValue, info);\n        if (valueResult.issues) {\n          pathItem = pathItem || {\n            type: \"map\",\n            input,\n            key: inputKey,\n            value: inputValue\n          };\n          for (const issue of valueResult.issues) {\n            if (issue.path) {\n              issue.path.unshift(pathItem);\n            } else {\n              issue.path = [pathItem];\n            }\n            issues?.push(issue);\n          }\n          if (!issues) {\n            issues = valueResult.issues;\n          }\n          if (info?.abortEarly) {\n            break;\n          }\n        }\n        if (!keyResult.issues && !valueResult.issues) {\n          output.set(keyResult.output, valueResult.output);\n        }\n      }\n      return issues ? getIssues(issues) : executePipe(output, this.pipe, info, \"map\");\n    }\n  };\n}\n\n// src/schemas/map/mapAsync.ts\nfunction mapAsync(key, value2, arg3, arg4) {\n  const [message = \"Invalid type\", pipe] = getDefaultArgs(arg3, arg4);\n  return {\n    type: \"map\",\n    async: true,\n    key,\n    value: value2,\n    message,\n    pipe,\n    async _parse(input, info) {\n      if (!(input instanceof Map)) {\n        return getSchemaIssues(info, \"type\", \"map\", this.message, input);\n      }\n      const output = /* @__PURE__ */ new Map();\n      let issues;\n      await Promise.all(\n        Array.from(input.entries()).map(async ([inputKey, inputValue]) => {\n          let pathItem;\n          const [keyResult, valueResult] = await Promise.all(\n            [\n              { schema: this.key, value: inputKey, origin: \"key\" },\n              { schema: this.value, value: inputValue, origin: \"value\" }\n            ].map(async ({ schema, value: value3, origin }) => {\n              if (!(info?.abortEarly && issues)) {\n                const result = await schema._parse(value3, {\n                  origin,\n                  abortEarly: info?.abortEarly,\n                  abortPipeEarly: info?.abortPipeEarly,\n                  skipPipe: info?.skipPipe\n                });\n                if (!(info?.abortEarly && issues)) {\n                  if (result.issues) {\n                    pathItem = pathItem || {\n                      type: \"map\",\n                      input,\n                      key: inputKey,\n                      value: inputValue\n                    };\n                    for (const issue of result.issues) {\n                      if (issue.path) {\n                        issue.path.unshift(pathItem);\n                      } else {\n                        issue.path = [pathItem];\n                      }\n                      issues?.push(issue);\n                    }\n                    if (!issues) {\n                      issues = result.issues;\n                    }\n                    if (info?.abortEarly) {\n                      throw null;\n                    }\n                  } else {\n                    return result;\n                  }\n                }\n              }\n            })\n          ).catch(() => []);\n          if (keyResult && valueResult) {\n            output.set(keyResult.output, valueResult.output);\n          }\n        })\n      );\n      return issues ? getIssues(issues) : executePipeAsync(input, this.pipe, info, \"map\");\n    }\n  };\n}\n\n// src/schemas/nan/nan.ts\nfunction nan(message = \"Invalid type\") {\n  return {\n    type: \"nan\",\n    async: false,\n    message,\n    _parse(input, info) {\n      if (!Number.isNaN(input)) {\n        return getSchemaIssues(info, \"type\", \"nan\", this.message, input);\n      }\n      return getOutput(input);\n    }\n  };\n}\n\n// src/schemas/nan/nanAsync.ts\nfunction nanAsync(message = \"Invalid type\") {\n  return {\n    type: \"nan\",\n    async: true,\n    message,\n    async _parse(input, info) {\n      if (!Number.isNaN(input)) {\n        return getSchemaIssues(info, \"type\", \"nan\", this.message, input);\n      }\n      return getOutput(input);\n    }\n  };\n}\n\n// src/schemas/never/never.ts\nfunction never(message = \"Invalid type\") {\n  return {\n    type: \"never\",\n    async: false,\n    message,\n    _parse(input, info) {\n      return getSchemaIssues(info, \"type\", \"never\", this.message, input);\n    }\n  };\n}\n\n// src/schemas/never/neverAsync.ts\nfunction neverAsync(message = \"Invalid type\") {\n  return {\n    type: \"never\",\n    async: true,\n    message,\n    async _parse(input, info) {\n      return getSchemaIssues(info, \"type\", \"never\", this.message, input);\n    }\n  };\n}\n\n// src/schemas/nonNullable/nonNullable.ts\nfunction nonNullable(wrapped, message = \"Invalid type\") {\n  return {\n    type: \"non_nullable\",\n    async: false,\n    wrapped,\n    message,\n    _parse(input, info) {\n      if (input === null) {\n        return getSchemaIssues(\n          info,\n          \"type\",\n          \"non_nullable\",\n          this.message,\n          input\n        );\n      }\n      return this.wrapped._parse(input, info);\n    }\n  };\n}\n\n// src/schemas/nonNullable/nonNullableAsync.ts\nfunction nonNullableAsync(wrapped, message = \"Invalid type\") {\n  return {\n    type: \"non_nullable\",\n    async: true,\n    wrapped,\n    message,\n    async _parse(input, info) {\n      if (input === null) {\n        return getSchemaIssues(\n          info,\n          \"type\",\n          \"non_nullable\",\n          this.message,\n          input\n        );\n      }\n      return this.wrapped._parse(input, info);\n    }\n  };\n}\n\n// src/schemas/nonNullish/nonNullish.ts\nfunction nonNullish(wrapped, message = \"Invalid type\") {\n  return {\n    type: \"non_nullish\",\n    async: false,\n    wrapped,\n    message,\n    _parse(input, info) {\n      if (input === null || input === void 0) {\n        return getSchemaIssues(\n          info,\n          \"type\",\n          \"non_nullish\",\n          this.message,\n          input\n        );\n      }\n      return this.wrapped._parse(input, info);\n    }\n  };\n}\n\n// src/schemas/nonNullish/nonNullishAsync.ts\nfunction nonNullishAsync(wrapped, message = \"Invalid type\") {\n  return {\n    type: \"non_nullish\",\n    async: true,\n    wrapped,\n    message,\n    async _parse(input, info) {\n      if (input === null || input === void 0) {\n        return getSchemaIssues(\n          info,\n          \"type\",\n          \"non_nullish\",\n          this.message,\n          input\n        );\n      }\n      return this.wrapped._parse(input, info);\n    }\n  };\n}\n\n// src/schemas/nonOptional/nonOptional.ts\nfunction nonOptional(wrapped, message = \"Invalid type\") {\n  return {\n    type: \"non_optional\",\n    async: false,\n    wrapped,\n    message,\n    _parse(input, info) {\n      if (input === void 0) {\n        return getSchemaIssues(\n          info,\n          \"type\",\n          \"non_optional\",\n          this.message,\n          input\n        );\n      }\n      return this.wrapped._parse(input, info);\n    }\n  };\n}\n\n// src/schemas/nonOptional/nonOptionalAsync.ts\nfunction nonOptionalAsync(wrapped, message = \"Invalid type\") {\n  return {\n    type: \"non_optional\",\n    async: true,\n    wrapped,\n    message,\n    async _parse(input, info) {\n      if (input === void 0) {\n        return getSchemaIssues(\n          info,\n          \"type\",\n          \"non_optional\",\n          this.message,\n          input\n        );\n      }\n      return this.wrapped._parse(input, info);\n    }\n  };\n}\n\n// src/schemas/nullable/nullable.ts\nfunction nullable(wrapped, default_) {\n  return {\n    type: \"nullable\",\n    async: false,\n    wrapped,\n    default: default_,\n    _parse(input, info) {\n      if (input === null) {\n        const override = getDefault(this);\n        if (override === void 0) {\n          return getOutput(input);\n        }\n        input = override;\n      }\n      return this.wrapped._parse(input, info);\n    }\n  };\n}\n\n// src/schemas/nullable/nullableAsync.ts\nfunction nullableAsync(wrapped, default_) {\n  return {\n    type: \"nullable\",\n    async: true,\n    wrapped,\n    default: default_,\n    async _parse(input, info) {\n      if (input === null) {\n        const override = await getDefaultAsync(this);\n        if (override === void 0) {\n          return getOutput(input);\n        }\n        input = override;\n      }\n      return this.wrapped._parse(input, info);\n    }\n  };\n}\n\n// src/schemas/nullish/nullish.ts\nfunction nullish(wrapped, default_) {\n  return {\n    type: \"nullish\",\n    async: false,\n    wrapped,\n    default: default_,\n    _parse(input, info) {\n      if (input === null || input === void 0) {\n        const override = getDefault(this);\n        if (override === void 0) {\n          return getOutput(input);\n        }\n        input = override;\n      }\n      return this.wrapped._parse(input, info);\n    }\n  };\n}\n\n// src/schemas/nullish/nullishAsync.ts\nfunction nullishAsync(wrapped, default_) {\n  return {\n    type: \"nullish\",\n    async: true,\n    wrapped,\n    default: default_,\n    async _parse(input, info) {\n      if (input === null || input === void 0) {\n        const override = await getDefaultAsync(this);\n        if (override === void 0) {\n          return getOutput(input);\n        }\n        input = override;\n      }\n      return this.wrapped._parse(input, info);\n    }\n  };\n}\n\n// src/schemas/null/null.ts\nfunction null_(message = \"Invalid type\") {\n  return {\n    type: \"null\",\n    async: false,\n    message,\n    _parse(input, info) {\n      if (input !== null) {\n        return getSchemaIssues(info, \"type\", \"null\", this.message, input);\n      }\n      return getOutput(input);\n    }\n  };\n}\nvar nullType = null_;\n\n// src/schemas/null/nullAsync.ts\nfunction nullAsync(message = \"Invalid type\") {\n  return {\n    type: \"null\",\n    async: true,\n    message,\n    async _parse(input, info) {\n      if (input !== null) {\n        return getSchemaIssues(info, \"type\", \"null\", this.message, input);\n      }\n      return getOutput(input);\n    }\n  };\n}\nvar nullTypeAsync = nullAsync;\n\n// src/schemas/number/number.ts\nfunction number(arg1, arg2) {\n  const [message = \"Invalid type\", pipe] = getDefaultArgs(arg1, arg2);\n  return {\n    type: \"number\",\n    async: false,\n    message,\n    pipe,\n    _parse(input, info) {\n      if (typeof input !== \"number\" || isNaN(input)) {\n        return getSchemaIssues(info, \"type\", \"number\", this.message, input);\n      }\n      return executePipe(input, this.pipe, info, \"number\");\n    }\n  };\n}\n\n// src/schemas/number/numberAsync.ts\nfunction numberAsync(arg1, arg2) {\n  const [message = \"Invalid type\", pipe] = getDefaultArgs(arg1, arg2);\n  return {\n    type: \"number\",\n    async: true,\n    message,\n    pipe,\n    async _parse(input, info) {\n      if (typeof input !== \"number\" || isNaN(input)) {\n        return getSchemaIssues(info, \"type\", \"number\", this.message, input);\n      }\n      return executePipeAsync(input, this.pipe, info, \"number\");\n    }\n  };\n}\n\n// src/schemas/object/object.ts\nfunction object(entries, arg2, arg3, arg4) {\n  const [rest, message = \"Invalid type\", pipe] = getRestAndDefaultArgs(arg2, arg3, arg4);\n  let cachedEntries;\n  return {\n    type: \"object\",\n    async: false,\n    entries,\n    rest,\n    message,\n    pipe,\n    _parse(input, info) {\n      if (!input || typeof input !== \"object\") {\n        return getSchemaIssues(info, \"type\", \"object\", this.message, input);\n      }\n      cachedEntries = cachedEntries || Object.entries(this.entries);\n      let issues;\n      const output = {};\n      for (const [key, schema] of cachedEntries) {\n        const value2 = input[key];\n        const result = schema._parse(value2, info);\n        if (result.issues) {\n          const pathItem = {\n            type: \"object\",\n            input,\n            key,\n            value: value2\n          };\n          for (const issue of result.issues) {\n            if (issue.path) {\n              issue.path.unshift(pathItem);\n            } else {\n              issue.path = [pathItem];\n            }\n            issues?.push(issue);\n          }\n          if (!issues) {\n            issues = result.issues;\n          }\n          if (info?.abortEarly) {\n            break;\n          }\n        } else if (result.output !== void 0 || key in input) {\n          output[key] = result.output;\n        }\n      }\n      if (this.rest && !(info?.abortEarly && issues)) {\n        for (const key in input) {\n          if (!(key in this.entries)) {\n            const value2 = input[key];\n            const result = this.rest._parse(value2, info);\n            if (result.issues) {\n              const pathItem = {\n                type: \"object\",\n                input,\n                key,\n                value: value2\n              };\n              for (const issue of result.issues) {\n                if (issue.path) {\n                  issue.path.unshift(pathItem);\n                } else {\n                  issue.path = [pathItem];\n                }\n                issues?.push(issue);\n              }\n              if (!issues) {\n                issues = result.issues;\n              }\n              if (info?.abortEarly) {\n                break;\n              }\n            } else {\n              output[key] = result.output;\n            }\n          }\n        }\n      }\n      return issues ? getIssues(issues) : executePipe(\n        output,\n        this.pipe,\n        info,\n        \"object\"\n      );\n    }\n  };\n}\n\n// src/schemas/object/objectAsync.ts\nfunction objectAsync(entries, arg2, arg3, arg4) {\n  const [rest, message = \"Invalid type\", pipe] = getRestAndDefaultArgs(arg2, arg3, arg4);\n  let cachedEntries;\n  return {\n    type: \"object\",\n    async: true,\n    entries,\n    rest,\n    message,\n    pipe,\n    async _parse(input, info) {\n      if (!input || typeof input !== \"object\") {\n        return getSchemaIssues(info, \"type\", \"object\", this.message, input);\n      }\n      cachedEntries = cachedEntries || Object.entries(this.entries);\n      let issues;\n      const output = {};\n      await Promise.all([\n        Promise.all(\n          cachedEntries.map(async ([key, schema]) => {\n            if (!(info?.abortEarly && issues)) {\n              const value2 = input[key];\n              const result = await schema._parse(value2, info);\n              if (!(info?.abortEarly && issues)) {\n                if (result.issues) {\n                  const pathItem = {\n                    type: \"object\",\n                    input,\n                    key,\n                    value: value2\n                  };\n                  for (const issue of result.issues) {\n                    if (issue.path) {\n                      issue.path.unshift(pathItem);\n                    } else {\n                      issue.path = [pathItem];\n                    }\n                    issues?.push(issue);\n                  }\n                  if (!issues) {\n                    issues = result.issues;\n                  }\n                  if (info?.abortEarly) {\n                    throw null;\n                  }\n                } else if (result.output !== void 0 || key in input) {\n                  output[key] = result.output;\n                }\n              }\n            }\n          })\n        ),\n        this.rest && Promise.all(\n          Object.entries(input).map(async ([key, value2]) => {\n            if (!(info?.abortEarly && issues)) {\n              if (!(key in this.entries)) {\n                const result = await this.rest._parse(value2, info);\n                if (!(info?.abortEarly && issues)) {\n                  if (result.issues) {\n                    const pathItem = {\n                      type: \"object\",\n                      input,\n                      key,\n                      value: value2\n                    };\n                    for (const issue of result.issues) {\n                      if (issue.path) {\n                        issue.path.unshift(pathItem);\n                      } else {\n                        issue.path = [pathItem];\n                      }\n                      issues?.push(issue);\n                    }\n                    if (!issues) {\n                      issues = result.issues;\n                    }\n                    if (info?.abortEarly) {\n                      throw null;\n                    }\n                  } else {\n                    output[key] = result.output;\n                  }\n                }\n              }\n            }\n          })\n        )\n      ]).catch(() => null);\n      return issues ? getIssues(issues) : executePipeAsync(\n        output,\n        this.pipe,\n        info,\n        \"object\"\n      );\n    }\n  };\n}\n\n// src/schemas/optional/optional.ts\nfunction optional(wrapped, default_) {\n  return {\n    type: \"optional\",\n    async: false,\n    wrapped,\n    default: default_,\n    _parse(input, info) {\n      if (input === void 0) {\n        const override = getDefault(this);\n        if (override === void 0) {\n          return getOutput(input);\n        }\n        input = override;\n      }\n      return this.wrapped._parse(input, info);\n    }\n  };\n}\n\n// src/schemas/optional/optionalAsync.ts\nfunction optionalAsync(wrapped, default_) {\n  return {\n    type: \"optional\",\n    async: true,\n    wrapped,\n    default: default_,\n    async _parse(input, info) {\n      if (input === void 0) {\n        const override = await getDefaultAsync(this);\n        if (override === void 0) {\n          return getOutput(input);\n        }\n        input = override;\n      }\n      return this.wrapped._parse(input, info);\n    }\n  };\n}\n\n// src/schemas/picklist/picklist.ts\nfunction picklist(options, message = \"Invalid type\") {\n  return {\n    type: \"picklist\",\n    async: false,\n    options,\n    message,\n    _parse(input, info) {\n      if (!this.options.includes(input)) {\n        return getSchemaIssues(info, \"type\", \"picklist\", this.message, input);\n      }\n      return getOutput(input);\n    }\n  };\n}\nvar enumType = picklist;\n\n// src/schemas/picklist/picklistAsync.ts\nfunction picklistAsync(options, message = \"Invalid type\") {\n  return {\n    type: \"picklist\",\n    async: true,\n    options,\n    message,\n    async _parse(input, info) {\n      if (!this.options.includes(input)) {\n        return getSchemaIssues(info, \"type\", \"picklist\", this.message, input);\n      }\n      return getOutput(input);\n    }\n  };\n}\nvar enumTypeAsync = picklistAsync;\n\n// src/schemas/string/string.ts\nfunction string(arg1, arg2) {\n  const [message = \"Invalid type\", pipe] = getDefaultArgs(arg1, arg2);\n  return {\n    type: \"string\",\n    async: false,\n    message,\n    pipe,\n    _parse(input, info) {\n      if (typeof input !== \"string\") {\n        return getSchemaIssues(info, \"type\", \"string\", this.message, input);\n      }\n      return executePipe(input, this.pipe, info, \"string\");\n    }\n  };\n}\n\n// src/schemas/string/stringAsync.ts\nfunction stringAsync(arg1, arg2) {\n  const [message = \"Invalid type\", pipe] = getDefaultArgs(arg1, arg2);\n  return {\n    type: \"string\",\n    async: true,\n    message,\n    pipe,\n    async _parse(input, info) {\n      if (typeof input !== \"string\") {\n        return getSchemaIssues(info, \"type\", \"string\", this.message, input);\n      }\n      return executePipeAsync(input, this.pipe, info, \"string\");\n    }\n  };\n}\n\n// src/schemas/record/utils/getRecordArgs/getRecordArgs.ts\nfunction getRecordArgs(arg1, arg2, arg3, arg4) {\n  if (typeof arg2 === \"object\" && !Array.isArray(arg2)) {\n    const [message2, pipe2] = getDefaultArgs(arg3, arg4);\n    return [arg1, arg2, message2, pipe2];\n  }\n  const [message, pipe] = getDefaultArgs(\n    arg2,\n    arg3\n  );\n  return [string(), arg1, message, pipe];\n}\n\n// src/schemas/record/values.ts\nvar BLOCKED_KEYS = [\"__proto__\", \"prototype\", \"constructor\"];\n\n// src/schemas/record/record.ts\nfunction record(arg1, arg2, arg3, arg4) {\n  const [key, value2, message = \"Invalid type\", pipe] = getRecordArgs(arg1, arg2, arg3, arg4);\n  return {\n    type: \"record\",\n    async: false,\n    key,\n    value: value2,\n    message,\n    pipe,\n    _parse(input, info) {\n      if (!input || typeof input !== \"object\") {\n        return getSchemaIssues(info, \"type\", \"record\", this.message, input);\n      }\n      let issues;\n      const output = {};\n      for (const [inputKey, inputValue] of Object.entries(input)) {\n        if (!BLOCKED_KEYS.includes(inputKey)) {\n          let pathItem;\n          const keyResult = this.key._parse(inputKey, {\n            origin: \"key\",\n            abortEarly: info?.abortEarly,\n            abortPipeEarly: info?.abortPipeEarly,\n            skipPipe: info?.skipPipe\n          });\n          if (keyResult.issues) {\n            pathItem = {\n              type: \"record\",\n              input,\n              key: inputKey,\n              value: inputValue\n            };\n            for (const issue of keyResult.issues) {\n              issue.path = [pathItem];\n              issues?.push(issue);\n            }\n            if (!issues) {\n              issues = keyResult.issues;\n            }\n            if (info?.abortEarly) {\n              break;\n            }\n          }\n          const valueResult = this.value._parse(inputValue, info);\n          if (valueResult.issues) {\n            pathItem = pathItem || {\n              type: \"record\",\n              input,\n              key: inputKey,\n              value: inputValue\n            };\n            for (const issue of valueResult.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              issues?.push(issue);\n            }\n            if (!issues) {\n              issues = valueResult.issues;\n            }\n            if (info?.abortEarly) {\n              break;\n            }\n          }\n          if (!keyResult.issues && !valueResult.issues) {\n            output[keyResult.output] = valueResult.output;\n          }\n        }\n      }\n      return issues ? getIssues(issues) : executePipe(\n        output,\n        this.pipe,\n        info,\n        \"record\"\n      );\n    }\n  };\n}\n\n// src/schemas/record/recordAsync.ts\nfunction recordAsync(arg1, arg2, arg3, arg4) {\n  const [key, value2, message = \"Invalid type\", pipe] = getRecordArgs(arg1, arg2, arg3, arg4);\n  return {\n    type: \"record\",\n    async: true,\n    key,\n    value: value2,\n    message,\n    pipe,\n    async _parse(input, info) {\n      if (!input || typeof input !== \"object\") {\n        return getSchemaIssues(info, \"type\", \"record\", this.message, input);\n      }\n      let issues;\n      const output = {};\n      await Promise.all(\n        // Note: `Object.entries(...)` converts each key to a string\n        Object.entries(input).map(async ([inputKey, inputValue]) => {\n          if (!BLOCKED_KEYS.includes(inputKey)) {\n            let pathItem;\n            const [keyResult, valueResult] = await Promise.all(\n              [\n                { schema: this.key, value: inputKey, origin: \"key\" },\n                { schema: this.value, value: inputValue, origin: \"value\" }\n              ].map(async ({ schema, value: value3, origin }) => {\n                if (!(info?.abortEarly && issues)) {\n                  const result = await schema._parse(value3, {\n                    origin,\n                    abortEarly: info?.abortEarly,\n                    abortPipeEarly: info?.abortPipeEarly,\n                    skipPipe: info?.skipPipe\n                  });\n                  if (!(info?.abortEarly && issues)) {\n                    if (result.issues) {\n                      pathItem = pathItem || {\n                        type: \"record\",\n                        input,\n                        key: inputKey,\n                        value: inputValue\n                      };\n                      for (const issue of result.issues) {\n                        if (issue.path) {\n                          issue.path.unshift(pathItem);\n                        } else {\n                          issue.path = [pathItem];\n                        }\n                        issues?.push(issue);\n                      }\n                      if (!issues) {\n                        issues = result.issues;\n                      }\n                      if (info?.abortEarly) {\n                        throw null;\n                      }\n                    } else {\n                      return result;\n                    }\n                  }\n                }\n              })\n            ).catch(() => []);\n            if (keyResult && valueResult) {\n              output[keyResult.output] = valueResult.output;\n            }\n          }\n        })\n      );\n      return issues ? getIssues(issues) : executePipeAsync(\n        output,\n        this.pipe,\n        info,\n        \"record\"\n      );\n    }\n  };\n}\n\n// src/schemas/recursive/recursive.ts\nfunction recursive(getter) {\n  return {\n    type: \"recursive\",\n    async: false,\n    getter,\n    _parse(input, info) {\n      return this.getter()._parse(input, info);\n    }\n  };\n}\n\n// src/schemas/recursive/recursiveAsync.ts\nfunction recursiveAsync(getter) {\n  return {\n    type: \"recursive\",\n    async: true,\n    getter,\n    async _parse(input, info) {\n      return this.getter()._parse(input, info);\n    }\n  };\n}\n\n// src/schemas/set/set.ts\nfunction set(value2, arg2, arg3) {\n  const [message = \"Invalid type\", pipe] = getDefaultArgs(arg2, arg3);\n  return {\n    type: \"set\",\n    async: false,\n    value: value2,\n    message,\n    pipe,\n    _parse(input, info) {\n      if (!(input instanceof Set)) {\n        return getSchemaIssues(info, \"type\", \"set\", this.message, input);\n      }\n      let key = 0;\n      let issues;\n      const output = /* @__PURE__ */ new Set();\n      for (const inputValue of input) {\n        const result = this.value._parse(inputValue, info);\n        if (result.issues) {\n          const pathItem = {\n            type: \"set\",\n            input,\n            key,\n            value: inputValue\n          };\n          for (const issue of result.issues) {\n            if (issue.path) {\n              issue.path.unshift(pathItem);\n            } else {\n              issue.path = [pathItem];\n            }\n            issues?.push(issue);\n          }\n          if (!issues) {\n            issues = result.issues;\n          }\n          if (info?.abortEarly) {\n            break;\n          }\n        } else {\n          output.add(result.output);\n        }\n        key++;\n      }\n      return issues ? getIssues(issues) : executePipe(output, this.pipe, info, \"set\");\n    }\n  };\n}\n\n// src/schemas/set/setAsync.ts\nfunction setAsync(value2, arg2, arg3) {\n  const [message = \"Invalid type\", pipe] = getDefaultArgs(arg2, arg3);\n  return {\n    type: \"set\",\n    async: true,\n    value: value2,\n    message,\n    pipe,\n    async _parse(input, info) {\n      if (!(input instanceof Set)) {\n        return getSchemaIssues(info, \"type\", \"set\", this.message, input);\n      }\n      let issues;\n      const output = /* @__PURE__ */ new Set();\n      await Promise.all(\n        Array.from(input.values()).map(async (inputValue, key) => {\n          if (!(info?.abortEarly && issues)) {\n            const result = await this.value._parse(inputValue, info);\n            if (!(info?.abortEarly && issues)) {\n              if (result.issues) {\n                const pathItem = {\n                  type: \"set\",\n                  input,\n                  key,\n                  value: inputValue\n                };\n                for (const issue of result.issues) {\n                  if (issue.path) {\n                    issue.path.unshift(pathItem);\n                  } else {\n                    issue.path = [pathItem];\n                  }\n                  issues?.push(issue);\n                }\n                if (!issues) {\n                  issues = result.issues;\n                }\n                if (info?.abortEarly) {\n                  throw null;\n                }\n              } else {\n                output.add(result.output);\n              }\n            }\n          }\n        })\n      ).catch(() => null);\n      return issues ? getIssues(issues) : executePipeAsync(input, this.pipe, info, \"set\");\n    }\n  };\n}\n\n// src/schemas/special/special.ts\nfunction special(check, arg2, arg3) {\n  const [message = \"Invalid type\", pipe] = getDefaultArgs(arg2, arg3);\n  return {\n    type: \"special\",\n    async: false,\n    check,\n    message,\n    pipe,\n    _parse(input, info) {\n      if (!this.check(input)) {\n        return getSchemaIssues(info, \"type\", \"special\", this.message, input);\n      }\n      return executePipe(input, this.pipe, info, \"special\");\n    }\n  };\n}\n\n// src/schemas/special/specialAsync.ts\nfunction specialAsync(check, arg2, arg3) {\n  const [message = \"Invalid type\", pipe] = getDefaultArgs(arg2, arg3);\n  return {\n    type: \"special\",\n    async: true,\n    check,\n    message,\n    pipe,\n    async _parse(input, info) {\n      if (!await this.check(input)) {\n        return getSchemaIssues(info, \"type\", \"special\", this.message, input);\n      }\n      return executePipeAsync(input, this.pipe, info, \"special\");\n    }\n  };\n}\n\n// src/schemas/symbol/symbol.ts\nfunction symbol(message = \"Invalid type\") {\n  return {\n    type: \"symbol\",\n    async: false,\n    message,\n    _parse(input, info) {\n      if (typeof input !== \"symbol\") {\n        return getSchemaIssues(info, \"type\", \"symbol\", this.message, input);\n      }\n      return getOutput(input);\n    }\n  };\n}\n\n// src/schemas/symbol/symbolAsync.ts\nfunction symbolAsync(message = \"Invalid type\") {\n  return {\n    type: \"symbol\",\n    async: true,\n    message,\n    async _parse(input, info) {\n      if (typeof input !== \"symbol\") {\n        return getSchemaIssues(info, \"type\", \"symbol\", this.message, input);\n      }\n      return getOutput(input);\n    }\n  };\n}\n\n// src/schemas/tuple/tuple.ts\nfunction tuple(items, arg2, arg3, arg4) {\n  const [rest, message = \"Invalid type\", pipe] = getRestAndDefaultArgs(arg2, arg3, arg4);\n  return {\n    type: \"tuple\",\n    async: false,\n    items,\n    rest,\n    message,\n    pipe,\n    _parse(input, info) {\n      if (!Array.isArray(input) || this.items.length > input.length) {\n        return getSchemaIssues(info, \"type\", \"tuple\", this.message, input);\n      }\n      let issues;\n      const output = [];\n      for (let key = 0; key < this.items.length; key++) {\n        const value2 = input[key];\n        const result = this.items[key]._parse(value2, info);\n        if (result.issues) {\n          const pathItem = {\n            type: \"tuple\",\n            input,\n            key,\n            value: value2\n          };\n          for (const issue of result.issues) {\n            if (issue.path) {\n              issue.path.unshift(pathItem);\n            } else {\n              issue.path = [pathItem];\n            }\n            issues?.push(issue);\n          }\n          if (!issues) {\n            issues = result.issues;\n          }\n          if (info?.abortEarly) {\n            break;\n          }\n        } else {\n          output[key] = result.output;\n        }\n      }\n      if (this.rest && !(info?.abortEarly && issues)) {\n        for (let key = this.items.length; key < input.length; key++) {\n          const value2 = input[key];\n          const result = this.rest._parse(value2, info);\n          if (result.issues) {\n            const pathItem = {\n              type: \"tuple\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of result.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              issues?.push(issue);\n            }\n            if (!issues) {\n              issues = result.issues;\n            }\n            if (info?.abortEarly) {\n              break;\n            }\n          } else {\n            output[key] = result.output;\n          }\n        }\n      }\n      return issues ? getIssues(issues) : executePipe(\n        output,\n        this.pipe,\n        info,\n        \"tuple\"\n      );\n    }\n  };\n}\n\n// src/schemas/tuple/tupleAsync.ts\nfunction tupleAsync(items, arg2, arg3, arg4) {\n  const [rest, message = \"Invalid type\", pipe] = getRestAndDefaultArgs(arg2, arg3, arg4);\n  return {\n    type: \"tuple\",\n    async: true,\n    items,\n    rest,\n    message,\n    pipe,\n    async _parse(input, info) {\n      if (!Array.isArray(input) || this.items.length > input.length) {\n        return getSchemaIssues(info, \"type\", \"tuple\", this.message, input);\n      }\n      let issues;\n      const output = [];\n      await Promise.all([\n        // Parse schema of each tuple item\n        Promise.all(\n          this.items.map(async (schema, key) => {\n            if (!(info?.abortEarly && issues)) {\n              const value2 = input[key];\n              const result = await schema._parse(value2, info);\n              if (!(info?.abortEarly && issues)) {\n                if (result.issues) {\n                  const pathItem = {\n                    type: \"tuple\",\n                    input,\n                    key,\n                    value: value2\n                  };\n                  for (const issue of result.issues) {\n                    if (issue.path) {\n                      issue.path.unshift(pathItem);\n                    } else {\n                      issue.path = [pathItem];\n                    }\n                    issues?.push(issue);\n                  }\n                  if (!issues) {\n                    issues = result.issues;\n                  }\n                  if (info?.abortEarly) {\n                    throw null;\n                  }\n                } else {\n                  output[key] = result.output;\n                }\n              }\n            }\n          })\n        ),\n        // If necessary parse schema of each rest item\n        this.rest && Promise.all(\n          input.slice(this.items.length).map(async (value2, index) => {\n            if (!(info?.abortEarly && issues)) {\n              const key = this.items.length + index;\n              const result = await this.rest._parse(value2, info);\n              if (!(info?.abortEarly && issues)) {\n                if (result.issues) {\n                  const pathItem = {\n                    type: \"tuple\",\n                    input,\n                    key,\n                    value: value2\n                  };\n                  for (const issue of result.issues) {\n                    if (issue.path) {\n                      issue.path.unshift(pathItem);\n                    } else {\n                      issue.path = [pathItem];\n                    }\n                    issues?.push(issue);\n                  }\n                  if (!issues) {\n                    issues = result.issues;\n                  }\n                  if (info?.abortEarly) {\n                    throw null;\n                  }\n                } else {\n                  output[key] = result.output;\n                }\n              }\n            }\n          })\n        )\n      ]).catch(() => null);\n      return issues ? getIssues(issues) : executePipeAsync(\n        output,\n        this.pipe,\n        info,\n        \"tuple\"\n      );\n    }\n  };\n}\n\n// src/schemas/undefined/undefined.ts\nfunction undefined_(message = \"Invalid type\") {\n  return {\n    type: \"undefined\",\n    async: false,\n    message,\n    _parse(input, info) {\n      if (typeof input !== \"undefined\") {\n        return getSchemaIssues(info, \"type\", \"undefined\", this.message, input);\n      }\n      return getOutput(input);\n    }\n  };\n}\nvar undefinedType = undefined_;\n\n// src/schemas/undefined/undefinedAsync.ts\nfunction undefinedAsync(message = \"Invalid type\") {\n  return {\n    type: \"undefined\",\n    async: true,\n    message,\n    async _parse(input, info) {\n      if (typeof input !== \"undefined\") {\n        return getSchemaIssues(info, \"type\", \"undefined\", this.message, input);\n      }\n      return getOutput(input);\n    }\n  };\n}\nvar undefinedTypeAsync = undefinedAsync;\n\n// src/schemas/union/union.ts\nfunction union(options, message = \"Invalid type\") {\n  return {\n    type: \"union\",\n    async: false,\n    options,\n    message,\n    _parse(input, info) {\n      let issues;\n      let output;\n      for (const schema of this.options) {\n        const result = schema._parse(input, info);\n        if (result.issues) {\n          if (issues) {\n            for (const issue of result.issues) {\n              issues.push(issue);\n            }\n          } else {\n            issues = result.issues;\n          }\n        } else {\n          output = [result.output];\n          break;\n        }\n      }\n      return output ? getOutput(output[0]) : getSchemaIssues(info, \"type\", \"union\", this.message, input, issues);\n    }\n  };\n}\n\n// src/schemas/union/unionAsync.ts\nfunction unionAsync(options, message = \"Invalid type\") {\n  return {\n    type: \"union\",\n    async: true,\n    options,\n    message,\n    async _parse(input, info) {\n      let issues;\n      let output;\n      for (const schema of this.options) {\n        const result = await schema._parse(input, info);\n        if (result.issues) {\n          if (issues) {\n            for (const issue of result.issues) {\n              issues.push(issue);\n            }\n          } else {\n            issues = result.issues;\n          }\n        } else {\n          output = [result.output];\n          break;\n        }\n      }\n      return output ? getOutput(output[0]) : getSchemaIssues(info, \"type\", \"union\", this.message, input, issues);\n    }\n  };\n}\n\n// src/schemas/unknown/unknown.ts\nfunction unknown(pipe) {\n  return {\n    type: \"unknown\",\n    async: false,\n    pipe,\n    _parse(input, info) {\n      return executePipe(input, this.pipe, info, \"unknown\");\n    }\n  };\n}\n\n// src/schemas/unknown/unknownAsync.ts\nfunction unknownAsync(pipe) {\n  return {\n    type: \"unknown\",\n    async: true,\n    pipe,\n    async _parse(input, info) {\n      return executePipeAsync(input, this.pipe, info, \"unknown\");\n    }\n  };\n}\n\n// src/schemas/variant/variant.ts\nfunction variant(key, options, message = \"Invalid type\") {\n  return {\n    type: \"variant\",\n    async: false,\n    key,\n    options,\n    message,\n    _parse(input, info) {\n      if (!input || typeof input !== \"object\" || !(this.key in input)) {\n        return getSchemaIssues(info, \"type\", \"variant\", this.message, input);\n      }\n      let issues;\n      let output;\n      const parseOptions = (options2) => {\n        for (const schema of options2) {\n          if (schema.type === \"object\") {\n            const result = schema.entries[this.key]._parse(\n              input[this.key],\n              info\n            );\n            if (!result.issues) {\n              const result2 = schema._parse(input, info);\n              if (result2.issues) {\n                issues = result2.issues;\n              } else {\n                output = [result2.output];\n              }\n              break;\n            }\n          } else if (schema.type === \"variant\") {\n            parseOptions(schema.options);\n            if (issues || output) {\n              break;\n            }\n          }\n        }\n      };\n      parseOptions(this.options);\n      return output ? getOutput(output[0]) : issues ? getIssues(issues) : getSchemaIssues(info, \"type\", \"variant\", this.message, input);\n    }\n  };\n}\nvar discriminatedUnion = variant;\n\n// src/schemas/variant/variantAsync.ts\nfunction variantAsync(key, options, message = \"Invalid type\") {\n  return {\n    type: \"variant\",\n    async: true,\n    key,\n    options,\n    message,\n    async _parse(input, info) {\n      if (!input || typeof input !== \"object\" || !(this.key in input)) {\n        return getSchemaIssues(info, \"type\", \"variant\", this.message, input);\n      }\n      let issues;\n      let output;\n      const parseOptions = async (options2) => {\n        for (const schema of options2) {\n          if (schema.type === \"object\") {\n            const result = await schema.entries[this.key]._parse(\n              input[this.key],\n              info\n            );\n            if (!result.issues) {\n              const result2 = await schema._parse(input, info);\n              if (result2.issues) {\n                issues = result2.issues;\n              } else {\n                output = [result2.output];\n              }\n              break;\n            }\n          } else if (schema.type === \"variant\") {\n            await parseOptions(schema.options);\n            if (issues || output) {\n              break;\n            }\n          }\n        }\n      };\n      await parseOptions(this.options);\n      return output ? getOutput(output[0]) : issues ? getIssues(issues) : getSchemaIssues(info, \"type\", \"variant\", this.message, input);\n    }\n  };\n}\nvar discriminatedUnionAsync = variantAsync;\n\n// src/schemas/void/void.ts\nfunction void_(message = \"Invalid type\") {\n  return {\n    type: \"void\",\n    async: false,\n    message,\n    _parse(input, info) {\n      if (typeof input !== \"undefined\") {\n        return getSchemaIssues(info, \"type\", \"void\", this.message, input);\n      }\n      return getOutput(input);\n    }\n  };\n}\nvar voidType = void_;\n\n// src/schemas/void/voidAsync.ts\nfunction voidAsync(message = \"Invalid type\") {\n  return {\n    type: \"void\",\n    async: true,\n    message,\n    async _parse(input, info) {\n      if (typeof input !== \"undefined\") {\n        return getSchemaIssues(info, \"type\", \"void\", this.message, input);\n      }\n      return getOutput(input);\n    }\n  };\n}\nvar voidTypeAsync = voidAsync;\n\n// src/methods/keyof/keyof.ts\nfunction keyof(schema) {\n  return picklist(\n    Object.keys(schema.entries)\n  );\n}\n\n// src/methods/merge/merge.ts\nfunction merge(schemas, arg2, arg3, arg4) {\n  const [rest, message, pipe] = getRestAndDefaultArgs(arg2, arg3, arg4);\n  return object(\n    schemas.reduce(\n      (entries, schema) => ({ ...entries, ...schema.entries }),\n      {}\n    ),\n    rest,\n    message,\n    pipe\n  );\n}\n\n// src/methods/merge/mergeAsync.ts\nfunction mergeAsync(schemas, arg2, arg3, arg4) {\n  const [rest, message, pipe] = getRestAndDefaultArgs(arg2, arg3, arg4);\n  return objectAsync(\n    schemas.reduce(\n      (entries, schema) => ({ ...entries, ...schema.entries }),\n      {}\n    ),\n    rest,\n    message,\n    pipe\n  );\n}\n\n// src/methods/omit/omit.ts\nfunction omit(schema, keys, arg3, arg4, arg5) {\n  const [rest, message, pipe] = getRestAndDefaultArgs(arg3, arg4, arg5);\n  return object(\n    Object.entries(schema.entries).reduce(\n      (entries, [key, schema2]) => keys.includes(key) ? entries : { ...entries, [key]: schema2 },\n      {}\n    ),\n    rest,\n    message,\n    pipe\n  );\n}\n\n// src/methods/omit/omitAsync.ts\nfunction omitAsync(schema, keys, arg3, arg4, arg5) {\n  const [rest, message, pipe] = getRestAndDefaultArgs(arg3, arg4, arg5);\n  return objectAsync(\n    Object.entries(schema.entries).reduce(\n      (entries, [key, schema2]) => keys.includes(key) ? entries : { ...entries, [key]: schema2 },\n      {}\n    ),\n    rest,\n    message,\n    pipe\n  );\n}\n\n// src/methods/parse/parse.ts\nfunction parse(schema, input, info) {\n  const result = schema._parse(input, info);\n  if (result.issues) {\n    throw new ValiError(result.issues);\n  }\n  return result.output;\n}\n\n// src/methods/parse/parseAsync.ts\nasync function parseAsync(schema, input, info) {\n  const result = await schema._parse(input, info);\n  if (result.issues) {\n    throw new ValiError(result.issues);\n  }\n  return result.output;\n}\n\n// src/methods/partial/partial.ts\nfunction partial(schema, arg2, arg3, arg4) {\n  const [rest, message, pipe] = getRestAndDefaultArgs(arg2, arg3, arg4);\n  return object(\n    Object.entries(schema.entries).reduce(\n      (entries, [key, schema2]) => ({\n        ...entries,\n        [key]: optional(schema2)\n      }),\n      {}\n    ),\n    rest,\n    message,\n    pipe\n  );\n}\n\n// src/methods/partial/partialAsync.ts\nfunction partialAsync(schema, arg2, arg3, arg4) {\n  const [rest, message, pipe] = getRestAndDefaultArgs(arg2, arg3, arg4);\n  return objectAsync(\n    Object.entries(schema.entries).reduce(\n      (entries, [key, schema2]) => ({\n        ...entries,\n        [key]: optionalAsync(schema2)\n      }),\n      {}\n    ),\n    rest,\n    message,\n    pipe\n  );\n}\n\n// src/methods/passthrough/passthrough.ts\nfunction passthrough(schema) {\n  return {\n    ...schema,\n    _parse(input, info) {\n      const result = schema._parse(input, info);\n      return !result.issues ? getOutput({ ...input, ...result.output }) : result;\n    }\n  };\n}\n\n// src/methods/passthrough/passthroughAsync.ts\nfunction passthroughAsync(schema) {\n  return {\n    ...schema,\n    async _parse(input, info) {\n      const result = await schema._parse(input, info);\n      return !result.issues ? getOutput({ ...input, ...result.output }) : result;\n    }\n  };\n}\n\n// src/methods/pick/pick.ts\nfunction pick(schema, keys, arg3, arg4, arg5) {\n  const [rest, message, pipe] = getRestAndDefaultArgs(arg3, arg4, arg5);\n  return object(\n    Object.entries(schema.entries).reduce(\n      (entries, [key, schema2]) => keys.includes(key) ? { ...entries, [key]: schema2 } : entries,\n      {}\n    ),\n    rest,\n    message,\n    pipe\n  );\n}\n\n// src/methods/pick/pickAsync.ts\nfunction pickAsync(schema, keys, arg3, arg4, arg5) {\n  const [rest, message, pipe] = getRestAndDefaultArgs(arg3, arg4, arg5);\n  return objectAsync(\n    Object.entries(schema.entries).reduce(\n      (entries, [key, schema2]) => keys.includes(key) ? { ...entries, [key]: schema2 } : entries,\n      {}\n    ),\n    rest,\n    message,\n    pipe\n  );\n}\n\n// src/methods/required/required.ts\nfunction required(schema, arg2, arg3, arg4) {\n  const [rest, message, pipe] = getRestAndDefaultArgs(arg2, arg3, arg4);\n  return object(\n    Object.entries(schema.entries).reduce(\n      (entries, [key, schema2]) => ({\n        ...entries,\n        [key]: nonOptional(schema2)\n      }),\n      {}\n    ),\n    rest,\n    message,\n    pipe\n  );\n}\n\n// src/methods/required/requiredAsync.ts\nfunction requiredAsync(schema, arg2, arg3, arg4) {\n  const [rest, message, pipe] = getRestAndDefaultArgs(arg2, arg3, arg4);\n  return objectAsync(\n    Object.entries(schema.entries).reduce(\n      (entries, [key, schema2]) => ({\n        ...entries,\n        [key]: nonOptionalAsync(schema2)\n      }),\n      {}\n    ),\n    rest,\n    message,\n    pipe\n  );\n}\n\n// src/methods/safeParse/safeParse.ts\nfunction safeParse(schema, input, info) {\n  const result = schema._parse(input, info);\n  return result.issues ? {\n    success: false,\n    error: new ValiError(result.issues),\n    issues: result.issues\n  } : {\n    success: true,\n    data: result.output,\n    output: result.output\n  };\n}\n\n// src/methods/safeParse/safeParseAsync.ts\nasync function safeParseAsync(schema, input, info) {\n  const result = await schema._parse(input, info);\n  return result.issues ? {\n    success: false,\n    error: new ValiError(result.issues),\n    issues: result.issues\n  } : {\n    success: true,\n    data: result.output,\n    output: result.output\n  };\n}\n\n// src/methods/strict/strict.ts\nfunction strict(schema, message = \"Invalid keys\") {\n  return {\n    ...schema,\n    _parse(input, info) {\n      const result = schema._parse(input, info);\n      return !result.issues && Object.keys(input).some((key) => !(key in schema.entries)) ? getSchemaIssues(info, \"object\", \"strict\", message, input) : result;\n    }\n  };\n}\n\n// src/methods/strict/strictAsync.ts\nfunction strictAsync(schema, message = \"Invalid keys\") {\n  return {\n    ...schema,\n    message,\n    async _parse(input, info) {\n      const result = await schema._parse(input, info);\n      return !result.issues && Object.keys(input).some((key) => !(key in schema.entries)) ? getSchemaIssues(info, \"object\", \"strict\", message, input) : result;\n    }\n  };\n}\n\n// src/methods/strip/strip.ts\nfunction strip(schema) {\n  let cachedKeys;\n  return {\n    ...schema,\n    _parse(input, info) {\n      const result = schema._parse(input, info);\n      if (result.issues) {\n        return result;\n      }\n      cachedKeys = cachedKeys || Object.keys(schema.entries);\n      const output = {};\n      for (const key of cachedKeys) {\n        output[key] = result.output[key];\n      }\n      return getOutput(output);\n    }\n  };\n}\n\n// src/methods/strip/stripAsync.ts\nfunction stripAsync(schema) {\n  let cachedKeys;\n  return {\n    ...schema,\n    async _parse(input, info) {\n      const result = await schema._parse(input, info);\n      if (result.issues) {\n        return result;\n      }\n      cachedKeys = cachedKeys || Object.keys(schema.entries);\n      const output = {};\n      for (const key of cachedKeys) {\n        output[key] = result.output[key];\n      }\n      return getOutput(output);\n    }\n  };\n}\n\n// src/methods/transform/transform.ts\nfunction transform(schema, action, arg1) {\n  return {\n    ...schema,\n    _parse(input, info) {\n      const result = schema._parse(input, info);\n      if (result.issues) {\n        return result;\n      }\n      const output = action(result.output);\n      if (arg1 && !Array.isArray(arg1)) {\n        return arg1._parse(output, info);\n      }\n      return executePipe(output, arg1, info, typeof output);\n    }\n  };\n}\n\n// src/methods/transform/transformAsync.ts\nfunction transformAsync(schema, action, arg1) {\n  return {\n    ...schema,\n    async: true,\n    async _parse(input, info) {\n      const result = await schema._parse(input, info);\n      if (result.issues) {\n        return result;\n      }\n      const output = await action(result.output);\n      if (arg1 && !Array.isArray(arg1)) {\n        return arg1._parse(output, info);\n      }\n      return executePipeAsync(output, arg1, info, typeof output);\n    }\n  };\n}\n\n// src/methods/unwrap/unwrap.ts\nfunction unwrap(schema) {\n  return schema.wrapped;\n}\n\n// src/methods/withDefault/withDefault.ts\nfunction withDefault(schema, value2) {\n  return {\n    ...schema,\n    _parse(input, info) {\n      return schema._parse(\n        input === void 0 ? typeof value2 === \"function\" ? value2() : value2 : input,\n        info\n      );\n    }\n  };\n}\nvar useDefault = withDefault;\n\n// src/regex.ts\nvar CUID2_REGEX = /^[a-z][\\da-z]*$/u;\nvar EMAIL_REGEX = /^[\\w+-]+(?:\\.[\\w+-]+)*@[\\da-z]+(?:[.-][\\da-z]+)*\\.[a-z]{2,}$/iu;\nvar EMOJI_REGEX = /^[\\p{Extended_Pictographic}\\p{Emoji_Component}]+$/u;\nvar IMEI_REGEX = /^\\d{2}(?:[ /|-]?\\d{6}){2}[ /|-]?\\d$/u;\nvar IPV4_REGEX = (\n  // eslint-disable-next-line redos-detector/no-unsafe-regex -- false positive\n  /^(?:(?:[1-9]|1\\d|2[0-4])?\\d|25[0-5])(?:\\.(?:(?:[1-9]|1\\d|2[0-4])?\\d|25[0-5])){3}$/u\n);\nvar IPV6_REGEX = /^(?:(?:[\\da-f]{1,4}:){7}[\\da-f]{1,4}|(?:[\\da-f]{1,4}:){1,7}:|(?:[\\da-f]{1,4}:){1,6}:[\\da-f]{1,4}|(?:[\\da-f]{1,4}:){1,5}(?::[\\da-f]{1,4}){1,2}|(?:[\\da-f]{1,4}:){1,4}(?::[\\da-f]{1,4}){1,3}|(?:[\\da-f]{1,4}:){1,3}(?::[\\da-f]{1,4}){1,4}|(?:[\\da-f]{1,4}:){1,2}(?::[\\da-f]{1,4}){1,5}|[\\da-f]{1,4}:(?::[\\da-f]{1,4}){1,6}|:(?:(?::[\\da-f]{1,4}){1,7}|:)|fe80:(?::[\\da-f]{0,4}){0,4}%[\\da-z]+|::(?:f{4}(?::0{1,4})?:)?(?:(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d)\\.){3}(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d)|(?:[\\da-f]{1,4}:){1,4}:(?:(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d)\\.){3}(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d))$/iu;\nvar ISO_DATE_REGEX = /^\\d{4}-(?:0[1-9]|1[0-2])-(?:[12]\\d|0[1-9]|3[01])$/u;\nvar ISO_DATE_TIME_REGEX = /^\\d{4}-(?:0[1-9]|1[0-2])-(?:[12]\\d|0[1-9]|3[01])T(?:0\\d|1\\d|2[0-3]):[0-5]\\d$/u;\nvar ISO_TIME_REGEX = /^(?:0\\d|1\\d|2[0-3]):[0-5]\\d$/u;\nvar ISO_TIME_SECOND_REGEX = /^(?:0\\d|1\\d|2[0-3])(?::[0-5]\\d){2}$/u;\nvar ISO_TIMESTAMP_REGEX = /^\\d{4}-(?:0[1-9]|1[0-2])-(?:[12]\\d|0[1-9]|3[01])T(?:0\\d|1\\d|2[0-3])(?::[0-5]\\d){2}\\.\\d{3}Z$/u;\nvar ISO_WEEK_REGEX = /^\\d{4}-W(?:0[1-9]|[1-4]\\d|5[0-3])$/u;\nvar ULID_REGEX = /^[\\da-hjkmnp-tv-z]{26}$/iu;\nvar UUID_REGEX = /^[\\da-f]{8}(?:-[\\da-f]{4}){3}-[\\da-f]{12}$/iu;\n\n// src/transformations/toCustom/toCustom.ts\nfunction toCustom(action) {\n  return {\n    type: \"to_custom\",\n    async: false,\n    _parse(input) {\n      return getOutput(action(input));\n    }\n  };\n}\n\n// src/transformations/toCustom/toCustomAsync.ts\nfunction toCustomAsync(action) {\n  return {\n    type: \"to_custom\",\n    async: true,\n    async _parse(input) {\n      return getOutput(await action(input));\n    }\n  };\n}\n\n// src/transformations/toLowerCase/toLowerCase.ts\nfunction toLowerCase() {\n  return {\n    type: \"to_lower_case\",\n    async: false,\n    _parse(input) {\n      return getOutput(input.toLocaleLowerCase());\n    }\n  };\n}\n\n// src/transformations/toMaxValue/toMaxValue.ts\nfunction toMaxValue(requirement) {\n  return {\n    type: \"to_max_value\",\n    async: false,\n    requirement,\n    _parse(input) {\n      return getOutput(input > this.requirement ? this.requirement : input);\n    }\n  };\n}\n\n// src/transformations/toMinValue/toMinValue.ts\nfunction toMinValue(requirement) {\n  return {\n    type: \"to_min_value\",\n    async: false,\n    requirement,\n    _parse(input) {\n      return getOutput(input < this.requirement ? this.requirement : input);\n    }\n  };\n}\n\n// src/transformations/toTrimmed/toTrimmed.ts\nfunction toTrimmed() {\n  return {\n    type: \"to_trimmed\",\n    async: false,\n    _parse(input) {\n      return getOutput(input.trim());\n    }\n  };\n}\n\n// src/transformations/toTrimmedEnd/toTrimmedEnd.ts\nfunction toTrimmedEnd() {\n  return {\n    type: \"to_trimmed_end\",\n    async: false,\n    _parse(input) {\n      return getOutput(input.trimEnd());\n    }\n  };\n}\n\n// src/transformations/toTrimmedStart/toTrimmedStart.ts\nfunction toTrimmedStart() {\n  return {\n    type: \"to_trimmed_start\",\n    async: false,\n    _parse(input) {\n      return getOutput(input.trimStart());\n    }\n  };\n}\n\n// src/transformations/toUpperCase/toUpperCase.ts\nfunction toUpperCase() {\n  return {\n    type: \"to_upper_case\",\n    async: false,\n    _parse(input) {\n      return getOutput(input.toUpperCase());\n    }\n  };\n}\n\n// src/validations/bytes/bytes.ts\nfunction bytes(requirement, message = \"Invalid byte length\") {\n  return {\n    type: \"bytes\",\n    async: false,\n    message,\n    requirement,\n    _parse(input) {\n      return new TextEncoder().encode(input).length !== this.requirement ? getPipeIssues(this.type, this.message, input, this.requirement) : getOutput(input);\n    }\n  };\n}\n\n// src/validations/cuid2/cuid2.ts\nfunction cuid2(message = \"Invalid Cuid2\") {\n  return {\n    type: \"cuid2\",\n    async: false,\n    message,\n    requirement: CUID2_REGEX,\n    _parse(input) {\n      return !this.requirement.test(input) ? getPipeIssues(this.type, this.message, input, this.requirement) : getOutput(input);\n    }\n  };\n}\n\n// src/validations/custom/custom.ts\nfunction custom(requirement, message = \"Invalid input\") {\n  return {\n    type: \"custom\",\n    async: false,\n    message,\n    requirement,\n    _parse(input) {\n      return !this.requirement(input) ? getPipeIssues(this.type, this.message, input, this.requirement) : getOutput(input);\n    }\n  };\n}\n\n// src/validations/custom/customAsync.ts\nfunction customAsync(requirement, message = \"Invalid input\") {\n  return {\n    type: \"custom\",\n    async: true,\n    message,\n    requirement,\n    async _parse(input) {\n      return !await this.requirement(input) ? getPipeIssues(this.type, this.message, input, this.requirement) : getOutput(input);\n    }\n  };\n}\n\n// src/validations/email/email.ts\nfunction email(message = \"Invalid email\") {\n  return {\n    type: \"email\",\n    async: false,\n    message,\n    requirement: EMAIL_REGEX,\n    _parse(input) {\n      return !this.requirement.test(input) ? getPipeIssues(this.type, this.message, input, this.requirement) : getOutput(input);\n    }\n  };\n}\n\n// src/validations/emoji/emoji.ts\nfunction emoji(message = \"Invalid emoji\") {\n  return {\n    type: \"emoji\",\n    async: false,\n    message,\n    requirement: EMOJI_REGEX,\n    _parse(input) {\n      return !this.requirement.test(input) ? getPipeIssues(this.type, this.message, input, this.requirement) : getOutput(input);\n    }\n  };\n}\n\n// src/validations/endsWith/endsWith.ts\nfunction endsWith(requirement, message = \"Invalid end\") {\n  return {\n    type: \"ends_with\",\n    async: false,\n    message,\n    requirement,\n    _parse(input) {\n      return !input.endsWith(this.requirement) ? getPipeIssues(this.type, this.message, input, this.requirement) : getOutput(input);\n    }\n  };\n}\n\n// src/validations/equal/equal.ts\nfunction equal(requirement, message = \"Invalid input\") {\n  return {\n    type: \"equal\",\n    async: false,\n    message,\n    requirement,\n    _parse(input) {\n      return input !== this.requirement ? getPipeIssues(this.type, this.message, input, this.requirement) : getOutput(input);\n    }\n  };\n}\n\n// src/validations/excludes/excludes.ts\nfunction excludes(requirement, message = \"Invalid content\") {\n  return {\n    type: \"excludes\",\n    async: false,\n    message,\n    requirement,\n    _parse(input) {\n      return input.includes(this.requirement) ? getPipeIssues(this.type, this.message, input, this.requirement) : getOutput(input);\n    }\n  };\n}\n\n// src/validations/finite/finite.ts\nfunction finite(message = \"Invalid finite number\") {\n  return {\n    type: \"finite\",\n    async: false,\n    message,\n    requirement: Number.isFinite,\n    _parse(input) {\n      return !this.requirement(input) ? getPipeIssues(this.type, this.message, input, this.requirement) : getOutput(input);\n    }\n  };\n}\n\n// src/validations/imei/imei.ts\nfunction imei(message = \"Invalid IMEI\") {\n  return {\n    type: \"imei\",\n    async: false,\n    message,\n    requirement: [IMEI_REGEX, isLuhnAlgo],\n    _parse(input) {\n      return !this.requirement[0].test(input) || !this.requirement[1](input) ? getPipeIssues(this.type, this.message, input, this.requirement) : getOutput(input);\n    }\n  };\n}\n\n// src/validations/includes/includes.ts\nfunction includes(requirement, message = \"Invalid content\") {\n  return {\n    type: \"includes\",\n    async: false,\n    message,\n    requirement,\n    _parse(input) {\n      return !input.includes(requirement) ? getPipeIssues(this.type, this.message, input, this.requirement) : getOutput(input);\n    }\n  };\n}\n\n// src/validations/integer/integer.ts\nfunction integer(message = \"Invalid integer\") {\n  return {\n    type: \"integer\",\n    async: false,\n    message,\n    requirement: Number.isInteger,\n    _parse(input) {\n      return !this.requirement(input) ? getPipeIssues(this.type, this.message, input, this.requirement) : getOutput(input);\n    }\n  };\n}\n\n// src/validations/ip/ip.ts\nfunction ip(message = \"Invalid IP\") {\n  return {\n    type: \"ip\",\n    async: false,\n    message,\n    requirement: [IPV4_REGEX, IPV6_REGEX],\n    _parse(input) {\n      return !this.requirement[0].test(input) && !this.requirement[1].test(input) ? getPipeIssues(this.type, this.message, input, this.requirement) : getOutput(input);\n    }\n  };\n}\n\n// src/validations/ipv4/ipv4.ts\nfunction ipv4(message = \"Invalid IPv4\") {\n  return {\n    type: \"ipv4\",\n    async: false,\n    message,\n    requirement: IPV4_REGEX,\n    _parse(input) {\n      return !this.requirement.test(input) ? getPipeIssues(this.type, this.message, input, this.requirement) : getOutput(input);\n    }\n  };\n}\n\n// src/validations/ipv6/ipv6.ts\nfunction ipv6(message = \"Invalid IPv6\") {\n  return {\n    type: \"ipv6\",\n    async: false,\n    message,\n    requirement: IPV6_REGEX,\n    _parse(input) {\n      return !this.requirement.test(input) ? getPipeIssues(this.type, this.message, input, this.requirement) : getOutput(input);\n    }\n  };\n}\n\n// src/validations/isoDate/isoDate.ts\nfunction isoDate(message = \"Invalid date\") {\n  return {\n    type: \"iso_date\",\n    async: false,\n    message,\n    requirement: ISO_DATE_REGEX,\n    _parse(input) {\n      return !this.requirement.test(input) ? getPipeIssues(this.type, this.message, input, this.requirement) : getOutput(input);\n    }\n  };\n}\n\n// src/validations/isoDateTime/isoDateTime.ts\nfunction isoDateTime(message = \"Invalid date-time\") {\n  return {\n    type: \"iso_date_time\",\n    async: false,\n    message,\n    requirement: ISO_DATE_TIME_REGEX,\n    _parse(input) {\n      return !this.requirement.test(input) ? getPipeIssues(this.type, this.message, input, this.requirement) : getOutput(input);\n    }\n  };\n}\n\n// src/validations/isoTime/isoTime.ts\nfunction isoTime(message = \"Invalid time\") {\n  return {\n    type: \"iso_time\",\n    async: false,\n    message,\n    requirement: ISO_TIME_REGEX,\n    _parse(input) {\n      return !this.requirement.test(input) ? getPipeIssues(this.type, this.message, input, this.requirement) : getOutput(input);\n    }\n  };\n}\n\n// src/validations/isoTimeSecond/isoTimeSecond.ts\nfunction isoTimeSecond(message = \"Invalid time second\") {\n  return {\n    type: \"iso_time_second\",\n    async: false,\n    message,\n    requirement: ISO_TIME_SECOND_REGEX,\n    _parse(input) {\n      return !this.requirement.test(input) ? getPipeIssues(this.type, this.message, input, this.requirement) : getOutput(input);\n    }\n  };\n}\n\n// src/validations/isoTimestamp/isoTimestamp.ts\nfunction isoTimestamp(message = \"Invalid timestamp\") {\n  return {\n    type: \"iso_timestamp\",\n    async: false,\n    message,\n    requirement: ISO_TIMESTAMP_REGEX,\n    _parse(input) {\n      return !this.requirement.test(input) ? getPipeIssues(this.type, this.message, input, this.requirement) : getOutput(input);\n    }\n  };\n}\n\n// src/validations/isoWeek/isoWeek.ts\nfunction isoWeek(message = \"Invalid week\") {\n  return {\n    type: \"iso_week\",\n    async: false,\n    message,\n    requirement: ISO_WEEK_REGEX,\n    _parse(input) {\n      return !this.requirement.test(input) ? getPipeIssues(this.type, this.message, input, this.requirement) : getOutput(input);\n    }\n  };\n}\n\n// src/validations/length/length.ts\nfunction length(requirement, message = \"Invalid length\") {\n  return {\n    type: \"length\",\n    async: false,\n    message,\n    requirement,\n    _parse(input) {\n      return input.length !== this.requirement ? getPipeIssues(this.type, this.message, input, this.requirement) : getOutput(input);\n    }\n  };\n}\n\n// src/validations/maxBytes/maxBytes.ts\nfunction maxBytes(requirement, message = \"Invalid byte length\") {\n  return {\n    type: \"max_bytes\",\n    async: false,\n    message,\n    requirement,\n    _parse(input) {\n      return new TextEncoder().encode(input).length > this.requirement ? getPipeIssues(this.type, this.message, input, this.requirement) : getOutput(input);\n    }\n  };\n}\n\n// src/validations/maxLength/maxLength.ts\nfunction maxLength(requirement, message = \"Invalid length\") {\n  return {\n    type: \"max_length\",\n    async: false,\n    message,\n    requirement,\n    _parse(input) {\n      return input.length > this.requirement ? getPipeIssues(this.type, this.message, input, this.requirement) : getOutput(input);\n    }\n  };\n}\n\n// src/validations/maxSize/maxSize.ts\nfunction maxSize(requirement, message = \"Invalid size\") {\n  return {\n    type: \"max_size\",\n    async: false,\n    message,\n    requirement,\n    _parse(input) {\n      return input.size > this.requirement ? getPipeIssues(this.type, this.message, input, this.requirement) : getOutput(input);\n    }\n  };\n}\n\n// src/validations/maxValue/maxValue.ts\nfunction maxValue(requirement, message = \"Invalid value\") {\n  return {\n    type: \"max_value\",\n    async: false,\n    message,\n    requirement,\n    _parse(input) {\n      return input > this.requirement ? getPipeIssues(this.type, this.message, input, this.requirement) : getOutput(input);\n    }\n  };\n}\nvar maxRange = maxValue;\n\n// src/validations/minBytes/minBytes.ts\nfunction minBytes(requirement, message = \"Invalid byte length\") {\n  return {\n    type: \"min_bytes\",\n    async: false,\n    message,\n    requirement,\n    _parse(input) {\n      return new TextEncoder().encode(input).length < this.requirement ? getPipeIssues(this.type, this.message, input, this.requirement) : getOutput(input);\n    }\n  };\n}\n\n// src/validations/mimeType/mimeType.ts\nfunction mimeType(requirement, message = \"Invalid MIME type\") {\n  return {\n    type: \"mime_type\",\n    async: false,\n    message,\n    requirement,\n    _parse(input) {\n      return !this.requirement.includes(input.type) ? getPipeIssues(this.type, this.message, input, this.requirement) : getOutput(input);\n    }\n  };\n}\n\n// src/validations/minLength/minLength.ts\nfunction minLength(requirement, message = \"Invalid length\") {\n  return {\n    type: \"min_length\",\n    async: false,\n    message,\n    requirement,\n    _parse(input) {\n      return input.length < this.requirement ? getPipeIssues(this.type, this.message, input, this.requirement) : getOutput(input);\n    }\n  };\n}\n\n// src/validations/minSize/minSize.ts\nfunction minSize(requirement, message = \"Invalid size\") {\n  return {\n    type: \"min_size\",\n    async: false,\n    message,\n    requirement,\n    _parse(input) {\n      return input.size < this.requirement ? getPipeIssues(this.type, this.message, input, this.requirement) : getOutput(input);\n    }\n  };\n}\n\n// src/validations/minValue/minValue.ts\nfunction minValue(requirement, message = \"Invalid value\") {\n  return {\n    type: \"min_value\",\n    async: false,\n    message,\n    requirement,\n    _parse(input) {\n      return input < this.requirement ? getPipeIssues(this.type, this.message, input, this.requirement) : getOutput(input);\n    }\n  };\n}\nvar minRange = minValue;\n\n// src/validations/multipleOf/multipleOf.ts\nfunction multipleOf(requirement, message = \"Invalid multiple\") {\n  return {\n    type: \"multiple_of\",\n    async: false,\n    message,\n    requirement,\n    _parse(input) {\n      return input % this.requirement !== 0 ? getPipeIssues(this.type, this.message, input, this.requirement) : getOutput(input);\n    }\n  };\n}\n\n// src/validations/notBytes/notBytes.ts\nfunction notBytes(requirement, message = \"Invalid byte length\") {\n  return {\n    type: \"not_bytes\",\n    async: false,\n    message,\n    requirement,\n    _parse(input) {\n      return new TextEncoder().encode(input).length === this.requirement ? getPipeIssues(this.type, this.message, input, this.requirement) : getOutput(input);\n    }\n  };\n}\n\n// src/validations/notLength/notLength.ts\nfunction notLength(requirement, message = \"Invalid length\") {\n  return {\n    type: \"not_length\",\n    async: false,\n    message,\n    requirement,\n    _parse(input) {\n      return input.length === this.requirement ? getPipeIssues(this.type, this.message, input, this.requirement) : getOutput(input);\n    }\n  };\n}\n\n// src/validations/notSize/notSize.ts\nfunction notSize(requirement, message = \"Invalid size\") {\n  return {\n    type: \"not_size\",\n    async: false,\n    message,\n    requirement,\n    _parse(input) {\n      return input.size === this.requirement ? getPipeIssues(this.type, this.message, input, this.requirement) : getOutput(input);\n    }\n  };\n}\n\n// src/validations/notValue/notValue.ts\nfunction notValue(requirement, message = \"Invalid value\") {\n  return {\n    type: \"not_value\",\n    async: false,\n    message,\n    requirement,\n    _parse(input) {\n      return input === this.requirement ? getPipeIssues(this.type, this.message, input, this.requirement) : getOutput(input);\n    }\n  };\n}\n\n// src/validations/regex/regex.ts\nfunction regex(requirement, message = \"Invalid regex\") {\n  return {\n    type: \"regex\",\n    async: false,\n    message,\n    requirement,\n    _parse(input) {\n      return !this.requirement.test(input) ? getPipeIssues(this.type, this.message, input, this.requirement) : getOutput(input);\n    }\n  };\n}\n\n// src/validations/safeInteger/safeInteger.ts\nfunction safeInteger(message = \"Invalid safe integer\") {\n  return {\n    type: \"safe_integer\",\n    async: false,\n    message,\n    requirement: Number.isSafeInteger,\n    _parse(input) {\n      return !this.requirement(input) ? getPipeIssues(this.type, this.message, input, this.requirement) : getOutput(input);\n    }\n  };\n}\n\n// src/validations/size/size.ts\nfunction size(requirement, message = \"Invalid size\") {\n  return {\n    type: \"size\",\n    async: false,\n    message,\n    requirement,\n    _parse(input) {\n      return input.size !== this.requirement ? getPipeIssues(this.type, this.message, input, this.requirement) : getOutput(input);\n    }\n  };\n}\n\n// src/validations/startsWith/startsWith.ts\nfunction startsWith(requirement, message = \"Invalid start\") {\n  return {\n    type: \"stars_with\",\n    async: false,\n    message,\n    requirement,\n    _parse(input) {\n      return !input.startsWith(this.requirement) ? getPipeIssues(this.type, this.message, input, this.requirement) : getOutput(input);\n    }\n  };\n}\n\n// src/validations/ulid/ulid.ts\nfunction ulid(message = \"Invalid ULID\") {\n  return {\n    type: \"ulid\",\n    async: false,\n    message,\n    requirement: ULID_REGEX,\n    _parse(input) {\n      return !this.requirement.test(input) ? getPipeIssues(this.type, this.message, input, this.requirement) : getOutput(input);\n    }\n  };\n}\n\n// src/validations/url/url.ts\nfunction url(message = \"Invalid URL\") {\n  return {\n    type: \"url\",\n    async: false,\n    message,\n    requirement(input) {\n      try {\n        new URL(input);\n        return true;\n      } catch {\n        return false;\n      }\n    },\n    _parse(input) {\n      return !this.requirement(input) ? getPipeIssues(this.type, this.message, input, this.requirement) : getOutput(input);\n    }\n  };\n}\n\n// src/validations/uuid/uuid.ts\nfunction uuid(message = \"Invalid UUID\") {\n  return {\n    type: \"uuid\",\n    async: false,\n    message,\n    requirement: UUID_REGEX,\n    _parse(input) {\n      return !this.requirement.test(input) ? getPipeIssues(this.type, this.message, input, this.requirement) : getOutput(input);\n    }\n  };\n}\n\n// src/validations/value/value.ts\nfunction value(requirement, message = \"Invalid value\") {\n  return {\n    type: \"value\",\n    async: false,\n    message,\n    requirement,\n    _parse(input) {\n      return input !== this.requirement ? getPipeIssues(this.type, this.message, input, this.requirement) : getOutput(input);\n    }\n  };\n}\nexport {\n  BrandSymbol,\n  CUID2_REGEX,\n  EMAIL_REGEX,\n  EMOJI_REGEX,\n  IMEI_REGEX,\n  IPV4_REGEX,\n  IPV6_REGEX,\n  ISO_DATE_REGEX,\n  ISO_DATE_TIME_REGEX,\n  ISO_TIMESTAMP_REGEX,\n  ISO_TIME_REGEX,\n  ISO_TIME_SECOND_REGEX,\n  ISO_WEEK_REGEX,\n  ULID_REGEX,\n  UUID_REGEX,\n  ValiError,\n  any,\n  anyAsync,\n  array,\n  arrayAsync,\n  bigint,\n  bigintAsync,\n  blob,\n  blobAsync,\n  boolean,\n  booleanAsync,\n  brand,\n  bytes,\n  coerce,\n  coerceAsync,\n  cuid2,\n  custom,\n  customAsync,\n  date,\n  dateAsync,\n  discriminatedUnion,\n  discriminatedUnionAsync,\n  email,\n  emoji,\n  endsWith,\n  enumAsync,\n  enumType,\n  enumTypeAsync,\n  enum_,\n  equal,\n  excludes,\n  executePipe,\n  executePipeAsync,\n  fallback,\n  fallbackAsync,\n  finite,\n  flatten,\n  getDefault,\n  getDefaultArgs,\n  getDefaultAsync,\n  getDefaults,\n  getDefaultsAsync,\n  getFallback,\n  getFallbackAsync,\n  getFallbacks,\n  getFallbacksAsync,\n  getIssues,\n  getOutput,\n  getPipeIssues,\n  getRestAndDefaultArgs,\n  getSchemaIssues,\n  imei,\n  includes,\n  instance,\n  instanceAsync,\n  integer,\n  intersect,\n  intersection,\n  ip,\n  ipv4,\n  ipv6,\n  is,\n  isLuhnAlgo,\n  isoDate,\n  isoDateTime,\n  isoTime,\n  isoTimeSecond,\n  isoTimestamp,\n  isoWeek,\n  keyof,\n  length,\n  literal,\n  literalAsync,\n  map,\n  mapAsync,\n  maxBytes,\n  maxLength,\n  maxRange,\n  maxSize,\n  maxValue,\n  merge,\n  mergeAsync,\n  mimeType,\n  minBytes,\n  minLength,\n  minRange,\n  minSize,\n  minValue,\n  multipleOf,\n  nan,\n  nanAsync,\n  nativeEnum,\n  nativeEnumAsync,\n  never,\n  neverAsync,\n  nonNullable,\n  nonNullableAsync,\n  nonNullish,\n  nonNullishAsync,\n  nonOptional,\n  nonOptionalAsync,\n  notBytes,\n  notLength,\n  notSize,\n  notValue,\n  nullAsync,\n  nullType,\n  nullTypeAsync,\n  null_,\n  nullable,\n  nullableAsync,\n  nullish,\n  nullishAsync,\n  number,\n  numberAsync,\n  object,\n  objectAsync,\n  omit,\n  omitAsync,\n  optional,\n  optionalAsync,\n  parse,\n  parseAsync,\n  partial,\n  partialAsync,\n  passthrough,\n  passthroughAsync,\n  pick,\n  pickAsync,\n  picklist,\n  picklistAsync,\n  record,\n  recordAsync,\n  recursive,\n  recursiveAsync,\n  regex,\n  required,\n  requiredAsync,\n  safeInteger,\n  safeParse,\n  safeParseAsync,\n  set,\n  setAsync,\n  size,\n  special,\n  specialAsync,\n  startsWith,\n  strict,\n  strictAsync,\n  string,\n  stringAsync,\n  strip,\n  stripAsync,\n  symbol,\n  symbolAsync,\n  toCustom,\n  toCustomAsync,\n  toLowerCase,\n  toMaxValue,\n  toMinValue,\n  toTrimmed,\n  toTrimmedEnd,\n  toTrimmedStart,\n  toUpperCase,\n  transform,\n  transformAsync,\n  tuple,\n  tupleAsync,\n  ulid,\n  undefinedAsync,\n  undefinedType,\n  undefinedTypeAsync,\n  undefined_,\n  union,\n  unionAsync,\n  unknown,\n  unknownAsync,\n  unwrap,\n  url,\n  useDefault,\n  uuid,\n  value,\n  variant,\n  variantAsync,\n  voidAsync,\n  voidType,\n  voidTypeAsync,\n  void_,\n  withDefault\n};\n","function isRecord(value) {\n  return typeof value === \"object\" && value !== null && !Array.isArray(value);\n}\nfunction isArray(value) {\n  return value !== null && Array.isArray(value);\n}\nfunction pathToUrlString(path) {\n  let str = \"\";\n  for (const segment of path) {\n    if (typeof segment === \"string\") {\n      if (str) str += \".\";\n      str += segment;\n      continue;\n    }\n    if (typeof segment === \"number\") {\n      if (str) str += \":\";\n      str += `${segment}`;\n      continue;\n    }\n    if (isArray(segment)) {\n      if (str) str += \":\";\n      str += `${segment.join(\",\")}}`;\n      continue;\n    }\n    if (segment._key) {\n      if (str) str += \":\";\n      str += `${segment._key}`;\n      continue;\n    }\n  }\n  return str;\n}\nconst RE_SEGMENT_WITH_INDEX = /^([A-Za-z]+):([0-9]+)$/;\nconst RE_SEGMENT_WITH_TUPLE = /^([A-Za-z]+):([0-9]+),([0-9]+)$/;\nconst RE_SEGMENT_WITH_KEY = /^([A-Za-z]+):([a-z0-9]+)$/;\nfunction urlStringToPath(str) {\n  const path = [];\n  for (const segment of str.split(\".\")) {\n    const withIndex = RE_SEGMENT_WITH_INDEX.exec(segment);\n    if (withIndex) {\n      path.push(withIndex[1], Number(withIndex[2]));\n      continue;\n    }\n    const withTuple = RE_SEGMENT_WITH_TUPLE.exec(segment);\n    if (withTuple) {\n      path.push(withTuple[1], [Number(withTuple[2]), Number(withTuple[3])]);\n      continue;\n    }\n    const withKey = RE_SEGMENT_WITH_KEY.exec(segment);\n    if (withKey) {\n      path.push(withKey[1], {\n        _key: withKey[2]\n      });\n      continue;\n    }\n    path.push(segment);\n  }\n  return path;\n}\nexport { isArray, isRecord, pathToUrlString, urlStringToPath };\n//# sourceMappingURL=urlStringToPath-ntyJ_1w6.js.map\n","import { resolveMapping, getPublishedId, studioPath, jsonPathToStudioPath, resolvedKeyedSourcePath } from '@sanity/client/csm';\nimport { string, minLength, optional, object, is, safeParse, parse } from 'valibot';\nimport { pathToUrlString, urlStringToPath, isRecord, isArray } from './_chunks/urlStringToPath-ntyJ_1w6.js';\nfunction resolveSanityNode(context, csm, resultPath, keyedResultPath) {\n  const {\n    mapping,\n    pathSuffix\n  } = resolveMapping(resultPath, csm) || {};\n  if (!mapping) {\n    return void 0;\n  }\n  if (mapping.source.type === \"literal\") {\n    return void 0;\n  }\n  if (mapping.source.type === \"unknown\") {\n    return void 0;\n  }\n  const sourceDoc = csm.documents[mapping.source.document];\n  const sourceBasePath = csm.paths[mapping.source.path];\n  if (sourceDoc && sourceBasePath) {\n    return {\n      baseUrl: context.baseUrl,\n      workspace: context.workspace,\n      tool: context.tool,\n      type: sourceDoc._type,\n      id: getPublishedId(sourceDoc._id),\n      path: studioPath.toString(jsonPathToStudioPath(resolvedKeyedSourcePath({\n        keyedResultPath,\n        pathSuffix,\n        sourceBasePath\n      })))\n    };\n  }\n  return void 0;\n}\nconst lengthyStr = string([minLength(1)]);\nconst optionalLengthyStr = optional(lengthyStr);\nconst sanityNodeSchema = object({\n  id: lengthyStr,\n  path: lengthyStr,\n  type: optionalLengthyStr,\n  baseUrl: lengthyStr,\n  workspace: optionalLengthyStr,\n  tool: optionalLengthyStr\n});\nconst sanityLegacyNodeSchema = object({\n  origin: lengthyStr,\n  href: lengthyStr,\n  data: optionalLengthyStr\n});\nfunction isValidSanityNode(node) {\n  return is(sanityNodeSchema, node);\n}\nfunction isValidSanityLegacyNode(node) {\n  return is(sanityLegacyNodeSchema, node);\n}\nfunction encodeSanityNodeData(node) {\n  const {\n    id: _id,\n    path,\n    baseUrl,\n    tool,\n    workspace,\n    type\n  } = node;\n  if (!isValidSanityNode(node)) {\n    return void 0;\n  }\n  const parts = [[\"id\", getPublishedId(_id)], [\"type\", type], [\"path\", pathToUrlString(studioPath.fromString(path))], [\"base\", encodeURIComponent(baseUrl)], [\"workspace\", workspace], [\"tool\", tool]];\n  return parts.filter(([, value]) => !!value).map(part => part.join(\"=\")).join(\";\");\n}\nfunction decodeSanityString(str) {\n  const segments = str.split(\";\");\n  const data = segments.reduce((acc, segment) => {\n    const [key, value] = segment.split(\"=\");\n    if (!key || !value) return acc;\n    switch (key) {\n      case \"id\":\n        acc.id = value;\n        break;\n      case \"type\":\n        acc.type = value;\n        break;\n      case \"path\":\n        acc.path = studioPath.toString(urlStringToPath(value));\n        break;\n      case \"base\":\n        acc.baseUrl = decodeURIComponent(value);\n        break;\n      case \"tool\":\n        acc.tool = value;\n        break;\n      case \"workspace\":\n        acc.workspace = value;\n        break;\n    }\n    return acc;\n  }, {});\n  if (!isValidSanityNode(data)) return void 0;\n  return data;\n}\nfunction decodeSanityJson(data) {\n  const sanityNode = safeParse(sanityNodeSchema, data);\n  if (sanityNode.success) {\n    return sanityNode.output;\n  }\n  const sanityLegacyNode = safeParse(sanityLegacyNodeSchema, data);\n  if (sanityLegacyNode.success) {\n    try {\n      const url = new URL(sanityLegacyNode.output.href, typeof document === \"undefined\" ? \"https://example.com\" : location.origin);\n      if (url.searchParams.size > 0) {\n        return parse(sanityNodeSchema, Object.fromEntries(url.searchParams.entries()));\n      }\n      return sanityLegacyNode.output;\n    } catch (err) {\n      console.error(\"Failed to parse sanity node\", err);\n      return sanityLegacyNode.output;\n    }\n  }\n  return void 0;\n}\nfunction decodeSanityNodeData(str) {\n  try {\n    const json = JSON.parse(str);\n    return decodeSanityJson(json);\n  } catch {\n    return decodeSanityString(str);\n  }\n}\nconst SANITY_KEYS = [\"_createdAt\", \"_dataset\", \"_id\", \"_key\", \"_originalId\", \"_projectId\", \"_ref\", \"_rev\", \"_strengthenOnPublish\", \"_type\", \"_updatedAt\", \"_weak\"];\nfunction isSourceNode(t) {\n  return isRecord(t) && t.$$type$$ === \"sanity\";\n}\nfunction unwrapData(wrapper) {\n  if (wrapper === void 0) {\n    return void 0;\n  }\n  if (wrapper === null) {\n    return null;\n  }\n  if (isSourceNode(wrapper)) {\n    return wrapper.value;\n  }\n  if (isArray(wrapper)) {\n    return wrapper.map(item => unwrapData(item));\n  }\n  if (isRecord(wrapper)) {\n    return Object.fromEntries(Object.entries(wrapper).map(([k, v]) => SANITY_KEYS.includes(k) ? [k, v] : [k, unwrapData(v)]));\n  }\n  throw new Error(\"invalid wrapped value\");\n}\nfunction wrapData(context, value, sourceMap, resultPath = [], keyedResultPath = []) {\n  if (value === void 0) {\n    return void 0;\n  }\n  if (value === null) {\n    return null;\n  }\n  if (isArray(value)) {\n    return value.map((t, idx) => wrapData(context, t, sourceMap, resultPath.concat(idx), keyedResultPath.concat(isRecord(t) && \"_key\" in t && typeof t._key === \"string\" ? {\n      _key: t._key,\n      _index: idx\n    } : idx)));\n  }\n  if (isRecord(value)) {\n    return Object.fromEntries(Object.entries(value).map(([k, v]) => SANITY_KEYS.includes(k) ? [k, v] : [k, wrapData(context, v, sourceMap, resultPath.concat(k), keyedResultPath.concat(k))]));\n  }\n  return {\n    $$type$$: \"sanity\",\n    path: studioPath.toString(jsonPathToStudioPath(resultPath)) || void 0,\n    source: sourceMap ? resolveSanityNode(context, sourceMap, resultPath, keyedResultPath) : void 0,\n    value\n  };\n}\nexport { decodeSanityNodeData, decodeSanityString, encodeSanityNodeData, isValidSanityLegacyNode, isValidSanityNode, resolveSanityNode, unwrapData, wrapData };\n//# sourceMappingURL=csm.js.map\n","import type { HTMLProps, Ref } from 'react'\nimport { createElement, forwardRef } from 'react'\nimport {\n  encodeSanityNodeData,\n  type SourceNode,\n} from 'visual-editing-helpers/csm'\n\nexport interface SanityElementProps {\n  children?: SourceNode | null\n}\n\nexport const SanityElement = forwardRef(function SanityElement(\n  props: { as: string } & SanityElementProps &\n    Omit<HTMLProps<HTMLElement>, 'children'>,\n  ref: Ref<HTMLElement | SVGElement>,\n) {\n  const { as, children: node, ...restProps } = props\n\n  if (node?.source) {\n    return createElement(\n      as,\n      {\n        ...restProps,\n        'data-sanity': encodeSanityNodeData(node.source),\n        ref,\n      },\n      node.value,\n    )\n  }\n\n  return createElement(as, restProps, node?.value)\n})\n","export const svgElements = [\n  'animate',\n  'circle',\n  'defs',\n  'desc',\n  'ellipse',\n  'g',\n  'image',\n  'line',\n  'filter',\n  'marker',\n  'mask',\n  'metadata',\n  'path',\n  'pattern',\n  'polygon',\n  'polyline',\n  'rect',\n  'stop',\n  'svg',\n  'switch',\n  'symbol',\n  'text',\n  'tspan',\n  'use',\n  'view',\n  'clipPath',\n  'feBlend',\n  'feColorMatrix',\n  'feComponentTransfer',\n  'feComposite',\n  'feConvolveMatrix',\n  'feDiffuseLighting',\n  'feDisplacementMap',\n  'feDistantLight',\n  'feDropShadow',\n  'feFlood',\n  'feFuncA',\n  'feFuncB',\n  'feFuncG',\n  'feFuncR',\n  'feGaussianBlur',\n  'feImage',\n  'feMerge',\n  'feMergeNode',\n  'feMorphology',\n  'feOffset',\n  'fePointLight',\n  'feSpecularLighting',\n  'feSpotLight',\n  'feTile',\n  'feTurbulence',\n  'foreignObject',\n  'linearGradient',\n  'radialGradient',\n  'textPath',\n] as const\n","import type {\n  ForwardRefExoticComponent,\n  HTMLProps,\n  ReactElement,\n  Ref,\n  SVGProps,\n} from 'react'\nimport { createElement, forwardRef } from 'react'\n\nimport { htmlElements } from './html'\nimport type { SanityElementProps } from './SanityElement'\nimport { SanityElement } from './SanityElement'\nimport { svgElements } from './svg'\n\nexport type SanityHTMLElements = Record<\n  (typeof htmlElements)[number],\n  ForwardRefExoticComponent<\n    SanityElementProps & Omit<HTMLProps<HTMLElement>, 'children' | 'ref'>\n  >\n>\n\nexport type SanitySVGElements = Record<\n  (typeof svgElements)[number],\n  ForwardRefExoticComponent<\n    SanityElementProps & Omit<SVGProps<SVGElement>, 'children' | 'ref'>\n  >\n>\n\nexport type SanityElements = SanityHTMLElements & SanitySVGElements\n\nfunction isHTMLElement(name: string): name is keyof SanityHTMLElements {\n  return htmlElements.includes(name as any)\n}\n\nfunction isSVGElement(name: string): name is keyof SanitySVGElements {\n  return svgElements.includes(name as any)\n}\n\nconst sanity = new Proxy({} as SanityElements, {\n  get(target: SanityElements, prop: string) {\n    if (isHTMLElement(prop)) {\n      if (target[prop]) return target[prop]\n\n      const SanityComponent = forwardRef(function SanityComponent(\n        props: SanityElementProps &\n          Omit<HTMLProps<HTMLElement>, 'children' | 'ref'>,\n        ref: Ref<HTMLElement>,\n      ): ReactElement {\n        return createElement(SanityElement, { as: prop, ref, ...props })\n      })\n\n      SanityComponent.displayName = `sanity.${prop}`\n\n      target[prop] = SanityComponent\n\n      return SanityComponent\n    }\n\n    if (isSVGElement(prop)) {\n      if (target[prop]) return target[prop]\n\n      const SanityComponent = forwardRef(function SanityComponent(\n        props: SanityElementProps &\n          Omit<SVGProps<SVGElement>, 'children' | 'ref'>,\n        ref: Ref<SVGElement>,\n      ): ReactElement {\n        return createElement(SanityElement, { as: prop, ref, ...props } as any)\n      })\n\n      SanityComponent.displayName = `sanity.${prop}`\n\n      target[prop] = SanityComponent as any\n\n      return SanityComponent\n    }\n\n    throw new Error(`No such element: ${prop}`)\n  },\n})\n\nexport { sanity }\n"],"names":["htmlElements","getIssues","issues","getOutput","output","getIssue","info","issue","reason","validation","origin","message","input","path","abortEarly","abortPipeEarly","skipPipe","getPipeInfo","executePipe","pipe","parseInfo","length","pipeInfo","action","result","_parse","issueInfo","push","getDefaultArgs","arg1","arg2","Array","isArray","getErrorMessage","getPipeIssues","requirement","getRestAndDefaultArgs","arg3","error2","pipe2","error","getSchemaIssues","getDefault","schema","default","is","object","entries","arg4","rest","cachedEntries","type","async","Object","key","value2","pathItem","value","unshift","optional","wrapped","default_","override","string","minLength","isRecord","pathToUrlString","str","segment","join","_key","resolveSanityNode","context","csm","resultPath","keyedResultPath","mapping","pathSuffix","resolveMapping","source","sourceDoc","documents","document","sourceBasePath","paths","baseUrl","workspace","tool","_type","id","getPublishedId","_id","studioPath","toString","jsonPathToStudioPath","resolvedKeyedSourcePath","lengthyStr","optionalLengthyStr","sanityNodeSchema","isValidSanityNode","node","encodeSanityNodeData","parts","fromString","encodeURIComponent","filter","map","part","SANITY_KEYS","isSourceNode","t","$$type$$","unwrapData","wrapper","item","fromEntries","k","v","includes","Error","wrapData","sourceMap","idx","concat","_index","SanityElement","forwardRef","props","ref","as","children","restProps","createElement","svgElements","isHTMLElement","name","isSVGElement","sanity","Proxy","get","target","prop","SanityComponent","displayName"],"mappings":";;AAAO,MAAMA,YAAe,GAAA,CAC1B,GAAA,EACA,MAAA,EACA,SAAA,EACA,MAAA,EACA,SAAA,EACA,OAAA,EACA,OAAA,EACA,GAAA,EACA,MAAA,EACA,KAAA,EACA,KAAA,EACA,KAAA,EACA,YAAA,EACA,MAAA,EACA,IAAA,EACA,QAAA,EACA,QAAA,EACA,SAAA,EACA,MAAA,EACA,MAAA,EACA,KAAA,EACA,UAAA,EACA,MAAA,EACA,UAAA,EACA,IAAA,EACA,KAAA,EACA,SAAA,EACA,KAAA,EACA,QAAA,EACA,KAAA,EACA,IAAA,EACA,IAAA,EACA,IAAA,EACA,OAAA,EACA,UAAA,EACA,YAAA,EACA,QAAA,EACA,QAAA,EACA,MAAA,EACA,IAAA,EACA,IAAA,EACA,IAAA,EACA,IAAA,EACA,IAAA,EACA,IAAA,EACA,MAAA,EACA,QAAA,EACA,QAAA,EACA,IAAA,EACA,MAAA,EACA,GAAA,EACA,QAAA,EACA,KAAA,EACA,OAAA,EACA,KAAA,EACA,KAAA,EACA,QAAA,EACA,OAAA,EACA,QAAA,EACA,IAAA,EACA,MAAA,EACA,MAAA,EACA,KAAA,EACA,MAAA,EACA,MAAA,EACA,UAAA,EACA,MAAA,EACA,OAAA,EACA,KAAA,EACA,UAAA,EACA,QAAA,EACA,IAAA,EACA,UAAA,EACA,QAAA,EACA,QAAA,EACA,GAAA,EACA,OAAA,EACA,SAAA,EACA,KAAA,EACA,UAAA,EACA,GAAA,EACA,IAAA,EACA,IAAA,EACA,MAAA,EACA,GAAA,EACA,MAAA,EACA,QAAA,EACA,SAAA,EACA,QAAA,EACA,OAAA,EACA,QAAA,EACA,MAAA,EACA,QAAA,EACA,OAAA,EACA,KAAA,EACA,SAAA,EACA,KAAA,EACA,OAAA,EACA,OAAA,EACA,IAAA,EACA,UAAA,EACA,OAAA,EACA,IAAA,EACA,OAAA,EACA,MAAA,EACA,OAAA,EACA,IAAA,EACA,OAAA,EACA,GAAA,EACA,IAAA,EACA,KAAA,EACA,OAAA,EACA,KAAA,EACA,SAAA,CACF;;ACnHA;;AAqEA;AACA,SAASC,SAASA,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","x_google_ignoreList":[1]}
\ No newline at end of file
diff --git a/dist/rsc/index.cjs b/dist/rsc/index.cjs
index 0729b75be1dec8e35b6c66a7a9c2c4ff4d2deeb9..7a5561fd9b4d45e1b9eb0a699d37d8eaf6bd0e6e 100644
--- a/dist/rsc/index.cjs
+++ b/dist/rsc/index.cjs
@@ -1 +1,66 @@
-"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var e=require("@sanity/core-loader"),r=require("react"),t=require("../_chunks/useEncodeDataAttribute-vXn1EmPc.cjs");exports.useEncodeDataAttribute=t.u,exports.createQueryStore=t=>{const{createFetcherStore:n,enableLiveMode:o}=e.createQueryStore(t),i={};return{loadQuery:()=>{throw new Error("The `loadQuery` function is server only.")},useQuery:(e,t=i,o={})=>{const[s]=r.useState((()=>o.initial?{perspective:"published",...o.initial}:void 0)),u=r.useMemo((()=>JSON.stringify(t)),[t]),[c,a]=r.useState((()=>n(e,JSON.parse(u),s).value));return r.useEffect((()=>{const r=n(e,JSON.parse(u),s).listen((e=>{a(e)}));return()=>r()}),[u,s,e]),c},setServerClient:()=>{throw new Error("The `setServerClient` function is server only.")},useLiveMode:({allowStudioOrigin:e,client:t,onConnect:n,onDisconnect:i})=>{r.useEffect((()=>{const r=o({allowStudioOrigin:e,client:t,onConnect:n,onDisconnect:i});return()=>r()}),[e,t,n,i])}}};//# sourceMappingURL=index.cjs.map
+'use strict';
+
+Object.defineProperty(exports, '__esModule', {
+  value: true
+});
+var coreLoader = require('@sanity/core-loader');
+var react = require('react');
+var useEncodeDataAttribute = require('../_chunks/useEncodeDataAttribute-wUJAsY0X.cjs');
+const createQueryStore = options => {
+  const {
+    createFetcherStore,
+    enableLiveMode
+  } = coreLoader.createQueryStore(options);
+  const DEFAULT_PARAMS = {};
+  const useQuery = (query, params = DEFAULT_PARAMS, options2 = {}) => {
+    const [initial] = react.useState(() => options2.initial ? {
+      perspective: "published",
+      ...options2.initial
+    } : void 0);
+    const $params = react.useMemo(() => JSON.stringify(params), [params]);
+    const [snapshot, setSnapshot] = react.useState(() => {
+      const fetcher = createFetcherStore(query, JSON.parse($params), initial);
+      return fetcher.value;
+    });
+    react.useEffect(() => {
+      const fetcher = createFetcherStore(query, JSON.parse($params), initial);
+      const unlisten = fetcher.listen(snapshot2 => {
+        setSnapshot(snapshot2);
+      });
+      return () => unlisten();
+    }, [$params, initial, query]);
+    return snapshot;
+  };
+  const useLiveMode = ({
+    allowStudioOrigin,
+    client,
+    onConnect,
+    onDisconnect
+  }) => {
+    react.useEffect(() => {
+      const disableLiveMode = enableLiveMode({
+        allowStudioOrigin,
+        client,
+        onConnect,
+        onDisconnect
+      });
+      return () => disableLiveMode();
+    }, [allowStudioOrigin, client, onConnect, onDisconnect]);
+  };
+  const loadQuery = () => {
+    throw new Error("The `loadQuery` function is server only.");
+  };
+  const setServerClient = () => {
+    throw new Error("The `setServerClient` function is server only.");
+  };
+  return {
+    loadQuery,
+    // @ts-expect-error - update typings
+    useQuery,
+    setServerClient,
+    useLiveMode
+  };
+};
+exports.useEncodeDataAttribute = useEncodeDataAttribute.useEncodeDataAttribute;
+exports.createQueryStore = createQueryStore;
+//# sourceMappingURL=index.cjs.map
diff --git a/dist/rsc/index.cjs.map b/dist/rsc/index.cjs.map
index e3fe5b2bda60b4f2659d8597f1e62aa0d9b28df1..883b0084193eb942fa655a4b95ceb2e62fed9f7d 100644
--- a/dist/rsc/index.cjs.map
+++ b/dist/rsc/index.cjs.map
@@ -1 +1 @@
-{"version":3,"file":"index.cjs","sources":["../../src/rsc/index.ts"],"sourcesContent":["import type { QueryParams } from '@sanity/client'\nimport {\n  createQueryStore as createCoreQueryStore,\n  type CreateQueryStoreOptions,\n  type QueryStoreState,\n} from '@sanity/core-loader'\nimport { useEffect, useMemo, useState } from 'react'\n\nimport { QueryStore, UseLiveModeHook, UseQueryOptions } from './types'\n\nexport type * from './types'\n\nexport const createQueryStore = (\n  options: CreateQueryStoreOptions,\n): QueryStore => {\n  const { createFetcherStore, enableLiveMode } = createCoreQueryStore(options)\n  const DEFAULT_PARAMS = {}\n  const useQuery = <QueryResponseResult, QueryResponseError>(\n    query: string,\n    params: QueryParams = DEFAULT_PARAMS,\n    options: UseQueryOptions<QueryResponseResult> = {},\n  ) => {\n    const [initial] = useState(() =>\n      options.initial\n        ? { perspective: 'published' as const, ...options.initial }\n        : undefined,\n    )\n    const $params = useMemo(() => JSON.stringify(params), [params])\n\n    const [snapshot, setSnapshot] = useState<\n      QueryStoreState<QueryResponseResult, QueryResponseError>\n    >(() => {\n      const fetcher = createFetcherStore<\n        QueryResponseResult,\n        QueryResponseError\n      >(query, JSON.parse($params), initial)\n      return fetcher.value!\n    })\n    useEffect(() => {\n      const fetcher = createFetcherStore<\n        QueryResponseResult,\n        QueryResponseError\n      >(query, JSON.parse($params), initial)\n      const unlisten = fetcher.listen((snapshot) => {\n        setSnapshot(snapshot)\n      })\n\n      return () => unlisten()\n    }, [$params, initial, query])\n    return snapshot\n  }\n\n  const useLiveMode: UseLiveModeHook = ({\n    allowStudioOrigin,\n    client,\n    onConnect,\n    onDisconnect,\n  }) => {\n    useEffect(() => {\n      const disableLiveMode = enableLiveMode({\n        allowStudioOrigin,\n        client,\n        onConnect,\n        onDisconnect,\n      })\n      return () => disableLiveMode()\n    }, [allowStudioOrigin, client, onConnect, onDisconnect])\n  }\n\n  const loadQuery: QueryStore['loadQuery'] = () => {\n    throw new Error('The `loadQuery` function is server only.')\n  }\n\n  const setServerClient: QueryStore['setServerClient'] = () => {\n    throw new Error('The `setServerClient` function is server only.')\n  }\n\n  return {\n    loadQuery,\n    useQuery,\n    setServerClient,\n    useLiveMode,\n  }\n}\n\nexport * from '../useEncodeDataAttribute'\n"],"names":["Object","defineProperty","exports","value","coreLoader","require","react","useEncodeDataAttribute","u","createQueryStore","options","createFetcherStore","enableLiveMode","createCoreQueryStore","DEFAULT_PARAMS","loadQuery","Error","useQuery","query","params","initial","useState","perspective","$params","useMemo","JSON","stringify","snapshot","setSnapshot","parse","useEffect","unlisten","listen","setServerClient","useLiveMode","allowStudioOrigin","client","onConnect","onDisconnect","disableLiveMode"],"mappings":"AAYa,aAAAA,OAAAC,eAAAC,QAAA,aAAA,CAAAC,OAAA,IAAA,IAAAC,EAAAC,QAAA,uBAAAC,EAAAD,QAAA,SAAAE,EAAAF,QAAA,kDAuEbH,QAAAK,uBAAAA,EAAAC,EAAAN,QAAAO,iBAtEEC,IAEA,MAAMC,mBAAEA,EAAAC,eAAoBA,GAAmBC,mBAAqBH,GAC9DI,EAAiB,CAAA,EA6DhB,MAAA,CACLC,UATyCA,KACnC,MAAA,IAAIC,MAAM,2CAA0C,EAS1DC,SA9DeA,CACfC,EACAC,EAAsBL,EACtBJ,EAAgD,MAE1C,MAACU,GAAWC,EAAAA,UAAS,IACzBX,EAAQU,QACJ,CAAEE,YAAa,eAAyBZ,EAAQU,cAChD,IAEAG,EAAUC,WAAQ,IAAMC,KAAKC,UAAUP,IAAS,CAACA,KAEhDQ,EAAUC,GAAeP,YAE9B,IACgBV,EAGdO,EAAOO,KAAKI,MAAMN,GAAUH,GACfjB,QAaV,OAXP2B,EAAAA,WAAU,KACR,MAIMC,EAJUpB,EAGdO,EAAOO,KAAKI,MAAMN,GAAUH,GACLY,QAAQL,IAC/BC,EAAYD,EAAQ,IAGtB,MAAO,IAAMI,GAAS,GACrB,CAACR,EAASH,EAASF,IACfS,CAAA,EA+BPM,gBAPqDA,KAC/C,MAAA,IAAIjB,MAAM,iDAAgD,EAOhEkB,YA7BmCA,EACnCC,oBACAC,SACAC,YACAC,mBAEAR,EAAAA,WAAU,KACR,MAAMS,EAAkB3B,EAAe,CACrCuB,oBACAC,SACAC,YACAC,iBAEF,MAAO,IAAMC,GAAgB,GAC5B,CAACJ,EAAmBC,EAAQC,EAAWC,GAAa,EAgBzD"}
\ No newline at end of file
+{"version":3,"file":"index.cjs","sources":["../../src/rsc/index.ts"],"sourcesContent":["import type { QueryParams } from '@sanity/client'\nimport {\n  createQueryStore as createCoreQueryStore,\n  type CreateQueryStoreOptions,\n  type QueryStoreState,\n} from '@sanity/core-loader'\nimport { useEffect, useMemo, useState } from 'react'\n\nimport { QueryStore, UseLiveModeHook, UseQueryOptions } from './types'\n\nexport type * from './types'\n\nexport const createQueryStore = (\n  options: CreateQueryStoreOptions,\n): QueryStore => {\n  const { createFetcherStore, enableLiveMode } = createCoreQueryStore(options)\n  const DEFAULT_PARAMS = {}\n  const useQuery = <QueryResponseResult, QueryResponseError>(\n    query: string,\n    params: QueryParams = DEFAULT_PARAMS,\n    options: UseQueryOptions<QueryResponseResult> = {},\n  ) => {\n    const [initial] = useState(() =>\n      options.initial\n        ? { perspective: 'published' as const, ...options.initial }\n        : undefined,\n    )\n    const $params = useMemo(() => JSON.stringify(params), [params])\n\n    const [snapshot, setSnapshot] = useState<\n      QueryStoreState<QueryResponseResult, QueryResponseError>\n    >(() => {\n      const fetcher = createFetcherStore<\n        QueryResponseResult,\n        QueryResponseError\n      >(query, JSON.parse($params), initial)\n      return fetcher.value!\n    })\n    useEffect(() => {\n      const fetcher = createFetcherStore<\n        QueryResponseResult,\n        QueryResponseError\n      >(query, JSON.parse($params), initial)\n      const unlisten = fetcher.listen((snapshot) => {\n        setSnapshot(snapshot)\n      })\n\n      return () => unlisten()\n    }, [$params, initial, query])\n    return snapshot\n  }\n\n  const useLiveMode: UseLiveModeHook = ({\n    allowStudioOrigin,\n    client,\n    onConnect,\n    onDisconnect,\n  }) => {\n    useEffect(() => {\n      const disableLiveMode = enableLiveMode({\n        allowStudioOrigin,\n        client,\n        onConnect,\n        onDisconnect,\n      })\n      return () => disableLiveMode()\n    }, [allowStudioOrigin, client, onConnect, onDisconnect])\n  }\n\n  const loadQuery: QueryStore['loadQuery'] = () => {\n    throw new Error('The `loadQuery` function is server only.')\n  }\n\n  const setServerClient: QueryStore['setServerClient'] = () => {\n    throw new Error('The `setServerClient` function is server only.')\n  }\n\n  return {\n    loadQuery,\n    // @ts-expect-error - update typings\n    useQuery,\n    setServerClient,\n    useLiveMode,\n  }\n}\n\nexport * from '../useEncodeDataAttribute'\n"],"names":["createQueryStore","options","createFetcherStore","enableLiveMode","createCoreQueryStore","DEFAULT_PARAMS","useQuery","query","params","initial","useState","perspective","$params","useMemo","JSON","stringify","snapshot","setSnapshot","fetcher","parse","value","useEffect","unlisten","listen","useLiveMode","allowStudioOrigin","client","onConnect","onDisconnect","disableLiveMode","loadQuery","Error","setServerClient"],"mappings":";;;;;;;;AAYa,MAAAA,gBAAA,GACXC,OACe,IAAA;EACf,MAAM;IAAEC,kBAAA;IAAoBC;EAAe,CAAA,GAAIC,4BAAqBH,OAAO,CAAA;EAC3E,MAAMI,iBAAiB,CAAA,CAAC;EACxB,MAAMC,WAAWA,CACfC,KAAA,EACAC,SAAsBH,cACtBJ,EAAAA,QAAAA,GAAgD,EAC7C,KAAA;IACG,MAAA,CAACQ,OAAO,CAAI,GAAAC,KAAA,CAAAA,QAAA,CAAS,MACzBT,SAAQQ,OACJ,GAAA;MAAEE,aAAa,WAAsB;MAAA,GAAGV,QAAQ,CAAAQ;IAChD,CAAA,GAAA,KAAA,CAAA,CACN;IACM,MAAAG,OAAA,GAAUC,cAAQ,MAAMC,IAAA,CAAKC,UAAUP,MAAM,CAAA,EAAG,CAACA,MAAM,CAAC,CAAA;IAE9D,MAAM,CAACQ,QAAA,EAAUC,WAAW,CAAA,GAAIP,eAE9B,MAAM;MACN,MAAMQ,UAAUhB,kBAGd,CAAAK,KAAA,EAAOO,KAAKK,KAAM,CAAAP,OAAO,GAAGH,OAAO,CAAA;MACrC,OAAOS,OAAQ,CAAAE,KAAA;IAAA,CAChB,CAAA;IACDC,KAAAA,CAAAA,SAAA,CAAU,MAAM;MACd,MAAMH,UAAUhB,kBAGd,CAAAK,KAAA,EAAOO,KAAKK,KAAM,CAAAP,OAAO,GAAGH,OAAO,CAAA;MACrC,MAAMa,QAAW,GAAAJ,OAAA,CAAQK,MAAO,CAACP,SAAa,IAAA;QAC5CC,WAAA,CAAYD,SAAQ,CAAA;MAAA,CACrB,CAAA;MAED,OAAO,MAAMM,QAAS,CAAA,CAAA;IACrB,CAAA,EAAA,CAACV,OAAS,EAAAH,OAAA,EAASF,KAAK,CAAC,CAAA;IACrB,OAAAS,QAAA;EAAA,CACT;EAEA,MAAMQ,cAA+BA,CAAC;IACpCC,iBAAA;IACAC,MAAA;IACAC,SAAA;IACAC;EAAA,CACI,KAAA;IACJP,KAAAA,CAAAA,SAAA,CAAU,MAAM;MACd,MAAMQ,kBAAkB1B,cAAe,CAAA;QACrCsB,iBAAA;QACAC,MAAA;QACAC,SAAA;QACAC;MAAA,CACD,CAAA;MACD,OAAO,MAAMC,eAAgB,CAAA,CAAA;OAC5B,CAACJ,iBAAA,EAAmBC,MAAQ,EAAAC,SAAA,EAAWC,YAAY,CAAC,CAAA;EAAA,CACzD;EAEA,MAAME,YAAqCA,CAAA,KAAM;IACzC,MAAA,IAAIC,MAAM,0CAA0C,CAAA;EAAA,CAC5D;EAEA,MAAMC,kBAAiDA,CAAA,KAAM;IACrD,MAAA,IAAID,MAAM,gDAAgD,CAAA;EAAA,CAClE;EAEO,OAAA;IACLD,SAAA;IAAA;IAEAxB,QAAA;IACA0B,eAAA;IACAR;EAAA,CACF;AACF,CAAA;;"}
\ No newline at end of file
diff --git a/dist/rsc/index.d.ts b/dist/rsc/index.d.ts
index 23984cfa661e471be8c8dc265f3efccb55c082ff..f66f8a405b24a908accdef28ca5d96d095b3b83c 100644
--- a/dist/rsc/index.d.ts
+++ b/dist/rsc/index.d.ts
@@ -20,7 +20,7 @@ export declare type EncodeDataAttributeCallback = (
   path: StudioPathLike,
 ) => string | undefined
 
-export declare interface QueryOptions<T = 'next'> {
+export declare interface LoadQueryOptions<T = 'next'> {
   /**
    * The perspective used to fetch the data, if not provided it'll assume 'published'
    */
@@ -29,6 +29,8 @@ export declare interface QueryOptions<T = 'next'> {
   next?: T extends keyof RequestInit ? RequestInit[T] : never
 }
 
+declare type NonUndefinedGuard<T> = T extends undefined ? never : T
+
 export declare interface QueryResponseInitial<QueryResponseResult> {
   data: QueryResponseResult
   sourceMap: ContentSourceMap | undefined
@@ -38,14 +40,36 @@ export declare interface QueryResponseInitial<QueryResponseResult> {
   perspective?: ClientPerspective
 }
 
-export declare interface QueryStore {
+export declare type QueryStore = QueryStore_2<LoadQueryOptions>
+
+declare interface QueryStore_2<
+  LoadQueryOptions = {
+    perspective?: ClientPerspective
+  },
+> {
   loadQuery: <QueryResponseResult>(
     query: string,
     params?: QueryParams,
-    options?: QueryOptions,
+    options?: LoadQueryOptions,
   ) => Promise<QueryResponseInitial<QueryResponseResult>>
   setServerClient: ReturnType<typeof createQueryStore_2>['setServerClient']
-  useQuery: UseQueryHook
+  useQuery: {
+    <QueryResponseResult = unknown, QueryResponseError = unknown>(
+      query: string,
+      params?: QueryParams,
+      options?: UseQueryOptionsUndefinedInitial,
+    ): QueryStoreState<QueryResponseResult, QueryResponseError>
+    <QueryResponseResult = unknown, QueryResponseError = unknown>(
+      query: string,
+      params?: QueryParams,
+      options?: UseQueryOptionsDefinedInitial<QueryResponseResult>,
+    ): Omit<
+      QueryStoreState<QueryResponseResult, QueryResponseError>,
+      'data'
+    > & {
+      data: QueryResponseResult
+    }
+  }
   useLiveMode: UseLiveModeHook
 }
 
@@ -93,6 +117,48 @@ export declare interface UseQueryOptions<QueryResponseResult = unknown> {
   initial?: QueryResponseInitial<QueryResponseResult>
 }
 
+export declare interface UseQueryOptionsDefinedInitial<
+  QueryResponseResult = unknown,
+> {
+  /**
+   * Initial `data` and `sourceMap`, used with SSR hydration and is required if `ssr: true`
+   * and an optional speed optimization if `ssr: false`.
+   * It's recommended to set `initial` to the return value of `loadQuery()`.
+   * @example
+   * ```ts
+   * const query = `*[_type == "author" && slug.current == $slug][0]`
+   * export const getServerSideProps = async ({params}) => {
+   *   const initial = await loadQuery<AuhthorType>(query, params)
+   *   return { props: { params, initial } }
+   * }
+   * export default function Page({params, initial}) {
+   *   const {data} = useQuery<AuthorType>(query, params, {initial})
+   * }
+   * ```
+   */
+  initial: NonUndefinedGuard<QueryResponseInitial<QueryResponseResult>>
+}
+
+export declare interface UseQueryOptionsUndefinedInitial {
+  /**
+   * Initial `data` and `sourceMap`, used with SSR hydration and is required if `ssr: true`
+   * and an optional speed optimization if `ssr: false`.
+   * It's recommended to set `initial` to the return value of `loadQuery()`.
+   * @example
+   * ```ts
+   * const query = `*[_type == "author" && slug.current == $slug][0]`
+   * export const getServerSideProps = async ({params}) => {
+   *   const initial = await loadQuery<AuhthorType>(query, params)
+   *   return { props: { params, initial } }
+   * }
+   * export default function Page({params, initial}) {
+   *   const {data} = useQuery<AuthorType>(query, params, {initial})
+   * }
+   * ```
+   */
+  initial?: undefined
+}
+
 export * from '@sanity/core-loader'
 
 export {}
diff --git a/dist/rsc/index.js b/dist/rsc/index.js
index 89cfe53d3e66db6c9d32182447f6549b931bc939..227c933288016a370f0be8308460f9653a42a3f0 100644
--- a/dist/rsc/index.js
+++ b/dist/rsc/index.js
@@ -1 +1,60 @@
-import{createQueryStore as e}from"@sanity/core-loader";import{useState as r,useMemo as t,useEffect as n}from"react";export{u as useEncodeDataAttribute}from"../_chunks/useEncodeDataAttribute-mY2QBNF1.js";const o=o=>{const{createFetcherStore:i,enableLiveMode:s}=e(o),c={};return{loadQuery:()=>{throw new Error("The `loadQuery` function is server only.")},useQuery:(e,o=c,s={})=>{const[u]=r((()=>s.initial?{perspective:"published",...s.initial}:void 0)),a=t((()=>JSON.stringify(o)),[o]),[l,d]=r((()=>i(e,JSON.parse(a),u).value));return n((()=>{const r=i(e,JSON.parse(a),u).listen((e=>{d(e)}));return()=>r()}),[a,u,e]),l},setServerClient:()=>{throw new Error("The `setServerClient` function is server only.")},useLiveMode:({allowStudioOrigin:e,client:r,onConnect:t,onDisconnect:o})=>{n((()=>{const n=s({allowStudioOrigin:e,client:r,onConnect:t,onDisconnect:o});return()=>n()}),[e,r,t,o])}}};export{o as createQueryStore};//# sourceMappingURL=index.js.map
+import { createQueryStore as createQueryStore$1 } from '@sanity/core-loader';
+import { useState, useMemo, useEffect } from 'react';
+export { useEncodeDataAttribute } from '../_chunks/useEncodeDataAttribute-RKZGuQWJ.js';
+const createQueryStore = options => {
+  const {
+    createFetcherStore,
+    enableLiveMode
+  } = createQueryStore$1(options);
+  const DEFAULT_PARAMS = {};
+  const useQuery = (query, params = DEFAULT_PARAMS, options2 = {}) => {
+    const [initial] = useState(() => options2.initial ? {
+      perspective: "published",
+      ...options2.initial
+    } : void 0);
+    const $params = useMemo(() => JSON.stringify(params), [params]);
+    const [snapshot, setSnapshot] = useState(() => {
+      const fetcher = createFetcherStore(query, JSON.parse($params), initial);
+      return fetcher.value;
+    });
+    useEffect(() => {
+      const fetcher = createFetcherStore(query, JSON.parse($params), initial);
+      const unlisten = fetcher.listen(snapshot2 => {
+        setSnapshot(snapshot2);
+      });
+      return () => unlisten();
+    }, [$params, initial, query]);
+    return snapshot;
+  };
+  const useLiveMode = ({
+    allowStudioOrigin,
+    client,
+    onConnect,
+    onDisconnect
+  }) => {
+    useEffect(() => {
+      const disableLiveMode = enableLiveMode({
+        allowStudioOrigin,
+        client,
+        onConnect,
+        onDisconnect
+      });
+      return () => disableLiveMode();
+    }, [allowStudioOrigin, client, onConnect, onDisconnect]);
+  };
+  const loadQuery = () => {
+    throw new Error("The `loadQuery` function is server only.");
+  };
+  const setServerClient = () => {
+    throw new Error("The `setServerClient` function is server only.");
+  };
+  return {
+    loadQuery,
+    // @ts-expect-error - update typings
+    useQuery,
+    setServerClient,
+    useLiveMode
+  };
+};
+export { createQueryStore };
+//# sourceMappingURL=index.js.map
diff --git a/dist/rsc/index.js.map b/dist/rsc/index.js.map
index 8fadc9abf2469ebfcd46f064ce476a28013f5916..fa09baf159641cec12b731452454cd52ea0cce02 100644
--- a/dist/rsc/index.js.map
+++ b/dist/rsc/index.js.map
@@ -1 +1 @@
-{"version":3,"file":"index.js","sources":["../../src/rsc/index.ts"],"sourcesContent":["import type { QueryParams } from '@sanity/client'\nimport {\n  createQueryStore as createCoreQueryStore,\n  type CreateQueryStoreOptions,\n  type QueryStoreState,\n} from '@sanity/core-loader'\nimport { useEffect, useMemo, useState } from 'react'\n\nimport { QueryStore, UseLiveModeHook, UseQueryOptions } from './types'\n\nexport type * from './types'\n\nexport const createQueryStore = (\n  options: CreateQueryStoreOptions,\n): QueryStore => {\n  const { createFetcherStore, enableLiveMode } = createCoreQueryStore(options)\n  const DEFAULT_PARAMS = {}\n  const useQuery = <QueryResponseResult, QueryResponseError>(\n    query: string,\n    params: QueryParams = DEFAULT_PARAMS,\n    options: UseQueryOptions<QueryResponseResult> = {},\n  ) => {\n    const [initial] = useState(() =>\n      options.initial\n        ? { perspective: 'published' as const, ...options.initial }\n        : undefined,\n    )\n    const $params = useMemo(() => JSON.stringify(params), [params])\n\n    const [snapshot, setSnapshot] = useState<\n      QueryStoreState<QueryResponseResult, QueryResponseError>\n    >(() => {\n      const fetcher = createFetcherStore<\n        QueryResponseResult,\n        QueryResponseError\n      >(query, JSON.parse($params), initial)\n      return fetcher.value!\n    })\n    useEffect(() => {\n      const fetcher = createFetcherStore<\n        QueryResponseResult,\n        QueryResponseError\n      >(query, JSON.parse($params), initial)\n      const unlisten = fetcher.listen((snapshot) => {\n        setSnapshot(snapshot)\n      })\n\n      return () => unlisten()\n    }, [$params, initial, query])\n    return snapshot\n  }\n\n  const useLiveMode: UseLiveModeHook = ({\n    allowStudioOrigin,\n    client,\n    onConnect,\n    onDisconnect,\n  }) => {\n    useEffect(() => {\n      const disableLiveMode = enableLiveMode({\n        allowStudioOrigin,\n        client,\n        onConnect,\n        onDisconnect,\n      })\n      return () => disableLiveMode()\n    }, [allowStudioOrigin, client, onConnect, onDisconnect])\n  }\n\n  const loadQuery: QueryStore['loadQuery'] = () => {\n    throw new Error('The `loadQuery` function is server only.')\n  }\n\n  const setServerClient: QueryStore['setServerClient'] = () => {\n    throw new Error('The `setServerClient` function is server only.')\n  }\n\n  return {\n    loadQuery,\n    useQuery,\n    setServerClient,\n    useLiveMode,\n  }\n}\n\nexport * from '../useEncodeDataAttribute'\n"],"names":["createQueryStore$1","useState","useMemo","useEffect","u","createQueryStore","options","createFetcherStore","enableLiveMode","createCoreQueryStore","DEFAULT_PARAMS","loadQuery","Error","useQuery","query","params","initial","perspective","$params","JSON","stringify","snapshot","setSnapshot","parse","value","unlisten","listen","setServerClient","useLiveMode","allowStudioOrigin","client","onConnect","onDisconnect","disableLiveMode"],"mappings":"2BAYaA,MAAA,yCAAAC,aAAAC,eAAAC,MAAA,eAAAC,gCAAA,gDAAA,MAAAC,EACXC,IAEA,MAAMC,mBAAEA,EAAAC,eAAoBA,GAAmBC,EAAqBH,GAC9DI,EAAiB,CAAA,EA6DhB,MAAA,CACLC,UATyCA,KACnC,MAAA,IAAIC,MAAM,2CAA0C,EAS1DC,SA9DeA,CACfC,EACAC,EAAsBL,EACtBJ,EAAgD,MAE1C,MAACU,GAAWf,GAAS,IACzBK,EAAQU,QACJ,CAAEC,YAAa,eAAyBX,EAAQU,cAChD,IAEAE,EAAUhB,GAAQ,IAAMiB,KAAKC,UAAUL,IAAS,CAACA,KAEhDM,EAAUC,GAAerB,GAE9B,IACgBM,EAGdO,EAAOK,KAAKI,MAAML,GAAUF,GACfQ,QAaV,OAXPrB,GAAU,KACR,MAIMsB,EAJUlB,EAGdO,EAAOK,KAAKI,MAAML,GAAUF,GACLU,QAAQL,IAC/BC,EAAYD,EAAQ,IAGtB,MAAO,IAAMI,GAAS,GACrB,CAACP,EAASF,EAASF,IACfO,CAAA,EA+BPM,gBAPqDA,KAC/C,MAAA,IAAIf,MAAM,iDAAgD,EAOhEgB,YA7BmCA,EACnCC,oBACAC,SACAC,YACAC,mBAEA7B,GAAU,KACR,MAAM8B,EAAkBzB,EAAe,CACrCqB,oBACAC,SACAC,YACAC,iBAEF,MAAO,IAAMC,GAAgB,GAC5B,CAACJ,EAAmBC,EAAQC,EAAWC,GAAa,EAgBzD,SACF3B"}
\ No newline at end of file
+{"version":3,"file":"index.js","sources":["../../src/rsc/index.ts"],"sourcesContent":["import type { QueryParams } from '@sanity/client'\nimport {\n  createQueryStore as createCoreQueryStore,\n  type CreateQueryStoreOptions,\n  type QueryStoreState,\n} from '@sanity/core-loader'\nimport { useEffect, useMemo, useState } from 'react'\n\nimport { QueryStore, UseLiveModeHook, UseQueryOptions } from './types'\n\nexport type * from './types'\n\nexport const createQueryStore = (\n  options: CreateQueryStoreOptions,\n): QueryStore => {\n  const { createFetcherStore, enableLiveMode } = createCoreQueryStore(options)\n  const DEFAULT_PARAMS = {}\n  const useQuery = <QueryResponseResult, QueryResponseError>(\n    query: string,\n    params: QueryParams = DEFAULT_PARAMS,\n    options: UseQueryOptions<QueryResponseResult> = {},\n  ) => {\n    const [initial] = useState(() =>\n      options.initial\n        ? { perspective: 'published' as const, ...options.initial }\n        : undefined,\n    )\n    const $params = useMemo(() => JSON.stringify(params), [params])\n\n    const [snapshot, setSnapshot] = useState<\n      QueryStoreState<QueryResponseResult, QueryResponseError>\n    >(() => {\n      const fetcher = createFetcherStore<\n        QueryResponseResult,\n        QueryResponseError\n      >(query, JSON.parse($params), initial)\n      return fetcher.value!\n    })\n    useEffect(() => {\n      const fetcher = createFetcherStore<\n        QueryResponseResult,\n        QueryResponseError\n      >(query, JSON.parse($params), initial)\n      const unlisten = fetcher.listen((snapshot) => {\n        setSnapshot(snapshot)\n      })\n\n      return () => unlisten()\n    }, [$params, initial, query])\n    return snapshot\n  }\n\n  const useLiveMode: UseLiveModeHook = ({\n    allowStudioOrigin,\n    client,\n    onConnect,\n    onDisconnect,\n  }) => {\n    useEffect(() => {\n      const disableLiveMode = enableLiveMode({\n        allowStudioOrigin,\n        client,\n        onConnect,\n        onDisconnect,\n      })\n      return () => disableLiveMode()\n    }, [allowStudioOrigin, client, onConnect, onDisconnect])\n  }\n\n  const loadQuery: QueryStore['loadQuery'] = () => {\n    throw new Error('The `loadQuery` function is server only.')\n  }\n\n  const setServerClient: QueryStore['setServerClient'] = () => {\n    throw new Error('The `setServerClient` function is server only.')\n  }\n\n  return {\n    loadQuery,\n    // @ts-expect-error - update typings\n    useQuery,\n    setServerClient,\n    useLiveMode,\n  }\n}\n\nexport * from '../useEncodeDataAttribute'\n"],"names":["createQueryStore","options","createFetcherStore","enableLiveMode","createCoreQueryStore","DEFAULT_PARAMS","useQuery","query","params","initial","useState","perspective","$params","useMemo","JSON","stringify","snapshot","setSnapshot","fetcher","parse","value","useEffect","unlisten","listen","useLiveMode","allowStudioOrigin","client","onConnect","onDisconnect","disableLiveMode","loadQuery","Error","setServerClient"],"mappings":";;;AAYa,MAAAA,gBAAA,GACXC,OACe,IAAA;EACf,MAAM;IAAEC,kBAAA;IAAoBC;EAAe,CAAA,GAAIC,mBAAqBH,OAAO,CAAA;EAC3E,MAAMI,iBAAiB,CAAA,CAAC;EACxB,MAAMC,WAAWA,CACfC,KAAA,EACAC,SAAsBH,cACtBJ,EAAAA,QAAAA,GAAgD,EAC7C,KAAA;IACG,MAAA,CAACQ,OAAO,CAAI,GAAAC,QAAA,CAAS,MACzBT,SAAQQ,OACJ,GAAA;MAAEE,aAAa,WAAsB;MAAA,GAAGV,QAAQ,CAAAQ;IAChD,CAAA,GAAA,KAAA,CAAA,CACN;IACM,MAAAG,OAAA,GAAUC,QAAQ,MAAMC,IAAA,CAAKC,UAAUP,MAAM,CAAA,EAAG,CAACA,MAAM,CAAC,CAAA;IAE9D,MAAM,CAACQ,QAAA,EAAUC,WAAW,CAAA,GAAIP,SAE9B,MAAM;MACN,MAAMQ,UAAUhB,kBAGd,CAAAK,KAAA,EAAOO,KAAKK,KAAM,CAAAP,OAAO,GAAGH,OAAO,CAAA;MACrC,OAAOS,OAAQ,CAAAE,KAAA;IAAA,CAChB,CAAA;IACDC,SAAA,CAAU,MAAM;MACd,MAAMH,UAAUhB,kBAGd,CAAAK,KAAA,EAAOO,KAAKK,KAAM,CAAAP,OAAO,GAAGH,OAAO,CAAA;MACrC,MAAMa,QAAW,GAAAJ,OAAA,CAAQK,MAAO,CAACP,SAAa,IAAA;QAC5CC,WAAA,CAAYD,SAAQ,CAAA;MAAA,CACrB,CAAA;MAED,OAAO,MAAMM,QAAS,CAAA,CAAA;IACrB,CAAA,EAAA,CAACV,OAAS,EAAAH,OAAA,EAASF,KAAK,CAAC,CAAA;IACrB,OAAAS,QAAA;EAAA,CACT;EAEA,MAAMQ,cAA+BA,CAAC;IACpCC,iBAAA;IACAC,MAAA;IACAC,SAAA;IACAC;EAAA,CACI,KAAA;IACJP,SAAA,CAAU,MAAM;MACd,MAAMQ,kBAAkB1B,cAAe,CAAA;QACrCsB,iBAAA;QACAC,MAAA;QACAC,SAAA;QACAC;MAAA,CACD,CAAA;MACD,OAAO,MAAMC,eAAgB,CAAA,CAAA;OAC5B,CAACJ,iBAAA,EAAmBC,MAAQ,EAAAC,SAAA,EAAWC,YAAY,CAAC,CAAA;EAAA,CACzD;EAEA,MAAME,YAAqCA,CAAA,KAAM;IACzC,MAAA,IAAIC,MAAM,0CAA0C,CAAA;EAAA,CAC5D;EAEA,MAAMC,kBAAiDA,CAAA,KAAM;IACrD,MAAA,IAAID,MAAM,gDAAgD,CAAA;EAAA,CAClE;EAEO,OAAA;IACLD,SAAA;IAAA;IAEAxB,QAAA;IACA0B,eAAA;IACAR;EAAA,CACF;AACF,CAAA;"}
\ No newline at end of file
diff --git a/dist/rsc/index.react-server.js b/dist/rsc/index.react-server.js
index 4c46edfc5cb69946aeb41eabe179570ee256f1d9..8eedde843a072ad63d1593a8a2ee0c520062d6a6 100644
--- a/dist/rsc/index.react-server.js
+++ b/dist/rsc/index.react-server.js
@@ -1 +1,54 @@
-import{createQueryStore as e}from"@sanity/core-loader";const t=t=>{if(!t.ssr)throw new Error("When using React Server Components the `ssr` option must be set to `true`.");const{setServerClient:n,unstable__serverClient:r}=e(t);return{loadQuery:async(e,t={},n={})=>{const{perspective:o="published"}=n;if("previewDrafts"===o&&!r.canPreviewDrafts)throw new Error('You cannot use "previewDrafts" unless you set a "token" in the "client" instance you\'re pasing to "setServerClient".');const s="published"!==o||r.instance.config().useCdn||n.cache||n.next?r.instance.config().useCdn?r.instance.withConfig({useCdn:!1}):r.instance:r.instance.withConfig({useCdn:!0}),{result:i,resultSourceMap:c}=await s.fetch(e,t,{filterResponse:!1,cache:n.next?void 0:"no-store",...n,perspective:o});return{data:i,sourceMap:c,perspective:"previewDrafts"===o?o:void 0}},setServerClient:n,useQuery:()=>{throw new Error("The `useQuery` hook can only be called from a client component.")},useLiveMode:()=>{throw new Error("The `useLiveMode` hook can only be called from a client component.")}}},n=()=>{throw new Error("The `useEncodeDataAttribute` hook can only be called from a client component.")};export{t as createQueryStore,n as useEncodeDataAttribute};//# sourceMappingURL=index.react-server.js.map
+import { createQueryStore as createQueryStore$1 } from '@sanity/core-loader';
+const createQueryStore = options => {
+  if (!options.ssr) {
+    throw new Error("When using React Server Components the `ssr` option must be set to `true`.");
+  }
+  const {
+    setServerClient,
+    unstable__serverClient
+  } = createQueryStore$1(options);
+  const loadQuery = async (query, params = {}, options2 = {}) => {
+    const {
+      perspective = "published"
+    } = options2;
+    if (perspective === "previewDrafts" && !unstable__serverClient.canPreviewDrafts) {
+      throw new Error(`You cannot use "previewDrafts" unless you set a "token" in the "client" instance you're pasing to "setServerClient".`);
+    }
+    const client = perspective === "published" && !unstable__serverClient.instance.config().useCdn && !options2.cache && !options2.next ? unstable__serverClient.instance.withConfig({
+      useCdn: true
+    }) : unstable__serverClient.instance.config().useCdn ? unstable__serverClient.instance.withConfig({
+      useCdn: false
+    }) : unstable__serverClient.instance;
+    const {
+      result,
+      resultSourceMap
+    } = await client.fetch(query, params, {
+      filterResponse: false,
+      cache: options2.next ? void 0 : "no-store",
+      ...options2,
+      perspective
+    });
+    return {
+      data: result,
+      sourceMap: resultSourceMap,
+      perspective: perspective === "previewDrafts" ? perspective : void 0
+    };
+  };
+  const useQuery = () => {
+    throw new Error("The `useQuery` hook can only be called from a client component.");
+  };
+  const useLiveMode = () => {
+    throw new Error("The `useLiveMode` hook can only be called from a client component.");
+  };
+  return {
+    loadQuery,
+    setServerClient,
+    useQuery,
+    useLiveMode
+  };
+};
+const useEncodeDataAttribute = () => {
+  throw new Error("The `useEncodeDataAttribute` hook can only be called from a client component.");
+};
+export { createQueryStore, useEncodeDataAttribute };
+//# sourceMappingURL=index.react-server.js.map
diff --git a/dist/rsc/index.react-server.js.map b/dist/rsc/index.react-server.js.map
index e3882612e77ab8233c700e2585fd27edda8768dc..7fde074b0e7da6529617c87546ad5122ea3fcecf 100644
--- a/dist/rsc/index.react-server.js.map
+++ b/dist/rsc/index.react-server.js.map
@@ -1 +1 @@
-{"version":3,"file":"index.react-server.js","sources":["../../src/rsc/index.react-server.ts"],"sourcesContent":["import type {\n  ClientPerspective,\n  ContentSourceMap,\n  QueryParams,\n} from '@sanity/client'\nimport {\n  createQueryStore as createCoreQueryStore,\n  type CreateQueryStoreOptions,\n} from '@sanity/core-loader'\n\nimport { QueryOptions, QueryStore } from './types'\n\nexport type * from './types'\n\nexport const createQueryStore = (\n  options: CreateQueryStoreOptions,\n): QueryStore => {\n  if (!options.ssr) {\n    throw new Error(\n      'When using React Server Components the `ssr` option must be set to `true`.',\n    )\n  }\n  const { setServerClient, unstable__serverClient } =\n    createCoreQueryStore(options)\n  const loadQuery = async <QueryResponseResult>(\n    query: string,\n    params: QueryParams = {},\n    options: QueryOptions = {},\n  ): Promise<{\n    data: QueryResponseResult\n    sourceMap: ContentSourceMap | undefined\n    perspective?: ClientPerspective\n  }> => {\n    const { perspective = 'published' } = options\n    if (\n      perspective === 'previewDrafts' &&\n      !unstable__serverClient.canPreviewDrafts\n    ) {\n      throw new Error(\n        `You cannot use \"previewDrafts\" unless you set a \"token\" in the \"client\" instance you're pasing to \"setServerClient\".`,\n      )\n    }\n    // Necessary with a new client instanec as `useCdn` can't be set on `client.fetch`\n    const client =\n      perspective === 'published' &&\n      !unstable__serverClient.instance!.config().useCdn &&\n      !options.cache &&\n      !options.next\n        ? unstable__serverClient.instance!.withConfig({ useCdn: true })\n        : 'previewDrafts' && unstable__serverClient.instance!.config().useCdn\n          ? unstable__serverClient.instance!.withConfig({ useCdn: false })\n          : unstable__serverClient.instance!\n    const { result, resultSourceMap } =\n      await client!.fetch<QueryResponseResult>(query, params, {\n        filterResponse: false,\n        cache: options.next ? undefined : 'no-store',\n        ...options,\n        perspective,\n      })\n    return {\n      data: result,\n      sourceMap: resultSourceMap,\n      perspective: perspective === 'previewDrafts' ? perspective : undefined,\n    }\n  }\n\n  const useQuery: QueryStore['useQuery'] = () => {\n    throw new Error(\n      'The `useQuery` hook can only be called from a client component.',\n    )\n  }\n\n  const useLiveMode: QueryStore['useLiveMode'] = () => {\n    throw new Error(\n      'The `useLiveMode` hook can only be called from a client component.',\n    )\n  }\n\n  return {\n    loadQuery,\n    setServerClient,\n    useQuery,\n    useLiveMode,\n  }\n}\n\nexport const useEncodeDataAttribute = (): void => {\n  throw new Error(\n    'The `useEncodeDataAttribute` hook can only be called from a client component.',\n  )\n}\n"],"names":["createQueryStore$1","createQueryStore","options","ssr","Error","setServerClient","unstable__serverClient","createCoreQueryStore","loadQuery","async","query","params","perspective","canPreviewDrafts","client","instance","config","useCdn","cache","next","withConfig","result","resultSourceMap","fetch","filterResponse","data","sourceMap","useQuery","useLiveMode","useEncodeDataAttribute"],"mappings":"2BAcaA,MAAA,sBAAA,MAAAC,EACXC,IAEI,IAACA,EAAQC,IACX,MAAM,IAAIC,MACR,8EAGJ,MAAMC,gBAAEA,EAAAC,uBAAiBA,GACvBC,EAAqBL,GAuDhB,MAAA,CACLM,UAvDgBC,MAChBC,EACAC,EAAsB,CACtBT,EAAAA,EAAwB,MAMlB,MAAAU,YAAEA,EAAc,aAAgBV,EACtC,GACkB,kBAAhBU,IACCN,EAAuBO,iBAExB,MAAM,IAAIT,MACR,yHAIJ,MAAMU,EACY,cAAhBF,GACCN,EAAuBS,SAAUC,SAASC,QAC1Cf,EAAQgB,OACRhB,EAAQiB,KAEcb,EAAuBS,SAAUC,SAASC,OAC3DX,EAAuBS,SAAUK,WAAW,CAAEH,QAAQ,IACtDX,EAAuBS,SAHzBT,EAAuBS,SAAUK,WAAW,CAAEH,QAAQ,KAItDI,OAAEA,kBAAQC,SACRR,EAAQS,MAA2Bb,EAAOC,EAAQ,CACtDa,gBAAgB,EAChBN,MAAOhB,EAAQiB,UAAO,EAAY,cAC/BjB,EACHU,gBAEG,MAAA,CACLa,KAAMJ,EACNK,UAAWJ,EACXV,YAA6B,kBAAhBA,EAAkCA,OAAc,EAC/D,EAiBAP,kBACAsB,SAfuCA,KACvC,MAAM,IAAIvB,MACR,kEACF,EAaAwB,YAV6CA,KAC7C,MAAM,IAAIxB,MACR,qEACF,EAQF,EAGWyB,EAAyBA,KACpC,MAAM,IAAIzB,MACR,gFACF,SACFH,sBAAA4B"}
\ No newline at end of file
+{"version":3,"file":"index.react-server.js","sources":["../../src/rsc/index.react-server.ts"],"sourcesContent":["import type {\n  ClientPerspective,\n  ContentSourceMap,\n  QueryParams,\n} from '@sanity/client'\nimport {\n  createQueryStore as createCoreQueryStore,\n  type CreateQueryStoreOptions,\n} from '@sanity/core-loader'\n\nimport { LoadQueryOptions, QueryStore } from './types'\n\nexport type * from './types'\n\nexport const createQueryStore = (\n  options: CreateQueryStoreOptions,\n): QueryStore => {\n  if (!options.ssr) {\n    throw new Error(\n      'When using React Server Components the `ssr` option must be set to `true`.',\n    )\n  }\n  const { setServerClient, unstable__serverClient } =\n    createCoreQueryStore(options)\n  const loadQuery = async <QueryResponseResult>(\n    query: string,\n    params: QueryParams = {},\n    options: LoadQueryOptions = {},\n  ): Promise<{\n    data: QueryResponseResult\n    sourceMap: ContentSourceMap | undefined\n    perspective?: ClientPerspective\n  }> => {\n    const { perspective = 'published' } = options\n    if (\n      perspective === 'previewDrafts' &&\n      !unstable__serverClient.canPreviewDrafts\n    ) {\n      throw new Error(\n        `You cannot use \"previewDrafts\" unless you set a \"token\" in the \"client\" instance you're pasing to \"setServerClient\".`,\n      )\n    }\n    // Necessary with a new client instanec as `useCdn` can't be set on `client.fetch`\n    const client =\n      perspective === 'published' &&\n      !unstable__serverClient.instance!.config().useCdn &&\n      !options.cache &&\n      !options.next\n        ? unstable__serverClient.instance!.withConfig({ useCdn: true })\n        : 'previewDrafts' && unstable__serverClient.instance!.config().useCdn\n          ? unstable__serverClient.instance!.withConfig({ useCdn: false })\n          : unstable__serverClient.instance!\n    const { result, resultSourceMap } =\n      await client!.fetch<QueryResponseResult>(query, params, {\n        filterResponse: false,\n        cache: options.next ? undefined : 'no-store',\n        ...options,\n        perspective,\n      })\n    return {\n      data: result,\n      sourceMap: resultSourceMap,\n      perspective: perspective === 'previewDrafts' ? perspective : undefined,\n    }\n  }\n\n  const useQuery: QueryStore['useQuery'] = () => {\n    throw new Error(\n      'The `useQuery` hook can only be called from a client component.',\n    )\n  }\n\n  const useLiveMode: QueryStore['useLiveMode'] = () => {\n    throw new Error(\n      'The `useLiveMode` hook can only be called from a client component.',\n    )\n  }\n\n  return {\n    loadQuery,\n    setServerClient,\n    useQuery,\n    useLiveMode,\n  }\n}\n\nexport const useEncodeDataAttribute = (): void => {\n  throw new Error(\n    'The `useEncodeDataAttribute` hook can only be called from a client component.',\n  )\n}\n"],"names":["createQueryStore","options","ssr","Error","setServerClient","unstable__serverClient","createCoreQueryStore","loadQuery","query","params","perspective","canPreviewDrafts","client","instance","config","useCdn","cache","next","withConfig","result","resultSourceMap","fetch","filterResponse","data","sourceMap","useQuery","useLiveMode","useEncodeDataAttribute"],"mappings":";AAca,MAAAA,gBAAA,GACXC,OACe,IAAA;EACX,IAAA,CAACA,QAAQC,GAAK,EAAA;IAChB,MAAM,IAAIC,KAAA,CACR,4EAAA,CACF;EACF;EACA,MAAM;IAAEC,eAAA;IAAiBC;EAAuB,CAAA,GAC9CC,mBAAqBL,OAAO,CAAA;EACxB,MAAAM,SAAA,GAAY,MAAAA,CAChBC,KACA,EAAAC,MAAA,GAAsB,CACtBR,CAAAA,EAAAA,QAAAA,GAA4B,EAKxB,KAAA;IACE,MAAA;MAAES,WAAc,GAAA;IAAgBT,CAAAA,GAAAA,QAAAA;IACtC,IACES,WAAgB,KAAA,eAAA,IAChB,CAACL,sBAAA,CAAuBM,gBACxB,EAAA;MACA,MAAM,IAAIR,KAAA,CACR,sHAAA,CACF;IACF;IAEA,MAAMS,SACJF,WAAgB,KAAA,WAAA,IAChB,CAACL,sBAAA,CAAuBQ,SAAUC,MAAO,CAAA,CAAA,CAAEC,MAC3C,IAAA,CAACd,SAAQe,KACT,IAAA,CAACf,QAAQ,CAAAgB,IAAA,GACLZ,uBAAuBQ,QAAU,CAAAK,UAAA,CAAW;MAAEH,MAAA,EAAQ;KAAM,CAAA,GACzCV,sBAAuB,CAAAQ,QAAA,CAAUC,QAAS,CAAAC,MAAA,GAC3DV,sBAAuB,CAAAQ,QAAA,CAAUK,WAAW;MAAEH,MAAA,EAAQ;IAAM,CAAC,IAC7DV,sBAAuB,CAAAQ,QAAA;IACzB,MAAA;MAAEM;MAAQC;IAAgB,CAAA,GAC9B,MAAMR,MAAQ,CAAAS,KAAA,CAA2Bb,OAAOC,MAAQ,EAAA;MACtDa,cAAgB,EAAA,KAAA;MAChBN,KAAA,EAAOf,QAAQ,CAAAgB,IAAA,GAAO,KAAY,CAAA,GAAA,UAAA;MAClC,GAAGhB,QAAAA;MACHS;IAAA,CACD,CAAA;IACI,OAAA;MACLa,IAAM,EAAAJ,MAAA;MACNK,SAAW,EAAAJ,eAAA;MACXV,WAAA,EAAaA,WAAgB,KAAA,eAAA,GAAkBA,WAAc,GAAA,KAAA;IAAA,CAC/D;EAAA,CACF;EAEA,MAAMe,WAAmCA,CAAA,KAAM;IAC7C,MAAM,IAAItB,KAAA,CACR,iEAAA,CACF;EAAA,CACF;EAEA,MAAMuB,cAAyCA,CAAA,KAAM;IACnD,MAAM,IAAIvB,KAAA,CACR,oEAAA,CACF;EAAA,CACF;EAEO,OAAA;IACLI,SAAA;IACAH,eAAA;IACAqB,QAAA;IACAC;EAAA,CACF;AACF,CAAA;AAEO,MAAMC,yBAAyBA,CAAA,KAAY;EAChD,MAAM,IAAIxB,KAAA,CACR,+EAAA,CACF;AACF,CAAA;"}
